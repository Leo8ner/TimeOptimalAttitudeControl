#include <casadi/casadi.hpp>
#include <toac/optimizer.h>
#include <toac/dynamics.h>
#include <toac/constraints.h>
#include <iostream>
#include <chrono>
#include <toac/helper_functions.h>
#include <toac/pso.h>
#include <cstdlib>

using namespace casadi;

// main function
// int main(int argc, char* argv[]) {
//     // Check command line arguments
//     if (argc != 3) {
//         std::cerr << "Usage: " << argv[0] << " \"phi_i,theta_i,psi_i,wx_i,wy_i,wz_i\" \"phi_f,theta_f,psi_f,wx_f,wy_f,wz_f\"" << std::endl;
//         return 1;
//     }
    
//     try {
//         // Parse command line arguments
//         DM X_0, angles_0;
//         std::tie(X_0, angles_0) = parseStateVector(argv[1]);
//         DM X_f, angles_f;
//         std::tie(X_f, angles_f) = parseStateVector(argv[2]);

//         DM X_guess(n_states, n_stp+1), U_guess(n_controls, n_stp), dt_guess(n_stp,1); // Initial guesses for states, controls, and time steps

//         PSOOptimizer initial_guess(X_0->data(), X_f->data(), true);
//         double w = 1.0; // Inertia weight
//         double c1 = 1.5; // Cognitive weight
//         double c2 = 1.5; // Social weight
//         initial_guess.setPSOParameters(500,1250,w,c1,c2); // Set PSO parameters: iterations, particles, inertia, cognitive, social
//         if(!initial_guess.optimize(X_guess, U_guess, dt_guess)) {
//             std::cerr << "Error: PSO initial guess optimization failed." << std::endl;
//             return -1;
//         }

//         std::cout << "Initial guess generated by PSO." << std::endl;
//         std::cout << "Initial guess state trajectory X_guess:\n" << X_guess << std::endl;
//         std::cout << "Initial guess control trajectory U_guess:\n" << U_guess << std::endl;
//         std::cout << "Initial guess time steps dt_guess:\n" << dt_guess << std::endl;
//         // Start the timer
//         auto start = std::chrono::high_resolution_clock::now();
//         Function solver = get_solver();
        
//         // Constraints (can still use for other constraint values)
//         Constraints cons;
        
        
//         // Call the solver with parsed inputs
//         DMDict inputs = {{"X0", X_0}, {"Xf", X_f}, 
//                          {"X_guess", X_guess}, 
//                          {"U_guess", U_guess}, 
//                          {"dt_guess", dt_guess}};
//         DMDict result = solver(inputs);
        
//         // Stop the timer
//         auto end = std::chrono::high_resolution_clock::now();
//         auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start) / 1000.0;
//         std::cout << "Computation Time: " << elapsed.count() << " s" << std::endl;

//         processResults(result, angles_0, angles_f);
        
//     } catch (const std::exception& e) {
//         std::cerr << "Error: " << e.what() << std::endl;
//         return 1;
//     }
    
//     return 0;
// }

int main(int argc, char* argv[]) {
    // Check command line arguments
    if (argc != 3) {
        std::cerr << "Usage: " << argv[0] << " \"phi_i,theta_i,psi_i,wx_i,wy_i,wz_i\" \"phi_f,theta_f,psi_f,wx_f,wy_f,wz_f\"" << std::endl;
        return 1;
    }
    
    try {

        auto start = std::chrono::high_resolution_clock::now();

        // Parse command line arguments
        casadi::DM X_0, angles_0;
        std::tie(X_0, angles_0) = parseStateVector(argv[1]);
        casadi::DM X_f, angles_f;
        std::tie(X_f, angles_f) = parseStateVector(argv[2]);

        DM X_guess(n_states, (n_stp + 1)), U_guess(n_controls, n_stp), dt_guess(n_stp, 1); // Initial guesses for states, controls, and time steps

        PSOOptimizer initial_guess(X_0->data(), X_f->data(), true);
        double w = 5.0; // Inertia weight
        double c1 = 2.0; // Cognitive weight
        double c2 = 1.0; // Social weight

        initial_guess.setPSOParameters(250,w,c1,c2); // Set PSO parameters: iterations, particles, inertia, cognitive, social
        if(!initial_guess.optimize(X_guess, U_guess, dt_guess)) {
            std::cerr << "Error: PSO initial guess optimization failed." << std::endl;
            return -1;
        }

        Function solver = get_solver();
        
        // Call the solver with parsed inputs
        DMDict inputs = {{"X0", X_0}, {"Xf", X_f}, 
                         {"X_guess", X_guess}, 
                         {"U_guess", U_guess}, 
                         {"dt_guess", dt_guess}};
        DMDict result = solver(inputs);

        DMDict PSOresults = {{"X", X_guess}, {"U", U_guess}, {"T", dt_guess.sum1(0)}, {"dt", dt_guess}};

        // Stop the timer
        auto end = std::chrono::high_resolution_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end - start) / 1000.0;
        std::cout << "Computation Time: " << elapsed.count() << " s" << std::endl;

        processResults(PSOresults, angles_0, angles_f);
        processResults(result, angles_0, angles_f);

        std::cout << "Maneuver duration: " << result["T"] << " s" << std::endl;

    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
    
    return 0;
}