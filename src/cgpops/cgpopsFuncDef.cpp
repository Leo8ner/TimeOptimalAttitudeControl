// Copyright (c) Yunus M. Agamawi and Anil Vithala Rao.  All Rights Reserved
//
// cgpopsFuncDec.cpp
// CGPOPS Software
// Defines functions used in CGPOPS
//

#include "cgpopsFuncDec.hpp"
#include "nlpGlobVarExt.hpp"

////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------NLP Initialization functions-------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLP getInfoNLP(void)    // Get information for transcribed NLP resulting from LGR collocation using defined mesh grid. Input: flag indicating Lavrentiev constraints are being used
{
    int LavrentievConstraintFlag = LavrentievConstraintFlagG;
    infoNLP infonlp;    // contains information for transcribed NLP problem
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        LavrentievConstraintCompG.mat[phase] = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LavrentievTolG.mat[phase] = getDoubleMat(nxG[phase]); // Allocate memory for number of state components in phase
        
        if (LavrentievConstraintFlagG==1)   // If Lavrentiev Constraints set to active
        {
            LavrentievConstraintG.val[phase] = 1;   // Indicate Lavrentiev constraint is active in phase
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                LavrentievConstraintCompG.mat[phase].val[comp] = 1;  // Set Lavrentiev constraint to active for state comp
                LavrentievTolG.mat[phase].val[comp] = LavrentievDefaultTolG;    // Set Lavrentiev constraint tolerance for state comp
            }
        }
    }
    
    //    sysinfoG = getSystemInfo(PG,nsG,nxG,nuG,nqG,NtG);
    //    sysinfoG = getSystemInfo(PG,nsG,nxG,nuG,nqG,NtG,rpmdG);
    
    // Allocate memory for each phase
    nZG     = new int[PG];
    PrIZG   = new int[PG];
    TeIZG   = new int[PG];
    nHG     = new int[PG];
    PrIHG   = new int[PG];
    TeIHG   = new int[PG];
    
    for (int p=0; p<PG; p++)
    {
        nZG[p] = nxG[p]*(NtG[p]+1) + nuG[p]*(NtG[p]+LavrentievConstraintG.val[p]) + nqG[p] + 2;
    };
    
    PrIZG[0]    = 0;
    TeIZG[0]    = PrIZG[0] + nZG[0];
    for (int p=1; p<PG; p++)
    {
        PrIZG[p]    = TeIZG[p-1];
        TeIZG[p]    = PrIZG[p] + nZG[p];
    }
    
    LenZG = TeIZG[PG-1] + nsG;
    
    infonlp.NLPIndZ = getInfoNLPIndZ(1,1);  // Indicate Lavrientiev constraints available
    
    infonlp.NLPGrad = getInfoNLPGrad(infonlp.NLPIndZ);
    
//    for (int p=0; p<PG; p++)
//    {
//        nHG[p] = nxG[p]*(NtG[p]+LavrentievConstraintG.val[p]) + ncG[p]*(NtG[p]+LavrentievConstraintG.val[p]) + nqG[p];
//    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        nHG[phase] = ncG[phase]*(NtG[phase]+LavrentievConstraintG.val[phase]) + nqG[phase]; // Add path constraints applied at each discretization point for control plus number of approximation constraints
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            nHG[phase] = nHG[phase] + NtG[phase] + LavrentievConstraintCompG.mat[phase].val[comp];   // Add defect constraints for each collocation point (plus final point for Lavrentiev Constraint)
        }
    }
    

    PrIHG[0]    = 0;
    TeIHG[0]    = PrIHG[0] + nHG[0];
    for (int p=1; p<PG; p++)
    {
        PrIHG[p]    = TeIHG[p-1];
        TeIHG[p]    = PrIHG[p] + nHG[p];
    }

    if ((DurationFlagG)&&(ContinuityFlagG))
    {
        LenHG = TeIHG[PG-1] + nbG + PG + neG;
    }
    else if (DurationFlagG)
    {
        LenHG = TeIHG[PG-1] + nbG + PG;
    }
    else if (ContinuityFlagG)
    {
        LenHG = TeIHG[PG-1] + nbG + neG;
    }
    else
    {
        LenHG = TeIHG[PG-1] + nbG;
    }

    infonlp.NLPIndH = getInfoNLPIndH(LavrentievConstraintFlag,LavrentievConstraintFlag);    // Indicate Lavrientiev constraints available

    infonlp.NLPJac = getInfoNLPJac(infonlp.NLPIndZ,infonlp.NLPIndH,LavrentievConstraintFlag);   // Indicate Lavrientiev constraints available

    infonlp.NLPHess = getInfoNLPHess(infonlp.NLPIndZ,LavrentievConstraintFlag); // Indicate Lavrientiev constraints available
    
    return infonlp;
}

void setInfoNLPG()
{
    if (initGlobalVarsFlagG==1)
    {
        if (MeshIterG==0)
        {
            for (int p=0; p<PG; p++)
            {
                nxorigG[p] = nxG[p];
                nuorigG[p] = nuG[p];
                nqorigG[p] = nqG[p];
                ncorigG[p] = ncG[p];
                npporigG[p] = nppG[p];
            }
        }
        if ((setRPMDGFlagG==0)||(setRPMDGFlagG<PG))
        {
            printf("\nsetRPMDG called only %d times for %d phases",setRPMDGFlagG,PG);
            setRPMDGFlagG = 0;
            printf("\nUsing DEFAULT Initial Mesh of %d Intervals with %d Collocation Points",numintervalsG,initcolptsG);
            double fraction[numintervalsG];    // Allocate memory for fraction vector for phase 1 mesh
            int colpoints[numintervalsG];      // Allocate memory for colpoints vector for phase 1 mesh
            for (int m=0; m<numintervalsG; m++)
            {
                fraction[m] = 1.0/((double) numintervalsG);
                colpoints[m] = initcolptsG;
            }
            for (int p=0; p<PG; p++)
            {
                setRPMDG(p,numintervalsG,fraction,colpoints);
            }
        }
        for (int p=0; p<PG-1; p++)
        {
            if (ContinuityEnforceG.val[p]==1)
            {
                ContinuityFlagG++;
                neG = neG + nxG[p] + 1;
            }
        }
        if (ContinuityFlagG)
        {
            int ne=0;
            ContinuityCompG = getIntMat(neG);
            ContinuityPhaseG = getIntMat(neG);
            for (int p=0; p<PG-1; p++)
            {
                if (ContinuityEnforceG.val[p]==1)
                {
                    for (int nx=0; nx<=nxG[p]; nx++)
                    {
                        ContinuityCompG.val[ne] = nx;
                        ContinuityPhaseG.val[ne] = p;
                        ne++;
                    }
                }
                ContinuityLBG.mat[p] = getDoubleMat(nxG[p]+1);
                ContinuityUBG.mat[p] = getDoubleMat(nxG[p]+1);
            }
        }
//        printf4MATLAB("ContinuityCompG",ContinuityCompG);
//        printf4MATLAB("ContinuityPhaseG",ContinuityPhaseG);
        infonlpG = getInfoNLP();
        setInfoNLPGFlagG = 1;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}

void getInfoNLPUpdate(int LavrentievConstraintFlag) // Update information for transcribed NLP resulting from LGR collocation using defined mesh grid. Input: flag indicating Lavrentiev constraints are being used
{
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        nHG[phase] = ncG[phase]*(NtG[phase]+LavrentievConstraintG.val[phase]) + nqG[phase]; // Add path constraints applied at each discretization point for control plus number of approximation constraints
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            nHG[phase] = nHG[phase] + NtG[phase] + LavrentievConstraintCompG.mat[phase].val[comp];   // Add defect constraints for each collocation point (plus final point for Lavrentiev Constraint)
        }
    }

    PrIHG[0]    = 0;
    TeIHG[0]    = PrIHG[0] + nHG[0];
    for (int p=1; p<PG; p++)
    {
        PrIHG[p]    = TeIHG[p-1];
        TeIHG[p]    = PrIHG[p] + nHG[p];
    }

    if ((DurationFlagG)&&(ContinuityFlagG))
    {
        LenHG = TeIHG[PG-1] + nbG + PG + neG;
    }
    else if (DurationFlagG)
    {
        LenHG = TeIHG[PG-1] + nbG + PG;
    }
    else if (ContinuityFlagG)
    {
        LenHG = TeIHG[PG-1] + nbG + neG;
    }
    else
    {
        LenHG = TeIHG[PG-1] + nbG;
    }

    infonlpG.NLPIndH = getInfoNLPIndH(LavrentievConstraintFlag,LavrentievConstraintFlag);    // Indicate Lavrientiev constraints available

    infonlpG.NLPJac = getInfoNLPJac(infonlpG.NLPIndZ,infonlpG.NLPIndH,LavrentievConstraintFlag);    // Indicate Lavrientiev constraints available
}

void setRPMDG(int p, int K, double* fraction, int* colpoints)
{
    if (initGlobalVarsFlagG==1)
    {
        rpmdG[p] = getRPMD(K,fraction,colpoints);
        NtG[p] = rpmdG[p].sumColPoints;
        setRPMDGFlagG++;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}

void setNLPPBG(int p, double* x0l, double* x0u, double* xfl, double* xfu, double* xl, double* xu, double* ul, double* uu, double* ql, double* qu, double* cl, double* cu, double t0l ,double t0u, double tfl, double tfu)
{
    if (initGlobalVarsFlagG==1)
    {
        nlpbG.PB[p] = getNLPPB(p,nxG[p],nuG[p],nqG[p],ncG[p],x0l,x0u,xfl,xfu,xl,xu,ul,uu,ql,qu,cl,cu,t0l,t0u,tfl,tfu);
        setNLPPBGFlagG++;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}
void setNLPWBG(double* sl, double* su, double* bl, double* bu)
{
    if (initGlobalVarsFlagG==1)
    {
//        nlpbG.WB = getNLPWB(nsG,nbG,sl,su,bl,bu,PG,DurationFlagG,neG,ContinuityFlagG);
        nlpbG.WB = getNLPWB(nsG,nbG,sl,su,bl,bu,PG,DurationFlagG,neG,ContinuityFlagG,ContinuityCompG,ContinuityPhaseG,ContinuityLBG,ContinuityUBG);
//        printf(nlpbG.WB);
        setNLPWBGFlagG = 1;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}
void setNLPPGG(int p, double* x0g, double* xfg, double* u0g, double* ufg, double* qg, double t0g, double tfg)
{
    if (initGlobalVarsFlagG==1)
    {
        nlpgG.PG[p] = getNLPPG(p,nxG[p],nuG[p],nqG[p],x0g,xfg,u0g,ufg,qg,t0g,tfg);
        setNLPPGGFlagG++;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}
void setNLPWGG(double* sg)
{
    if (initGlobalVarsFlagG==1)
    {
        nlpgG.WG = getNLPWG(nsG,sg);
        setNLPWGGFlagG = 1;
    }
    else
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n---------------------ERROR: Make call to initGlobalVar before setting infonlpG global variable------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------NLP Index Z functions-----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLPIndZ getInfoNLPIndZ(int LavrentievConstraintFlag1, int LavrentievConstraintFlag2)
{
    int l;                      // Variable type holder
    int NLPInd;                 // Index number in NLP Decision Vector
    infoNLPIndZ inlpz(LenZG);   // Information class for NLP Decision Vector
    
    // State variables
    l = 1;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<nxG[i]; j++)    // for each state component in phase
        {
            for (int k=0; k<NtG[i]+1; k++)  // for each discretization point in phase
            {
                NLPInd = mainNLPIndZ(l,i,j,k,1);  // Get NLP index for variable l, phase i, component j, point k
                inlpz.Var[NLPInd]   = l;        // Store variable type for NLP Decision Vector index
                inlpz.Phase[NLPInd] = i;        // Store phase number for NLP Decision Vector index
                inlpz.Comp[NLPInd]  = j;        // Store component number for NLP Decision Vector index
                inlpz.Pt[NLPInd]    = k;        // Store point number for NLP Decision Vector index
            }
        }
    }
    
    // Control variables
    l = 2;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<nuG[i]; j++)    // for each control component in phase
        {
            for (int k=0; k<NtG[i]+LavrentievConstraintG.val[i]; k++)   // for each collocation point in phase (additional point if Lavrentiev constraint is active in phase)
            {
                NLPInd = mainNLPIndZ(l,i,j,k,1);  // Get NLP index for variable l, phase i, component j, point k
                inlpz.Var[NLPInd]   = l;        // Store variable type for NLP Decision Vector index
                inlpz.Phase[NLPInd] = i;        // Store phase number for NLP Decision Vector index
                inlpz.Comp[NLPInd]  = j;        // Store component number for NLP Decision Vector index
                inlpz.Pt[NLPInd]    = k;        // Store point number for NLP Decision Vector index
            }
        }
    }
    
    // Integral variables
    l = 3;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<nqG[i]; j++)    // for each integral component in phase
        {
            NLPInd = mainNLPIndZ(l,i,j,-1,1);   // Get NLP index for variable l, phase i, component j, point k
            inlpz.Var[NLPInd]   = l;        // Store variable type for NLP Decision Vector index
            inlpz.Phase[NLPInd] = i;        // Store phase number for NLP Decision Vector index
            inlpz.Comp[NLPInd]  = j;        // Store component number for NLP Decision Vector index
            inlpz.Pt[NLPInd]    = -1;       // Store point number for NLP Decision Vector index
        }
    }
    
    // Initial variables
    l = 4;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        NLPInd = mainNLPIndZ(l,i,-1,-1,1);  // Get NLP index for variable l, phase i, component j, point k
        inlpz.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
        inlpz.Phase[NLPInd] = i;            // Store phase number for NLP Decision Vector index
        inlpz.Comp[NLPInd]  = -1;           // Store component number for NLP Decision Vector index
        inlpz.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
    }
    
    // Final variables
    l = 5;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        NLPInd = mainNLPIndZ(l,i,-1,-1,1);  // Get NLP index for variable l, phase i, component j, point k
        inlpz.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
        inlpz.Phase[NLPInd] = i;            // Store phase number for NLP Decision Vector index
        inlpz.Comp[NLPInd]  = -1;            // Store component number for NLP Decision Vector index
        inlpz.Pt[NLPInd]    = -1;            // Store point number for NLP Decision Vector index
    }
    
    // Static variables
    l = 6;
    for (int j=0; j<nsG; j++)   // for each static parameter in problem
    {
        NLPInd = mainNLPIndZ(l,-1,j,-1,1);  // Get NLP index for variable l, phase i, component j, point k
        inlpz.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
        inlpz.Phase[NLPInd] = -1;           // Store phase number for NLP Decision Vector index
        inlpz.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
        inlpz.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
    }
    
    return inlpz;
}

int mainNLPIndZ(int l, int i, int j, int k) // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd; // To be returned index in NLP Decision Vector
    
    if (LavrentievConstraintFlagG==1)   // If Lavrentiev constraints marked active
    {
        if (l == 1) // If state variable
        {
            NLPInd = stateNLPInd(i,j,k,LavrentievConstraintFlagG);  // Get NLP index for state variable type
        }
        else if (l == 2)    // If control variable
        {
            NLPInd = controlNLPInd(i,j,k,LavrentievConstraintFlagG);    // Get NLP index for control variable type
        }
        else if (l == 3)    // If integral variable
        {
            NLPInd = integralNLPInd(i,j,LavrentievConstraintFlagG); // Get NLP index for integral variable type
        }
        else if (l == 4)    // If initial time variable
        {
            NLPInd = initialNLPInd(i,LavrentievConstraintFlagG);    // Get NLP index for initial time variable type
        }
        else if (l == 5)    // If final time variable
        {
            NLPInd = finalNLPInd(i,LavrentievConstraintFlagG);  // Get NLP index for final time variable type
        }
        else if (l == 6)    // If static parameter variable
        {
            NLPInd = staticNLPInd(j,LavrentievConstraintFlagG); // Get NLP index for static parameter variable type
        }
        else    // Not a recognized variable type
        {
            NLPInd = -1;
        }
    }
    else
    {
        if (l == 1) // If state variable
        {
            NLPInd = stateNLPInd(i,j,k);    // Get NLP index for state variable type
        }
        else if (l == 2)    // If control variable
        {
            NLPInd = controlNLPInd(i,j,k);  // Get NLP index for control variable type
        }
        else if (l == 3)    // If integral variable
        {
            NLPInd = integralNLPInd(i,j);   // Get NLP index for integral variable type
        }
        else if (l == 4)    // If initial time variable
        {
            NLPInd = initialNLPInd(i);  // Get NLP index for initial time variable type
        }
        else if (l == 5)    // If final time variable
        {
            NLPInd = finalNLPInd(i);    // Get NLP index for final time variable type
        }
        else if (l == 6)    // If static parameter variable
        {
            NLPInd = staticNLPInd(j);   // Get NLP index for static parameter variable type
        }
        else    // Not a recognized variable type
        {
            NLPInd = -1;
        }
    }
    
    return NLPInd;
}

int stateNLPInd(int i, int j, int k) // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd;
    
    //    i_yj(k)    i_PrI + (j-1)*(i_N+1) + k
    
    NLPInd = PrIZG[i] + (j)*(NtG[i]+1) + k; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int controlNLPInd(int i, int j, int k)  // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd;
    
    //    i_uj(k)    i_PrI + i_nx(i_N+1) + (j-1)*i_N + k
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (j)*NtG[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int integralNLPInd(int i, int j) // Takes in phase i, component j (i, j using ccode indexing)
{
    int NLPInd;
    
    //    i_qj    i_PrI + i_nx(i_N+1) + i_nu*i_N + j
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*NtG[i] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int initialNLPInd(int i) // Takes in phase i (i using ccode indexing)
{
    int NLPInd;
    
    //    i_t0    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 1
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*NtG[i] + nqG[i]; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int finalNLPInd(int i) // Takes in phase i (i using ccode indexing)
{
    int NLPInd;
    
    //    i_tf    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 2
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*NtG[i] + nqG[i] + 1; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int staticNLPInd(int j) // Takes in component j (j using ccode indexing)
{
    int NLPInd;
    
    //    si    P_TeI + j
    
    NLPInd = TeIZG[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int mainNLPIndZ(int l, int i, int j, int k, int LavrentievConstraintFlag)   // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd; // To be returned index in NLP Decision Vector
    
    if (l == 1) // If state variable
    {
        NLPInd = stateNLPInd(i,j,k,1);  // Get NLP index for state variable type
    }
    else if (l == 2)    // If control variable
    {
        NLPInd = controlNLPInd(i,j,k,1);    // Get NLP index for control variable type
    }
    else if (l == 3)    // If integral variable
    {
        NLPInd = integralNLPInd(i,j,1); // Get NLP index for integral variable type
    }
    else if (l == 4)    // If initial time variable
    {
        NLPInd = initialNLPInd(i,1);    // Get NLP index for initial time variable type
    }
    else if (l == 5)    // If final time variable
    {
        NLPInd = finalNLPInd(i,1);  // Get NLP index for final time variable type
    }
    else if (l == 6)    // If static parameter variable
    {
        NLPInd = staticNLPInd(j,1); // Get NLP index for static parameter variable type
    }
    else    // Not a recognized variable type
    {
        NLPInd = -1;
    }
    
    return NLPInd;
}

int stateNLPInd(int i, int j, int k, int LavrentievConstraintFlag)  // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_yj(k)    i_PrI + (j-1)*(i_N+1) + k
    
    NLPInd = PrIZG[i] + (j)*(NtG[i]+1) + k; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int controlNLPInd(int i, int j, int k, int LavrentievConstraintFlag)    // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_uj(k)    i_PrI + i_nx(i_N+1) + (j-1)*i_N + k
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (j)*(NtG[i]+LavrentievConstraintG.val[i]) + k;    // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int integralNLPInd(int i, int j, int LavrentievConstraintFlag)  // Takes in phase i, component j (i, j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_qj    i_PrI + i_nx(i_N+1) + i_nu*i_N + j
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + j;   // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int initialNLPInd(int i, int LavrentievConstraintFlag)  // Takes in phase i (i using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_t0    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 1
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + nqG[i];  // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int finalNLPInd(int i, int LavrentievConstraintFlag)    // Takes in phase i (i using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_tf    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 2
    
    NLPInd = PrIZG[i] + (nxG[i])*(NtG[i]+1) + (nuG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + nqG[i] + 1;  // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int staticNLPInd(int j, int LavrentievConstraintFlag)   // Takes in component j (j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    si    P_TeI + j
    
    NLPInd = TeIZG[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int mainNLPIndZOld(int l, int i, int j, int k, const int *NtOld, const int *PrIZOld, const int *TeIZOld)    // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld; // To be returned index in NLP Decision Vector
    
    if (LavrentievConstraintFlagG==1)   // If Lavrentiev constraints marked active
    {
        if (l == 1) // If state variable
        {
            NLPIndOld = stateNLPIndOld(i,j,k,NtOld,PrIZOld,LavrentievConstraintFlagG);  // Get NLP index for state variable type
        }
        else if (l == 2)    // If control variable
        {
            NLPIndOld = controlNLPIndOld(i,j,k,NtOld,PrIZOld,LavrentievConstraintFlagG);    // Get NLP index for control variable type
        }
        else if (l == 3)    // If integral variable
        {
            NLPIndOld = integralNLPIndOld(i,j,NtOld,PrIZOld,LavrentievConstraintFlagG); // Get NLP index for integral variable type
        }
        else if (l == 4)    // If initial time variable
        {
            NLPIndOld = initialNLPIndOld(i,NtOld,PrIZOld,LavrentievConstraintFlagG);    // Get NLP index for initial time variable type
        }
        else if (l == 5)    // If final time variable
        {
            NLPIndOld = finalNLPIndOld(i,NtOld,PrIZOld,LavrentievConstraintFlagG);  // Get NLP index for final time variable type
        }
        else if (l == 6)    // If static parameter variable
        {
            NLPIndOld = staticNLPIndOld(j,TeIZOld,LavrentievConstraintFlagG);   // Get NLP index for static parameter variable type
        }
        else    // Not a recognized variable type
        {
            NLPIndOld = -1;
        }
    }
    else
    {
        if (l == 1) // If state variable
        {
            NLPIndOld = stateNLPIndOld(i,j,k,NtOld,PrIZOld);    // Get NLP index for state variable type
        }
        else if (l == 2)    // If control variable
        {
            NLPIndOld = controlNLPIndOld(i,j,k,NtOld,PrIZOld);  // Get NLP index for control variable type
        }
        else if (l == 3)    // If integral variable
        {
            NLPIndOld = integralNLPIndOld(i,j,NtOld,PrIZOld);   // Get NLP index for integral variable type
        }
        else if (l == 4)    // If initial time variable
        {
            NLPIndOld = initialNLPIndOld(i,NtOld,PrIZOld);  // Get NLP index for initial time variable type
        }
        else if (l == 5)    // If final time variable
        {
            NLPIndOld = finalNLPIndOld(i,NtOld,PrIZOld);    // Get NLP index for final time variable type
        }
        else if (l == 6)    // If static parameter variable
        {
            NLPIndOld = staticNLPIndOld(j,TeIZOld);   // Get NLP index for static parameter variable type
        }
        else    // Not a recognized variable type
        {
            NLPIndOld = -1;
        }
    }
    
    return NLPIndOld;
}

int stateNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIZOld) // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld;
    
    //    i_yj(k)    i_PrI + (j-1)*(i_N+1) + k
    
    NLPIndOld = PrIZOld[i] + (j)*(NtOld[i]+1) + k; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int controlNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIZOld) // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld;
    
    //    i_uj(k)    i_PrI + i_nx(i_N+1) + (j-1)*i_N + k
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (j)*NtOld[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int integralNLPIndOld(int i, int j, const int *NtOld, const int *PrIZOld) // Takes in phase i, component j (i, j using ccode indexing)
{
    int NLPIndOld;
    
    //    i_qj    i_PrI + i_nx(i_N+1) + i_nu*i_N + j
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*NtOld[i] + j; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int initialNLPIndOld(int i, const int *NtOld, const int *PrIZOld) // Takes in phase i (i using ccode indexing)
{
    int NLPIndOld;
    
    //    i_t0    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 1
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*NtOld[i] + nqG[i]; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int finalNLPIndOld(int i, const int *NtOld, const int *PrIZOld) // Takes in phase i (i using ccode indexing)
{
    int NLPIndOld;
    
    //    i_tf    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 2
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*NtOld[i] + nqG[i] + 1; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int staticNLPIndOld(int j, const int *TeIZOld) // Takes in component j (j using ccode indexing)
{
    int NLPIndOld;
    
    //    si    P_TeI + j
    
    NLPIndOld = TeIZOld[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int mainNLPIndZOld(int l, int i, int j, int k, const int *NtOld, const int *PrIZOld, const int *TeIZOld, int LavrentievConstraintFlag)  // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld; // To be returned index in NLP Decision Vector
    
    if (l == 1) // If state variable
    {
        NLPIndOld = stateNLPIndOld(i,j,k,NtOld,PrIZOld,1);    // Get NLP index for state variable type
    }
    else if (l == 2)    // If control variable
    {
        NLPIndOld = controlNLPIndOld(i,j,k,NtOld,PrIZOld,1);  // Get NLP index for control variable type
    }
    else if (l == 3)    // If integral variable
    {
        NLPIndOld = integralNLPIndOld(i,j,NtOld,PrIZOld,1);   // Get NLP index for integral variable type
    }
    else if (l == 4)    // If initial time variable
    {
        NLPIndOld = initialNLPIndOld(i,NtOld,PrIZOld,1);  // Get NLP index for initial time variable type
    }
    else if (l == 5)    // If final time variable
    {
        NLPIndOld = finalNLPIndOld(i,NtOld,PrIZOld,1);    // Get NLP index for final time variable type
    }
    else if (l == 6)    // If static parameter variable
    {
        NLPIndOld = staticNLPIndOld(j,TeIZOld,1);   // Get NLP index for static parameter variable type
    }
    else    // Not a recognized variable type
    {
        NLPIndOld = -1;
    }
    
    return NLPIndOld;
}

int stateNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIZOld, int LavrentievConstraintFlag) // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_yj(k)    i_PrI + (j-1)*(i_N+1) + k
    
    NLPIndOld = PrIZOld[i] + (j)*(NtOld[i]+1) + k; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int controlNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIZOld, int LavrentievConstraintFlag)   // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_uj(k)    i_PrI + i_nx(i_N+1) + (j-1)*i_N + k
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (j)*(NtOld[i]+LavrentievConstraintG.val[i]) + k;   // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int integralNLPIndOld(int i, int j, const int *NtOld, const int *PrIZOld, int LavrentievConstraintFlag) // Takes in phase i, component j (i, j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_qj    i_PrI + i_nx(i_N+1) + i_nu*i_N + j
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + j;  // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int initialNLPIndOld(int i, const int *NtOld, const int *PrIZOld, int LavrentievConstraintFlag) // Takes in phase i (i using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_t0    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 1
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + nqG[i]; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int finalNLPIndOld(int i, const int *NtOld, const int *PrIZOld, int LavrentievConstraintFlag)   // Takes in phase i (i using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_tf    i_PrI + i_nx(i_N+1) + i_nu*i_N + i_nq + 2
    
    NLPIndOld = PrIZOld[i] + (nxG[i])*(NtOld[i]+1) + (nuG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + nqG[i] + 1; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int staticNLPIndOld(int j, const int *TeIZOld, int LavrentievConstraintFlag)    // Takes in component j (j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    si    P_TeI + j
    
    NLPIndOld = TeIZOld[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------NLP Index H functions-----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLPIndH getInfoNLPIndH(int LavrentievConstraintFlag1, int LavrentievConstraintFlag2)
{
    int l;                      // Variable type holder
    int NLPInd;                 // Index number in NLP Decision Vector
    infoNLPIndH inlph(LenHG);   // Information class for NLP Decision Vector
    
    // Defect constraints
    l = 7;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<nxG[i]; j++)    // for each state component in phase
        {
            for (int k=0; k<(NtG[i]+LavrentievConstraintCompG.mat[i].val[j]); k++)   // for each collocation point in phase (additional point if Lavrentiev constraint is active in phase for state component)
            {
                NLPInd = mainNLPIndH(l,i,j,k,1);    // Get NLP index for variable l, phase i, component j, point k
                inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
                inlph.Phase[NLPInd] = i;            // Store phase number for NLP Decision Vector index
                inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
                inlph.Pt[NLPInd]    = k;            // Store point number for NLP Decision Vector index
            }
        }
    }
    
    // Path constraints
    l = 8;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<ncG[i]; j++)    // for each path constraint component in phase
        {
            for (int k=0; k<(NtG[i]+LavrentievConstraintG.val[i]); k++) // for each collocation point in phase (additional point if Lavrentiev constraint is active in phase)
            {
                NLPInd = mainNLPIndH(l,i,j,k,1);    // Get NLP index for variable l, phase i, component j, point k
                inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
                inlph.Phase[NLPInd] = i;            // Store phase number for NLP Decision Vector index
                inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
                inlph.Pt[NLPInd]    = k;            // Store point number for NLP Decision Vector index
            }
        }
    }
    
    // Approximation of integral constraints
    l = 9;
    for (int i=0; i<PG; i++)    // for each phase in problem
    {
        for (int j=0; j<nqG[i]; j++)    // for each approximation constraint component in phase
        {
            NLPInd = mainNLPIndH(l,i,j,-1,1);   // Get NLP index for variable l, phase i, component j, point k
            inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
            inlph.Phase[NLPInd] = i;            // Store phase number for NLP Decision Vector index
            inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
            inlph.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
        }
    }
    
    // Event constraints
    l = 10;
    if ((DurationFlagG)&&(ContinuityFlagG))
    {
        for (int j=0; j<(nbG+PG+neG); j++)  // for each event constraint component in phase
        {
            NLPInd = mainNLPIndH(l,-1,j,-1,1);  // Get NLP index for variable l, phase i, component j, point k
            inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
            inlph.Phase[NLPInd] = -1;           // Store phase number for NLP Decision Vector index
            inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
            inlph.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
        }
    }
    else if (DurationFlagG)
    {
        for (int j=0; j<(nbG+PG); j++)   // for each event constraint component in phase
        {
            NLPInd = mainNLPIndH(l,-1,j,-1,1);  // Get NLP index for variable l, phase i, component j, point k
            inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
            inlph.Phase[NLPInd] = -1;           // Store phase number for NLP Decision Vector index
            inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
            inlph.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
        }
    }
    else if (ContinuityFlagG)
    {
        for (int j=0; j<(nbG+neG); j++) // for each event constraint component in phase
        {
            NLPInd = mainNLPIndH(l,-1,j,-1,1);  // Get NLP index for variable l, phase i, component j, point k
            inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
            inlph.Phase[NLPInd] = -1;           // Store phase number for NLP Decision Vector index
            inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
            inlph.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
        }
    }
    else
    {
        for (int j=0; j<nbG; j++)   // for each event constraint component in phase
        {
            NLPInd = mainNLPIndH(l,-1,j,-1,1);  // Get NLP index for variable l, phase i, component j, point k
            inlph.Var[NLPInd]   = l;            // Store variable type for NLP Decision Vector index
            inlph.Phase[NLPInd] = -1;           // Store phase number for NLP Decision Vector index
            inlph.Comp[NLPInd]  = j;            // Store component number for NLP Decision Vector index
            inlph.Pt[NLPInd]    = -1;           // Store point number for NLP Decision Vector index
        }
    }
    
    return inlph;
}

int mainNLPIndH(int l, int i, int j, int k) // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd; // To be returned index in NLP Constraints Vector
    
    if (LavrentievConstraintFlagG==1)
    {
        if (l == 7) // If defect constraint
        {
            NLPInd = defectNLPInd(i,j,k,LavrentievConstraintFlagG); // Get NLP index for defect constraint type
        }
        else if (l == 8)    // If path constraint
        {
            NLPInd = pathNLPInd(i,j,k,LavrentievConstraintFlagG);   // Get NLP index for path constraint type
        }
        else if (l == 9)    // If approximation constraint
        {
            NLPInd = approxNLPInd(i,j,LavrentievConstraintFlagG);   // Get NLP index for approximation constraint type
        }
        else if (l == 10)   // If event constraint
        {
            NLPInd = eventNLPInd(j,LavrentievConstraintFlagG);  // Get NLP index for event constraint type
        }
        else    // Not a recognized constraint type
        {
            NLPInd = -1;
        }
    }
    else
    {
        if (l == 7) // If defect constraint
        {
            NLPInd = defectNLPInd(i,j,k);   // Get NLP index for defect constraint type
        }
        else if (l == 8)    // If path constraint
        {
            NLPInd = pathNLPInd(i,j,k); // Get NLP index for path constraint type
        }
        else if (l == 9)    // If approximation constraint
        {
            NLPInd = approxNLPInd(i,j); // Get NLP index for approximation constraint type
        }
        else if (l == 10)   // If event constraint
        {
            NLPInd = eventNLPInd(j);    // Get NLP index for event constraint type
        }
        else    // Not a recognized constraint type
        {
            NLPInd = -1;
        }
    }
    
    return NLPInd;
}

int defectNLPInd(int i, int j, int k)   // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd;
    
    //    i_dj(k)    i_PrIh + (j-1)*(i_N) + k
    
    NLPInd = PrIHG[i] + (j)*NtG[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int pathNLPInd(int i, int j, int k) // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPInd;
    
    //    i_cj(k)    i_PrIh + i_nx*(i_N) + (j-1)*i_N + k
    
    NLPInd = PrIHG[i] + (nxG[i])*NtG[i] + (j)*NtG[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int approxNLPInd(int i, int j)  // Takes in phase i, component j (i, j using ccode indexing)
{
    int NLPInd;
    
    //    i_rj    i_PrIh + i_nx*i_N + i_nc*i_N + j
    
    NLPInd = PrIHG[i] + (nxG[i])*NtG[i] + (ncG[i])*NtG[i] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int eventNLPInd(int j)  // Takes in component j (j using ccode indexing)
{
    int NLPInd;
    
    //    bj    P_TeIh + j
    
    NLPInd = TeIHG[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int mainNLPIndH(int l, int i, int j, int k, int LavrentievConstraintFlag)   // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd; // To be returned index in NLP Constraints Vector
    
    if (l == 7) // If defect constraint
    {
        NLPInd = defectNLPInd(i,j,k,1); // Get NLP index for defect constraint type
    }
    else if (l == 8)    // If path constraint
    {
        NLPInd = pathNLPInd(i,j,k,1);   // Get NLP index for path constraint type
    }
    else if (l == 9)    // If approximation constraint
    {
        NLPInd = approxNLPInd(i,j,1);   // Get NLP index for approximation constraint type
    }
    else if (l == 10)   // If event constraint
    {
        NLPInd = eventNLPInd(j,1);  // Get NLP index for event constraint type
    }
    else    // Not a recognized constraint type
    {
        NLPInd = -1;
    }
    
    return NLPInd;
}

int defectNLPInd(int i, int j, int k, int LavrentievConstraintFlag) // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_dj(k)    i_PrIh + (j-1)*(i_N) + k
    
//    NLPInd = PrIHG[i] + (j)*(NtG[i]+LavrentievConstraintG.val[i]) + k; // calculate NLP index in terms of c code indexing
    
    NLPInd = PrIHG[i] + k;  // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<j; comp++)    // For each state component before current one
    {
        NLPInd = NLPInd + NtG[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }

    return NLPInd;
}

int pathNLPInd(int i, int j, int k, int LavrentievConstraintFlag)   // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_cj(k)    i_PrIh + i_nx*(i_N) + (j-1)*i_N + k
    
//    NLPInd = PrIHG[i] + (nxG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + (j)*(NtG[i]+LavrentievConstraintG.val[i]) + k; // calculate NLP index in terms of c code indexing
    
    NLPInd = PrIHG[i] + (j)*(NtG[i]+LavrentievConstraintG.val[i]) + k; // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<nxG[i]; comp++)   // For each state component in phase
    {
        NLPInd = NLPInd + NtG[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }

    return NLPInd;
}

int approxNLPInd(int i, int j, int LavrentievConstraintFlag)    // Takes in phase i, component j (i, j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    i_rj    i_PrIh + i_nx*i_N + i_nc*i_N + j
    
//    NLPInd = PrIHG[i] + (nxG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + (ncG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + j; // calculate NLP index in terms of c code indexing
    
    NLPInd = PrIHG[i] + (ncG[i])*(NtG[i]+LavrentievConstraintG.val[i]) + j; // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<nxG[i]; comp++)   // For each state component in phase
    {
        NLPInd = NLPInd + NtG[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }

    return NLPInd;
}

int eventNLPInd(int j, int LavrentievConstraintFlag)    // Takes in component j (j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPInd;
    
    //    bj    P_TeIh + j
    
    NLPInd = TeIHG[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPInd;
}

int mainNLPIndHOld(int l, int i, int j, int k, const int *NtOld, const int *PrIHOld, const int *TeIHOld) // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld; // To be returned index in NLP Constraints Vector
    
    if (LavrentievConstraintFlagG==1)
    {
        if (l == 7) // If defect constraint
        {
            NLPIndOld = defectNLPIndOld(i,j,k,NtOld,PrIHOld,1); // Get NLP index for defect constraint type
        }
        else if (l == 8)    // If path constraint
        {
            NLPIndOld = pathNLPIndOld(i,j,k,NtOld,PrIHOld,1);   // Get NLP index for path constraint type
        }
        else if (l == 9)    // If approximation constraint
        {
            NLPIndOld = approxNLPIndOld(i,j,NtOld,PrIHOld,1);   // Get NLP index for approximation constraint type
        }
        else if (l == 10)   // If event constraint
        {
            NLPIndOld = eventNLPIndOld(j,TeIHOld,1);    // Get NLP index for event constraint type
        }
        else    // Not a recognized constraint type
        {
            NLPIndOld = -1;
        }
    }
    else
    {
        if (l == 7) // If defect constraint
        {
            NLPIndOld = defectNLPIndOld(i,j,k,NtOld,PrIHOld);   // Get NLP index for defect constraint type
        }
        else if (l == 8)    // If path constraint
        {
            NLPIndOld = pathNLPIndOld(i,j,k,NtOld,PrIHOld); // Get NLP index for path constraint type
        }
        else if (l == 9)    // If approximation constraint
        {
            NLPIndOld = approxNLPIndOld(i,j,NtOld,PrIHOld); // Get NLP index for approximation constraint type
        }
        else if (l == 10)   // If event constraint
        {
            NLPIndOld = eventNLPIndOld(j,TeIHOld);    // Get NLP index for event constraint type
        }
        else    // Not a recognized constraint type
        {
            NLPIndOld = -1;
        }
    }
    
    return NLPIndOld;
}

int defectNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIHOld)   // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld;
    
    //    i_dj(k)    i_PrIh + (j-1)*(i_N) + k
    
    NLPIndOld = PrIHOld[i] + (j)*NtOld[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int pathNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIHOld) // Takes in phase i, component j, point k (i, j, k using ccode indexing)
{
    int NLPIndOld;
    
    //    i_cj(k)    i_PrIh + i_nx*(i_N) + (j-1)*i_N + k
    
    NLPIndOld = PrIHOld[i] + (nxG[i])*NtOld[i] + (j)*NtOld[i] + k; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int approxNLPIndOld(int i, int j, const int *NtOld, const int *PrIHOld)  // Takes in phase i, component j (i, j using ccode indexing)
{
    int NLPIndOld;
    
    //    i_rj    i_PrIh + i_nx*i_N + i_nc*i_N + j
    
    NLPIndOld = PrIHOld[i] + (nxG[i])*NtOld[i] + (ncG[i])*NtOld[i] + j; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int eventNLPIndOld(int j, const int *TeIHOld)  // Takes in component j (j using ccode indexing)
{
    int NLPIndOld;
    
    //    bj    P_TeIh + j
    
    NLPIndOld = TeIHOld[PG-1] + j; // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

int mainNLPIndHOld(int l, int i, int j, int k, const int *NtOld, const int *PrIHOld, const int *TeIHOld, int LavrentievConstraintFlag)  // Takes in variable l, phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld; // To be returned index in NLP Constraints Vector
    
    if (l == 7) // If defect constraint
    {
        NLPIndOld = defectNLPIndOld(i,j,k,NtOld,PrIHOld,1); // Get NLP index for defect constraint type
    }
    else if (l == 8)    // If path constraint
    {
        NLPIndOld = pathNLPIndOld(i,j,k,NtOld,PrIHOld,1);   // Get NLP index for path constraint type
    }
    else if (l == 9)    // If approximation constraint
    {
        NLPIndOld = approxNLPIndOld(i,j,NtOld,PrIHOld,1);   // Get NLP index for approximation constraint type
    }
    else if (l == 10)   // If event constraint
    {
        NLPIndOld = eventNLPIndOld(j,TeIHOld,1);    // Get NLP index for event constraint type
    }
    else    // Not a recognized constraint type
    {
        NLPIndOld = -1;
    }
    
    return NLPIndOld;
}

int defectNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIHOld, int LavrentievConstraintFlag)    // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_dj(k)    i_PrIh + (j-1)*(i_N) + k
    
//    NLPIndOld = PrIHOld[i] + (j)*(NtOld[i]+LavrentievConstraintG.val[i]) + k;   // calculate NLP index in terms of c code indexing
    
    NLPIndOld = PrIHOld[i] + k; // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<j; comp++)    // For each state component before current one
    {
        NLPIndOld = NLPIndOld + NtOld[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }
    
    return NLPIndOld;
}

int pathNLPIndOld(int i, int j, int k, const int *NtOld, const int *PrIHOld, int LavrentievConstraintFlag)  // Takes in phase i, component j, point k (i, j, k using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_cj(k)    i_PrIh + i_nx*(i_N) + (j-1)*i_N + k
    
    NLPIndOld = PrIHOld[i] + (nxG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + (j)*(NtOld[i]+LavrentievConstraintG.val[i]) + k;    // calculate NLP index in terms of c code indexing
    
    NLPIndOld = PrIHOld[i] + (j)*(NtOld[i]+LavrentievConstraintG.val[i]) + k;   // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<nxG[i]; comp++)   // For each state component in phase
    {
        NLPIndOld = NLPIndOld + NtOld[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }
    
    return NLPIndOld;
}

int approxNLPIndOld(int i, int j, const int *NtOld, const int *PrIHOld, int LavrentievConstraintFlag)   // Takes in phase i, component j (i, j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    i_rj    i_PrIh + i_nx*i_N + i_nc*i_N + j
    
//    NLPIndOld = PrIHOld[i] + (nxG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + (ncG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + j;   // calculate NLP index in terms of c code indexing
    
    NLPIndOld = PrIHOld[i] + (ncG[i])*(NtOld[i]+LavrentievConstraintG.val[i]) + j;  // calculate NLP index in terms of c code indexing
    for (int comp=0; comp<nxG[i]; comp++)   // For each state component in phase
    {
        NLPIndOld = NLPIndOld + NtOld[i]+LavrentievConstraintCompG.mat[i].val[comp]; // Add number of collocation points (plus final point for Lavrentiev constraint)
    }
    
    return NLPIndOld;
}

int eventNLPIndOld(int j, const int *TeIHOld, int LavrentievConstraintFlag) // Takes in component j (j using ccode indexing) and flag indicating Lavrentiev constraints are being used
{
    int NLPIndOld;
    
    //    bj    P_TeIh + j
    
    NLPIndOld = TeIHOld[PG-1] + j;  // calculate NLP index in terms of c code indexing
    
    return NLPIndOld;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------NLP Gradient functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLPGrad getInfoNLPGrad(const infoNLPIndZ& NLPIndZ)
{
    infoNLPGrad inlpgrad;   // Construct empty information class for NLP Objective Gradient
    intMat NLPGradStat(LenZG);  // Allocate memory for length of NLP Decision Vector
    
    for (int NLPInd=0; NLPInd<LenZG; NLPInd++)  // For length of NLP Decision Vector
    {
        if (NLPIndZ.Var[NLPInd] == 1)  // If state variable type
        {
            if ((NLPIndZ.Pt[NLPInd] == 0) || (NLPIndZ.Pt[NLPInd] == NtG[NLPIndZ.Phase[NLPInd]]))    // If initial or final point
            {
                NLPGradStat.val[NLPInd] = 1;    // Mark partial as nonzero
            }
        }
        if ((NLPIndZ.Var[NLPInd] > 2) && (NLPIndZ.Var[NLPInd] < 7)) // If integral, initial time, final time, or static parameter variable type
        {
            NLPGradStat.val[NLPInd] = 1;    // Mark partial as nonzero
        }
        if ((NLPIndZ.Var[NLPInd] < 1) || (NLPIndZ.Var[NLPInd] > 6)) // If unknown variable type
        {
            printf("\nUnknown variable type being assigned in getInfoNLPGrad(const ...)");
        }
    }
    
    inlpgrad = getInfoNLPGrad(NLPGradStat);
    
    return inlpgrad;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------NLP Jacobian functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLPJac getInfoNLPJac(const infoNLPIndZ& NLPIndZ, const infoNLPIndH& NLPIndH)
{
    int nnzJacPre = 0;
    int nnzJacCnt = 0;
    int h_i, h_j, h_k, h_l;
    int z_i, z_j, z_k, z_l;
    
    // For defect constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<nxG[i]; j++) // For each state component in phase
        {
            nnzJacPre = nnzJacPre + NtG[i]*(NtG[i] + nxG[i] + nuG[i] + 2 + nsG);
        }
    }
    
    // For path constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<ncG[i]; j++) // For each path component in phase
        {
            nnzJacPre = nnzJacPre + NtG[i]*(nxG[i] + nuG[i] + 2 + nsG);
        }
    }
    
    // For approx constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<nqG[i]; j++) // For each integral component in phase
        {
            nnzJacPre = nnzJacPre + NtG[i]*(nxG[i] + nuG[i]) + 3 + nsG;
        }
    }
    
    // For event constraints
    if ((DurationFlagG)&&(ContinuityFlagG))
    {
        for (int j=0; j<(nbG+PG+neG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else if (DurationFlagG)
    {
        for (int j=0; j<(nbG+PG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else if (ContinuityFlagG)
    {
        for (int j=0; j<(nbG+neG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else
    {
        for (int j=0; j<nbG; j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    
    infoNLPJac inlpjac(nnzJacPre);  // Information class for NLP Constraints Jacobian
    
    for (int nlpIndH=0; nlpIndH<LenHG; nlpIndH++) // For entire length of NLP constraints vector
    {
        for (int nlpIndZ=0; nlpIndZ<LenZG; nlpIndZ++) // For entire length of NLP decision vector
        {
            h_l = NLPIndH.Var[nlpIndH];
            h_i = NLPIndH.Phase[nlpIndH];
            h_j = NLPIndH.Comp[nlpIndH];
            h_k = NLPIndH.Pt[nlpIndH];
            
            z_l = NLPIndZ.Var[nlpIndZ];
            z_i = NLPIndZ.Phase[nlpIndZ];
            z_j = NLPIndZ.Comp[nlpIndZ];
            z_k = NLPIndZ.Pt[nlpIndZ];
            
            if (h_l == 7) // if defect constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_j == z_j) // if same component
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                        else // if not same component
                        {
                            if (h_k == z_k) // if same collocation point
                            {
                                inlpjac.Row[nnzJacCnt] = nlpIndH;
                                inlpjac.Col[nnzJacCnt] = nlpIndZ;
                                nnzJacCnt++;
                            }
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 8) // if path constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 9) // if approx constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (z_k < NtG[z_i]) // if not last point (ccode indexing)
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_j == z_j) // if same component
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 10) // if event constraint
            {
                if (z_l == 1) // if state variable
                {
                    if ((z_k == 0)||(z_k == NtG[z_i])) // if first or last point (ccode indexing)
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    
                }
                else if (z_l == 3) // if integral variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 4) // if initial time variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 5) // if final time variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
        }
    }
    
    return inlpjac;
}

infoNLPJac getInfoNLPJac(const infoNLPIndZ& NLPIndZ, const infoNLPIndH& NLPIndH, int LavrentievConstraintFlag)  // Get NLP Constraints Jacobian information and flag indicating Lavrentiev constraints are being used
{
    int nnzJacPre = 0;
    int nnzJacCnt = 0;
    int h_i, h_j, h_k, h_l;
    int z_i, z_j, z_k, z_l;
    
    // For defect constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<nxG[i]; j++) // For each state component in phase
        {
            nnzJacPre = nnzJacPre + (NtG[i]+LavrentievConstraintCompG.mat[i].val[j])*(NtG[i] + nxG[i] + nuG[i] + 2 + nsG);   // Allocate for (number discretization points + number state - 1 + number control + init time + final time + number static param)*(number of collocation points plus additional point if Lavrentiev constraint enforced for state component in phase)
        }
    }
    
    // For path constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<ncG[i]; j++) // For each path component in phase
        {
            nnzJacPre = nnzJacPre + (NtG[i]+LavrentievConstraintG.val[i])*(nxG[i] + nuG[i] + 2 + nsG);  // Allocate for (number states + number control + init time + final time + number static param)*(number of collocation points plus additional point if Lavrentiev constraint enforced in phase)
        }
    }
    
    // For approx constraints
    for (int i=0; i<PG; i++) // For each phase
    {
        for (int j=0; j<nqG[i]; j++) // For each integral component in phase
        {
            nnzJacPre = nnzJacPre + NtG[i]*(nxG[i] + nuG[i]) + 3 + nsG;
        }
    }
    
    // For event constraints
    if ((DurationFlagG)&&(ContinuityFlagG))
    {
        for (int j=0; j<(nbG+PG+neG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else if (DurationFlagG)
    {
        for (int j=0; j<(nbG+PG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else if (ContinuityFlagG)
    {
        for (int j=0; j<(nbG+neG); j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    else
    {
        for (int j=0; j<nbG; j++) // For each event component
        {
            for (int i=0; i<PG; i++) // For each phase
            {
                nnzJacPre = nnzJacPre +2*nxG[i] + nqG[i] + 2;
            }
            nnzJacPre = nnzJacPre + nsG;
        }
    }
    
    infoNLPJac inlpjac(nnzJacPre);  // Information class for NLP Constraints Jacobian
    
    for (int nlpIndH=0; nlpIndH<LenHG; nlpIndH++) // For entire length of NLP constraints vector
    {
        for (int nlpIndZ=0; nlpIndZ<LenZG; nlpIndZ++) // For entire length of NLP decision vector
        {
            h_l = NLPIndH.Var[nlpIndH];
            h_i = NLPIndH.Phase[nlpIndH];
            h_j = NLPIndH.Comp[nlpIndH];
            h_k = NLPIndH.Pt[nlpIndH];
            
            z_l = NLPIndZ.Var[nlpIndZ];
            z_i = NLPIndZ.Phase[nlpIndZ];
            z_j = NLPIndZ.Comp[nlpIndZ];
            z_k = NLPIndZ.Pt[nlpIndZ];
            
            if (h_l == 7) // if defect constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_j == z_j) // if same component
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                        else // if not same component
                        {
                            if (h_k == z_k) // if same collocation point
                            {
                                inlpjac.Row[nnzJacCnt] = nlpIndH;
                                inlpjac.Col[nnzJacCnt] = nlpIndZ;
                                nnzJacCnt++;
                            }
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 8) // if path constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_k == z_k) // if same collocation point
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 9) // if approx constraint
            {
                if (z_l == 1) // if state variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (z_k < NtG[z_i]) // if not last point (ccode indexing)
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (z_k < NtG[z_i]) // if not last point (ccode indexing)
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 3) // if integral variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        if (h_j == z_j) // if same component
                        {
                            inlpjac.Row[nnzJacCnt] = nlpIndH;
                            inlpjac.Col[nnzJacCnt] = nlpIndZ;
                            nnzJacCnt++;
                        }
                    }
                }
                else if (z_l == 4) // if initial time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 5) // if final time variable
                {
                    if (h_i == z_i) // if same phase
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
            else if (h_l == 10) // if event constraint
            {
                if (z_l == 1) // if state variable
                {
                    if ((z_k == 0)||(z_k == NtG[z_i])) // if first or last point (ccode indexing)
                    {
                        inlpjac.Row[nnzJacCnt] = nlpIndH;
                        inlpjac.Col[nnzJacCnt] = nlpIndZ;
                        nnzJacCnt++;
                    }
                }
                else if (z_l == 2) // if control variable
                {
                    
                }
                else if (z_l == 3) // if integral variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 4) // if initial time variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 5) // if final time variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
                else if (z_l == 6) // if static variable
                {
                    inlpjac.Row[nnzJacCnt] = nlpIndH;
                    inlpjac.Col[nnzJacCnt] = nlpIndZ;
                    nnzJacCnt++;
                }
            }
        }
    }
    
    return inlpjac;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------NLP Hessian functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

infoNLPHess getInfoNLPHess(const infoNLPIndZ& NLPIndZ)
{
    int nnzHessCnt = 0;
    int nnzHessPre = 0;
    int z1_i, z1_j, z1_k, z1_l;
    int z2_i, z2_j, z2_k, z2_l;
    int nnzHessLT = 0;
    
    // For state-state partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r]*nxG[p];
            }
        }
    }
    
    // For state-integral partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r]*nqG[p];
            }
        }
    }
    
    // For integral-integral partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + nqG[r]*nqG[p];
            }
        }
    }
    
    // For state-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r];
            }
        }
    }
    
    // For integral-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2*nqG[r];
            }
        }
    }
    
    // For initial-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 1;
            }
        }
    }
    
    // For state-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r];
            }
        }
    }
    
    // For integral-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2*nqG[r];
            }
        }
    }
    
    // For initial-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2;
            }
        }
    }
    
    // For final-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 1;
            }
        }
    }
    
    // For state-state partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + nxG[p]*nxG[p]*(NtG[p]+3);
    }
    
    // For state-control partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*NtG[p]*nxG[p]*nuG[p];
    }
    
    // For control-control partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + NtG[p]*nuG[p]*nuG[p];
    }
    
    // For state-integral partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 4*nqG[p]*nxG[p];
    }
    
    // For integral-integral partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + nqG[p]*nqG[p];
    }
    
    // For state-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p];
    }
    
    // For control-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*NtG[p]*nuG[p];
    }
    
    // For integral-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p];
    }
    
    // For initial-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 1;
    }
    
    // For state-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p];
    }
    
    // For control-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*NtG[p]*nuG[p];
    }
    
    // For integral-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p];
    }
    
    // For initial-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2;
    }
    
    // For final-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 1;
    }
    
    // For state-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p]*nsG;
    }
    
    // For control-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*NtG[p]*nuG[p]*nsG;
    }
    
    // For integral-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p]*nsG;
    }
    
    // For initial-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nsG;
    }
    
    // For final-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nsG;
    }
    
    // For static-static partials
    nnzHessPre = nnzHessPre + nsG*nsG;
    
    nnzHessLT = (int) (((double)nnzHessPre - (double)LenZG)/2.0) + LenZG;
    
    infoNLPHess inlphess(nnzHessLT);
    
//    inlphess.NNZ = nnzHessPre;  // Decided to not track total number of nonzeros appearing in Hessian (just lower triangle)
    
    for (int nlpIndZ1=0; nlpIndZ1<LenZG; nlpIndZ1++) // For entire length of NLP decision vector
    {
        //        for (nlpIndZ2=0; nlpIndZ2<nlpLenz; nlpIndZ2++) // For entire length of NLP decision vector
        for (int nlpIndZ2=0; nlpIndZ2<=nlpIndZ1; nlpIndZ2++) // For lower triangular part of NLP Lagrange Hessian
        {
            z1_l = NLPIndZ.Var[nlpIndZ1];
            z1_i = NLPIndZ.Phase[nlpIndZ1];
            z1_j = NLPIndZ.Comp[nlpIndZ1];
            z1_k = NLPIndZ.Pt[nlpIndZ1];
            
            z2_l = NLPIndZ.Var[nlpIndZ2];
            z2_i = NLPIndZ.Phase[nlpIndZ2];
            z2_j = NLPIndZ.Comp[nlpIndZ2];
            z2_k = NLPIndZ.Pt[nlpIndZ2];
            
            if ((z1_l == 1) && (z2_l ==1)) // if both partials are state variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == 0)&&(z2_k == NtG[z2_i])) // if first point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == 0)) // if last point of row phase and first point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else  // if in different phases
                {
                    if ((z1_k == 0)&&(z2_k == 0)) // if first point of each phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == 0)&&(z2_k == NtG[z2_i])) // if first point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == 0)) // if last point of row phase and first point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == NtG[z2_i])) // if last point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 1) && (z2_l == 2)) // if first partial is state variable and second partial is control variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 2) && (z2_l == 1)) // if first partial is control variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 2) && (z2_l == 2)) // if both partials are control variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 1) && (z2_l == 3)) // if first partial is state variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 3) && (z2_l == 1)) // if first partial is integral variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if ((z2_k == 0)||(z2_k == NtG[z1_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 3) && (z2_l ==3)) // if both partials are integral variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 4)) // if first partial is state variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 4) && (z2_l == 1)) // if first partial is initial variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 2) && (z2_l == 4)) // if first partial is control variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 4) && (z2_l == 2)) // if first partial is initial variable and second partial is control variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 3) && (z2_l == 4)) // if first partial is integral variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 3)) // if first partial is initial variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 4)) // if both partials are initial variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 5)) // if first partial is state variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 5) && (z2_l == 1)) // if first partial is final variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 2) && (z2_l == 5)) // if first partial is integral variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 5) && (z2_l == 2)) // if first partial is final variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 3) && (z2_l == 5)) // if first partial is integral variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 3)) // if first partial is final variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 5)) // if first partial is initial variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 4)) // if first partial is final variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 5)) // if both partials are final variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 6)) // if first partial is state variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 1)) // if first partial is static variable and second partial is state variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 2) && (z2_l == 6)) // if first partial is control variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 2)) // if first partial is static variable and second partial is control variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 3) && (z2_l == 6)) // if first partial is integral variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 3)) // if first partial is static variable and second partial is integral variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 4) && (z2_l == 6)) // if first partial is initial variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 4)) // if first partial is static variable and second partial is initial variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 5) && (z2_l == 6)) // if first partial is final variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 5)) // if first partial is static variable and second partial is final variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 6)) // if both partials are static variables
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
        }
    }
    
    return inlphess;
}

infoNLPHess getInfoNLPHess(const infoNLPIndZ& NLPIndZ, int LavrentievConstraintFlag)    // Get NLP Lagrangian Hessian information and flag indicating Lavrentiev constraints are being used
{
    int nnzHessCnt = 0;
    int nnzHessPre = 0;
    int z1_i, z1_j, z1_k, z1_l;
    int z2_i, z2_j, z2_k, z2_l;
    int nnzHessLT = 0;
    
    // For state-state partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r]*nxG[p];
            }
        }
    }
    
    // For state-integral partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r]*nqG[p];
            }
        }
    }
    
    // For integral-integral partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + nqG[r]*nqG[p];
            }
        }
    }
    
    // For state-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r];
            }
        }
    }
    
    // For integral-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2*nqG[r];
            }
        }
    }
    
    // For initial-initial partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 1;
            }
        }
    }
    
    // For state-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 4*nxG[r];
            }
        }
    }
    
    // For integral-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2*nqG[r];
            }
        }
    }
    
    // For initial-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 2;
            }
        }
    }
    
    // For final-final partials in different phases
    for (int r=0; r<PG; r++)
    {
        for (int p=0; p<PG; p++)
        {
            if (r != p) // if different phases
            {
                nnzHessPre = nnzHessPre + 1;
            }
        }
    }
    
    // For state-state partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + nxG[p]*nxG[p]*(NtG[p]+3);
    }
    
    // For state-control partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+LavrentievConstraintG.val[p])*nxG[p]*nuG[p];
    }
    
    // For control-control partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + (NtG[p]+LavrentievConstraintG.val[p])*nuG[p]*nuG[p];
    }
    
    // For state-integral partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 4*nqG[p]*nxG[p];
    }
    
    // For integral-integral partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + nqG[p]*nqG[p];
    }
    
    // For state-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p];
    }
    
    // For control-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+LavrentievConstraintG.val[p])*nuG[p];
    }
    
    // For integral-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p];
    }
    
    // For initial-initial partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 1;
    }
    
    // For state-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p];
    }
    
    // For control-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+LavrentievConstraintG.val[p])*nuG[p];
    }
    
    // For integral-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p];
    }
    
    // For initial-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2;
    }
    
    // For final-final partials in same phase
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 1;
    }
    
    // For state-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+1)*nxG[p]*nsG;
    }
    
    // For control-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*(NtG[p]+LavrentievConstraintG.val[p])*nuG[p]*nsG;
    }
    
    // For integral-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nqG[p]*nsG;
    }
    
    // For initial-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nsG;
    }
    
    // For final-static partials
    for (int p=0; p<PG; p++)
    {
        nnzHessPre = nnzHessPre + 2*nsG;
    }
    
    // For static-static partials
    nnzHessPre = nnzHessPre + nsG*nsG;
    
    nnzHessLT = (int) (((double)nnzHessPre - (double)LenZG)/2.0) + LenZG;
    
    infoNLPHess inlphess(nnzHessLT);
    
    //    inlphess.NNZ = nnzHessPre;  // Decided to not track total number of nonzeros appearing in Hessian (just lower triangle)
    
    for (int nlpIndZ1=0; nlpIndZ1<LenZG; nlpIndZ1++) // For entire length of NLP decision vector
    {
        //        for (nlpIndZ2=0; nlpIndZ2<nlpLenz; nlpIndZ2++) // For entire length of NLP decision vector
        for (int nlpIndZ2=0; nlpIndZ2<=nlpIndZ1; nlpIndZ2++) // For lower triangular part of NLP Lagrange Hessian
        {
            z1_l = NLPIndZ.Var[nlpIndZ1];
            z1_i = NLPIndZ.Phase[nlpIndZ1];
            z1_j = NLPIndZ.Comp[nlpIndZ1];
            z1_k = NLPIndZ.Pt[nlpIndZ1];
            
            z2_l = NLPIndZ.Var[nlpIndZ2];
            z2_i = NLPIndZ.Phase[nlpIndZ2];
            z2_j = NLPIndZ.Comp[nlpIndZ2];
            z2_k = NLPIndZ.Pt[nlpIndZ2];
            
            if ((z1_l == 1) && (z2_l ==1)) // if both partials are state variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == 0)&&(z2_k == NtG[z2_i])) // if first point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == 0)) // if last point of row phase and first point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else  // if in different phases
                {
                    if ((z1_k == 0)&&(z2_k == 0)) // if first point of each phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == 0)&&(z2_k == NtG[z2_i])) // if first point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == 0)) // if last point of row phase and first point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                    else if ((z1_k == NtG[z1_i])&&(z2_k == NtG[z2_i])) // if last point of row phase and last point of col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 1) && (z2_l == 2)) // if first partial is state variable and second partial is control variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 2) && (z2_l == 1)) // if first partial is control variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 2) && (z2_l == 2)) // if both partials are control variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if (z1_k == z2_k) // if at same point
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 1) && (z2_l == 3)) // if first partial is state variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 3) && (z2_l == 1)) // if first partial is integral variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    if ((z2_k == 0)||(z2_k == NtG[z1_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 3) && (z2_l ==3)) // if both partials are integral variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 4)) // if first partial is state variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 4) && (z2_l == 1)) // if first partial is initial variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 2) && (z2_l == 4)) // if first partial is control variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 4) && (z2_l == 2)) // if first partial is initial variable and second partial is control variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 3) && (z2_l == 4)) // if first partial is integral variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 3)) // if first partial is initial variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 4)) // if both partials are initial variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 5)) // if first partial is state variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z1_k == 0)||(z1_k == NtG[z1_i])) // if first or last point in row phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 5) && (z2_l == 1)) // if first partial is final variable and second partial is state variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    if ((z2_k == 0)||(z2_k == NtG[z2_i])) // if first or last point in col phase
                    {
                        inlphess.Row[nnzHessCnt] = nlpIndZ1;
                        inlphess.Col[nnzHessCnt] = nlpIndZ2;
                        nnzHessCnt++;
                    }
                }
            }
            else if ((z1_l == 2) && (z2_l == 5)) // if first partial is integral variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 5) && (z2_l == 2)) // if first partial is final variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    //
                }
            }
            else if ((z1_l == 3) && (z2_l == 5)) // if first partial is integral variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 3)) // if first partial is final variable and second partial is integral variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 4) && (z2_l == 5)) // if first partial is initial variable and second partial is final variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 4)) // if first partial is final variable and second partial is initial variable
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 5) && (z2_l == 5)) // if both partials are final variables
            {
                if (z1_i == z2_i) // if in same phase
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
                else // if in different phases
                {
                    inlphess.Row[nnzHessCnt] = nlpIndZ1;
                    inlphess.Col[nnzHessCnt] = nlpIndZ2;
                    nnzHessCnt++;
                }
            }
            else if ((z1_l == 1) && (z2_l == 6)) // if first partial is state variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 1)) // if first partial is static variable and second partial is state variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 2) && (z2_l == 6)) // if first partial is control variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 2)) // if first partial is static variable and second partial is control variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 3) && (z2_l == 6)) // if first partial is integral variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 3)) // if first partial is static variable and second partial is integral variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 4) && (z2_l == 6)) // if first partial is initial variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 4)) // if first partial is static variable and second partial is initial variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 5) && (z2_l == 6)) // if first partial is final variable and second partial is static variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 5)) // if first partial is static variable and second partial is final variable
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
            else if ((z1_l == 6) && (z2_l == 6)) // if both partials are static variables
            {
                inlphess.Row[nnzHessCnt] = nlpIndZ1;
                inlphess.Col[nnzHessCnt] = nlpIndZ2;
                nnzHessCnt++;
            }
        }
    }
    
    return inlphess;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------NLP Bounds functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

double getNLPBoundVal(int bound, int type, int ind)
{
    double value;
    int l, i, j, k;
    
    if (type == 0)
    {
        l = infonlpG.NLPIndZ.Var[ind];
        i = infonlpG.NLPIndZ.Phase[ind];
        j = infonlpG.NLPIndZ.Comp[ind];
        k = infonlpG.NLPIndZ.Pt[ind];
    }
    else if (type == 1)
    {
        l = infonlpG.NLPIndH.Var[ind];
        i = infonlpG.NLPIndH.Phase[ind];
        j = infonlpG.NLPIndH.Comp[ind];
        k = infonlpG.NLPIndH.Pt[ind];
    }
    
    if (bound==1) // If upper bound
    {
        if (l == 1) // If state variable
        {
            if (k==0) // If first point in mesh
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].x0U[j]; // Assign initial state upper bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else if (k==NtG[i]) // If last point in mesh
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].xfU[j]; // Assign final state upper bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else if ((k>0)&&(k<NtG[i])) // If point exists within mesh for state
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].xU[j]; // Assign state upper bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                value = NAN;
            }
        }
        else if (l == 2) // If control variable
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists within mesh for control
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nuG[i])) // If control component exists
                    {
                        value = nlpbG.PB[i].uU[j]; // Assign control upper bound
                    }
                    else // Control component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Control component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Point does not exist----------");
                value = NAN;
            }
        }
        else if (l == 3) // If integral variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                if ((j>=0)&&(j<nqG[i])) // If integral component exists
                {
                    value = nlpbG.PB[i].qU[j]; // Assign integral upper bound
                }
                else // Integral component does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Integral component does not exist----------");
                    value = NAN;
                }
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 4) // If initial time variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                value = nlpbG.PB[i].t0U; // Assign intial time upper bound
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 5) // If final time variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                value = nlpbG.PB[i].tfU; // Assign final time upper bound
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 6) // If static variable
        {
            if ((j>=0)&&(j<nsG)) // If static component exists
            {
                value = nlpbG.WB.sU[j];; // Assign static upper bound
            }
            else // Static component does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------State component does not exist----------");
                value = NAN;
            }
        }
        else if (l == 7) // If defect constraint
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists for defect
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If defect component exists
                    {
                        value = 0; // Assign path upper bound
                    }
                    else // Defect component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Defect component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Point does not exist----------");
                value = NAN;
            }
        }
        else if (l == 8) // If path constraint
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists for path
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<ncG[i])) // If path component exists
                    {
                        value = nlpbG.PB[i].cU[j]; // Assign path upper bound
                    }
                    else // Path component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Path component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                value = NAN;
            }
        }
        else if (l == 9) // If approx constraint
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                if ((j>=0)&&(j<nqG[i])) // If approx component exists
                {
                    value = 0; // Assign approx upper bound
                }
                else // Approx component does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Approx component does not exist----------");
                    value = NAN;
                }
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 10) // If event constraint
        {
            if ((DurationFlagG)&&(ContinuityFlagG)&&((j>=0)&&(j<(nbG+PG+neG)))) // If event component exists
            {
                value = nlpbG.WB.bU[j]; // Assign event upper bound
            }
            else if ((DurationFlagG)&&((j>=0)&&(j<(nbG+PG)))) // If event component exists
            {
                value = nlpbG.WB.bU[j]; // Assign event upper bound
            }
            else if ((ContinuityFlagG)&&((j>=0)&&(j<(nbG+neG)))) // If event component exists
            {
                value = nlpbG.WB.bU[j]; // Assign event upper bound
            }
            else if ((j>=0)&&(j<nbG)) // If event component exists
            {
                value = nlpbG.WB.bU[j]; // Assign event upper bound
            }
            else // Event component does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Event component does not exist----------");
                value = NAN;
            }
        }
        else // Bound does not exist
        {
            printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
            printf("\n----------Bound does not exist----------");
            value = NAN;
        }
    }
    else if (bound==0) // If lower bound
    {
        if (l == 1) // If state variable
        {
            if (k==0) // If first point in mesh
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].x0L[j]; // Assign initial state lower bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else if (k==NtG[i]) // If last point in mesh
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].xfL[j]; // Assign final state lower bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else if ((k>0)&&(k<NtG[i])) // If point exists within mesh for state
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If state component exists
                    {
                        value = nlpbG.PB[i].xL[j]; // Assign state lower bound
                    }
                    else // State component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------State component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                value = NAN;
            }
        }
        else if (l == 2) // If control variable
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists within mesh for control
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nuG[i])) // If control component exists
                    {
                        value = nlpbG.PB[i].uL[j]; // Assign control lower bound
                    }
                    else // Control component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Control component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Point does not exist----------");
                value = NAN;
            }
        }
        else if (l == 3) // If integral variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                if ((j>=0)&&(j<nqG[i])) // If integral component exists
                {
                    value = nlpbG.PB[i].qL[j]; // Assign integral lower bound
                }
                else // Integral component does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Integral component does not exist----------");
                    value = NAN;
                }
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 4) // If initial time variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                value = nlpbG.PB[i].t0L; // Assign intial time lower bound
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 5) // If final time variable
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                value = nlpbG.PB[i].tfL; // Assign final time lower bound
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 6) // If static variable
        {
            if ((j>=0)&&(j<nsG)) // If static component exists
            {
                value = nlpbG.WB.sL[j];; // Assign static lower bound
            }
            else // Static component does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Static component does not exist----------");
                value = NAN;
            }
        }
        else if (l == 7) // If defect constraint
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists for defect
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<nxG[i])) // If defect component exists
                    {
                        value = 0; // Assign path lower bound
                    }
                    else // Defect component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Defect component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Point does not exist----------");
                value = NAN;
            }
        }
        else if (l == 8) // If path constraint
        {
            if ((k>=0)&&(k<NtG[i])) // If point exists for path
            {
                if ((i>=0)&&(i<PG)) // If phase exists
                {
                    if ((j>=0)&&(j<ncG[i])) // If path component exists
                    {
                        value = nlpbG.PB[i].cL[j]; // Assign path lower bound
                    }
                    else // Path component does not exist
                    {
                        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                        printf("\n----------Path component does not exist----------");
                        value = NAN;
                    }
                }
                else // Phase does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Phase does not exist----------");
                    value = NAN;
                }
            }
            else // Point does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                value = NAN;
            }
        }
        else if (l == 9) // If approx constraint
        {
            if ((i>=0)&&(i<PG)) // If phase exists
            {
                if ((j>=0)&&(j<nqG[i])) // If approx component exists
                {
                    value = 0; // Assign approx lower bound
                }
                else // Approx component does not exist
                {
                    printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                    printf("\n----------Approx component does not exist----------");
                    value = NAN;
                }
            }
            else // Phase does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Phase does not exist----------");
                value = NAN;
            }
        }
        else if (l == 10) // If event constraint
        {
            if ((DurationFlagG)&&(ContinuityFlagG)&&((j>=0)&&(j<(nbG+PG+neG)))) // If event component exists
            {
                value = nlpbG.WB.bL[j]; // Assign event lower bound
            }
            else if ((DurationFlagG)&&((j>=0)&&(j<(nbG+PG)))) // If event component exists
            {
                value = nlpbG.WB.bL[j]; // Assign event lower bound
            }
            else if ((ContinuityFlagG)&&((j>=0)&&(j<(nbG+neG)))) // If event component exists
            {
                value = nlpbG.WB.bL[j]; // Assign event lower bound
            }
            else if ((j>=0)&&(j<nbG)) // If event component exists
            {
                value = nlpbG.WB.bL[j]; // Assign event lower bound
            }
            else // Event component does not exist
            {
                printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
                printf("\n----------Event component does not exist----------");
                value = NAN;
            }
        }
        else // Bound does not exist
        {
            printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
            printf("\n----------Bound does not exist----------");
            value = NAN;
        }
    }
    else // No bound selected
    {
        printf("\n%%%%%%%%%%%%%%%%%%%%%%%%ERROR%%%%%%%%%%%%%%%%%%%%%%%%");
        printf("\n----------Bound does not exist----------");
        value = NAN;
    }
    
    return value;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------NLP Guess Functions-----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

double LinearInterp(double x, double xA, double xB, double yA, double yB)
{
    double y;
    
    y = (yB-yA)*(x-xA)/(xB-xA) + yA;
    
    return y;
}

void getNLPZInit(void)
{
    int l, i, j, k;
    double xA, xB, yA, yB, x, y;
    double g;
    double L_bound;
    double U_bound;
    
    xA = -1.0;  // Set xA to be initial time to -1
    xB = 1.0;   // Set xB to be final time to +1

    for (int ind=0; ind<LenZG; ind++)
    {
        l = infonlpG.NLPIndZ.Var[ind];
        i = infonlpG.NLPIndZ.Phase[ind];
        j = infonlpG.NLPIndZ.Comp[ind];
        k = infonlpG.NLPIndZ.Pt[ind];

        if (l == 1) // If state variable
        {
            x               = rpmdG[i].tauO[k];             // Get time at collocation point k in [-1,+1]
            yA              = nlpgG.PG[i].x0[j];            // Set yA to be initial state guess for component j
            yB              = nlpgG.PG[i].xf[j];            // Set yB to be finial state guess for component j
            y               = LinearInterp(x,xA,xB,yA,yB);  // Get state guess at collocation point k using linear interpolation
            nlpigG.z[ind]   = y;
            g               = nlpigG.z[ind];
            if (k==0)   // If first point in phase
            {
                L_bound         = nlpbG.PB[i].x0L[j];   // set lower bound equal to initial state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].x0U[j];   // set upper bound equal to initial state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
            else if (k==NtG[i]) // If last point in phase
            {
                L_bound         = nlpbG.PB[i].xfL[j];   // set lower bound equal to final state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].xfU[j];   // set upper bound equal to final state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
            else    // for all other points in phase
            {
                L_bound         = nlpbG.PB[i].xL[j];    // set lower bound equal to state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].xU[j];    // set upper bound equal to state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
        }
        else if (l == 2)    // If control variable
        {
            x               = rpmdG[i].tauO[k];             // Get time at collocation point k in [-1,+1]
            yA              = nlpgG.PG[i].u0[j];            // Set yA to be initial state guess for component j
            yB              = nlpgG.PG[i].uf[j];            // Set yB to be finial state guess for component j
            y               = LinearInterp(x,xA,xB,yA,yB);  // Get control guess at collocation point k using linear interpolation
            nlpigG.z[ind]   = y;
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].uL[j];    // set lower bound equal to control lower bound
            nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].uU[j];    // set upper bound equal to control upper bound
            nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 3)    // If integral variable
        {
            nlpigG.z[ind]   = nlpgG.PG[i].q[j];
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].qL[j];    // set lower bound equal to integral lower bound
            nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].qU[j];    // set upper bound equal to integral upper bound
            nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 4)    // If initial variable
        {
            nlpigG.z[ind]   = nlpgG.PG[i].t0;
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].t0L;  // set lower bound equal to initial time lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].t0U;  // set upper bound equal to initial time upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 5)    // If final variable
        {
            nlpigG.z[ind]   = nlpgG.PG[i].tf;
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].tfL;  // set lower bound equal to final time lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater to the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].tfU;  // set upper bound equal to final time upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 6)    // If static variable
        {
            nlpigG.z[ind]   = nlpgG.WG.s[j];
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.WB.sL[j];   // set lower bound equal to static parameter lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater to the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.WB.sU[j];   // set upper bound equal to static parameter upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
    }
}

void getNLPZInitWarm(void)
{
    double tauOvalZ;
    double tauOvalW;
    int indw;
    int l, i, j, k;
    double xA, xB, yA, yB, x, y;
    double g;
    double L_bound;
    double U_bound;
    
    for (int ind=0; ind<LenZG; ind++)
    {
        l = infonlpG.NLPIndZ.Var[ind];
        i = infonlpG.NLPIndZ.Phase[ind];
        j = infonlpG.NLPIndZ.Comp[ind];
        k = infonlpG.NLPIndZ.Pt[ind];
        
        if (l == 1) // If state variable
        {
            tauOvalZ = rpmdG[i].tauO[k];
            indw = 0;
            tauOvalW = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;
            while (tauOvalZ>tauOvalW)
            {
                indw++;
                tauOvalW = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;
            }
//            printf("\ntauOvalZ = %.15e",tauOvalZ);
//            printf("\ntauOvalW = %.15e",tauOvalW);
            if (indw==0)    // Initial point of system
            {
                xA              = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;       // Current point of warm start solution is lower tau value
                xB              = sysinfowarmG.phaseinfo[i].ptInfo[indw+1].tau;     // Next point of warm start solution is upper tau value
                x               = rpmdG[i].tauO[k];                                 // Get time at collocation point k in [-1,+1]
                yA              = sysinfowarmG.phaseinfo[i].ptInfo[indw].x[j];      // Current point of warm start solution is lower state value
                yB              = sysinfowarmG.phaseinfo[i].ptInfo[indw+1].x[j];    // Next point of warm start solution is upper state value
                y               = LinearInterp(x,xA,xB,yA,yB);  // Get state guess at collocation point k using linear interpolation
                nlpigG.z[ind]   = y;
                g               = nlpigG.z[ind];
            }
            else    // After initial point
            {
                xA              = sysinfowarmG.phaseinfo[i].ptInfo[indw-1].tau;     // Previous point of warm start solution is lower tau value
                xB              = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;       // Current point of warm start solution is upper tau value
                x               = rpmdG[i].tauO[k];                                 // Get time at collocation point k in [-1,+1]
                yA              = sysinfowarmG.phaseinfo[i].ptInfo[indw-1].x[j];    // Previous point of warm start solution is lower state value
                yB              = sysinfowarmG.phaseinfo[i].ptInfo[indw].x[j];      // Current point of warm start solution is upper state value
                y               = LinearInterp(x,xA,xB,yA,yB);  // Get state guess at collocation point k using linear interpolation
                nlpigG.z[ind]   = y;
                g               = nlpigG.z[ind];
            }
            if (k==0)   // If first point in phase
            {
                L_bound         = nlpbG.PB[i].x0L[j];   // set lower bound equal to initial state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].x0U[j];   // set upper bound equal to initial state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
            else if (k==NtG[i]) // If last point in phase
            {
                L_bound         = nlpbG.PB[i].xfL[j];   // set lower bound equal to final state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].xfU[j];   // set upper bound equal to final state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
            else    // for all other points in phase
            {
                L_bound         = nlpbG.PB[i].xL[j];    // set lower bound equal to state lower bound
                nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
                if (g>L_bound)  // If guess value is greater than the lower bound
                {
                    nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
                }
                else
                {
                    nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
                }
                U_bound         = nlpbG.PB[i].xU[j];    // set upper bound equal to state upper bound
                nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
                if (g<U_bound)  // If guess value is less than the upper bound
                {
                    nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
                }
                else
                {
                    nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
                }
            }
        }
        else if (l == 2) // If control variable
        {
            tauOvalZ = rpmdG[i].tauO[k];
            indw = 0;
            tauOvalW = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;
            while (tauOvalZ>tauOvalW)
            {
                indw++;
                tauOvalW = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;
            }
//            printf("\ntauOvalZ = %.15e",tauOvalZ);
//            printf("\ntauOvalW = %.15e",tauOvalW);
            if (indw==0)    // Initial point of system
            {
                xA              = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;       // Current point of warm start solution is lower tau value
                xB              = sysinfowarmG.phaseinfo[i].ptInfo[indw+1].tau;     // Next point of warm start solution is upper tau value
                x               = rpmdG[i].tauO[k];                                 // Get time at collocation point k in [-1,+1]
                yA              = sysinfowarmG.phaseinfo[i].ptInfo[indw].u[j];      // Current point of warm start solution is lower control value
                yB              = sysinfowarmG.phaseinfo[i].ptInfo[indw+1].u[j];    // Next point of warm start solution is upper control value
                y               = LinearInterp(x,xA,xB,yA,yB);  // Get state guess at collocation point k using linear interpolation
                nlpigG.z[ind]   = y;
                g               = nlpigG.z[ind];
            }
            else    // After initial point
            {
                xA              = sysinfowarmG.phaseinfo[i].ptInfo[indw-1].tau;     // Previous point of warm start solution is lower tau value
                xB              = sysinfowarmG.phaseinfo[i].ptInfo[indw].tau;       // Current point of warm start solution is upper tau value
                x               = rpmdG[i].tauO[k];                                 // Get time at collocation point k in [-1,+1]
                yA              = sysinfowarmG.phaseinfo[i].ptInfo[indw-1].u[j];    // Previous point of warm start solution is lower control value
                yB              = sysinfowarmG.phaseinfo[i].ptInfo[indw].u[j];      // Current point of warm start solution is upper control value
                y               = LinearInterp(x,xA,xB,yA,yB);  // Get state guess at collocation point k using linear interpolation
                nlpigG.z[ind]   = y;
                g               = nlpigG.z[ind];
            }
            L_bound         = nlpbG.PB[i].uL[j];    // set lower bound equal to control lower bound
            nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].uU[j];    // set upper bound equal to control upper bound
            nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 3) // If integral variable
        {
            nlpigG.z[ind]   = sysinfowarmG.phaseinfo[i].q[j];
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].qL[j];    // set lower bound equal to integral lower bound
            nlpigG.zBL[ind] = L_bound;              // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].qU[j];    // set upper bound equal to integral upper bound
            nlpigG.zBU[ind] = U_bound;              // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 4) // If initial time variable
        {
            nlpigG.z[ind]   = sysinfowarmG.phaseinfo[i].t0;
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].t0L;  // set lower bound equal to initial time lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater than the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].t0U;  // set upper bound equal to initial time upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 5) // If final time variable
        {
            nlpigG.z[ind]   = sysinfowarmG.phaseinfo[i].tf;
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.PB[i].tfL;  // set lower bound equal to final time lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater to the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.PB[i].tfU;  // set upper bound equal to final time upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
        else if (l == 6) // If static parameter variable
        {
            nlpigG.z[ind]   = sysinfowarmG.s[j];
            g               = nlpigG.z[ind];
            L_bound         = nlpbG.WB.sL[j];   // set lower bound equal to static parameter lower bound
            nlpigG.zBL[ind] = L_bound;          // set lower bound for index in NLP decision vector
            if (g>L_bound)  // If guess value is greater to the lower bound
            {
                nlpigG.zL[ind] = 0; // Initialize lower bound multiplier as inactive
            }
            else
            {
                nlpigG.zL[ind] = 1.0;   // Initialize lower bound multiplier as active
            }
            U_bound         = nlpbG.WB.sU[j];   // set upper bound equal to static parameter upper bound
            nlpigG.zBU[ind] = U_bound;          // set upper bound for index in NLP decision vector
            if (g<U_bound)  // If guess value is less than the upper bound
            {
                nlpigG.zU[ind] = 0; // Initialize upper bound multiplier as inactive
            }
            else
            {
                nlpigG.zU[ind] = 1.0;   // Initialize upper bound multiplier as active
            }
        }
    }
}

void getNLPLambdaInit(void)
{
    int l, i, j, k;
    
    for (int ind=0; ind<LenHG; ind++)
    {
        l = infonlpG.NLPIndH.Var[ind];
        i = infonlpG.NLPIndH.Phase[ind];
        j = infonlpG.NLPIndH.Comp[ind];
        k = infonlpG.NLPIndH.Pt[ind];
        
        nlpigG.lambda[ind] = 0.001; // initialize Lagrange multiplier to 1e-3
        
        if (l == 7) // If defect constraint
        {
            if (k<NtG[i])  // If not final point in phase
            {
                nlpigG.hBL[ind] = 0;    // set lower bound for index in NLP Constraints Vector
                nlpigG.hBU[ind] = 0;    // set upper bound for index in NLP Constraints Vector
            }
            else if (k==NtG[i]) // final point in phase (Lavrentiev constraint)
            {
                nlpigG.hBL[ind] = -LavrentievTolG.mat[i].val[j];  // set lower bound for index in NLP Constraints Vector for state component j in phase i
                nlpigG.hBU[ind] = LavrentievTolG.mat[i].val[j];   // set upper bound for index in NLP Constraints Vector for state component j in phase i
            }
        }
        else if (l == 8)    // If path constraint
        {
            nlpigG.hBL[ind] = nlpbG.PB[i].cL[j];    // set lower bound for index in NLP Constraints Vector
            nlpigG.hBU[ind] = nlpbG.PB[i].cU[j];    // set upper bound for index in NLP Constraints Vector
        }
        else if (l == 9)    // If approximation constraint
        {
            nlpigG.hBL[ind] = 0;    // set lower bound for index in NLP Constraints Vector
            nlpigG.hBU[ind] = 0;    // set upper bound for index in NLP Constraints Vector
        }
        else if (l == 10)   // If event constraint
        {
            nlpigG.hBL[ind] = nlpbG.WB.bL[j];   // set lower bound for index in NLP Constraints Vector
            nlpigG.hBU[ind] = nlpbG.WB.bU[j];   // set upper bound for index in NLP Constraints Vector
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------NLP Scaling functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void getScalarZ(void)   // Get ScaleZ and ShiftZ values from nlpigG and infonlpG.NLPIndZ
{
    int var,phase,comp,pt;
    int indAlt;
    
    for (int ind=0; ind<LenZG; ind++)
    {
        var = infonlpG.NLPIndZ.Var[ind];
        phase = infonlpG.NLPIndZ.Phase[ind];
        comp = infonlpG.NLPIndZ.Comp[ind];
        pt = infonlpG.NLPIndZ.Pt[ind];
        
        switch (var)
        {
            case 1: // State variable
                if (pt==0)  // If initial point in phase
                {
                    indAlt = ind + 1;   // Use bounds for second point in phase (interior point bounds)
                    if (nlpigG.zBL[indAlt]==nlpigG.zBU[indAlt])
                    {
                        if (nlpigG.zBL[indAlt]==0)  // Lower bound is zero
                        {
                            nlpsG.ScaleZ[ind] = 1;
                            nlpsG.ShiftZ[ind] = 0;
                        }
                        else if (nlpigG.zBL[indAlt]>0)  // Lower bound is greater than zero
                        {
                            nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[indAlt];
                            nlpsG.ShiftZ[ind] = -1;
                        }
                        else if (nlpigG.zBL[indAlt]<0)  // Lower bound is less than zero
                        {
                            nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[indAlt];
                            nlpsG.ShiftZ[ind] = 1;
                        }
                    }
                    else
                    {
                        nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[indAlt]-nlpigG.zBL[indAlt]);
                        nlpsG.ShiftZ[ind] = (nlpigG.zBL[indAlt]+nlpigG.zBU[indAlt])/(2.0*(nlpigG.zBL[indAlt]-nlpigG.zBU[indAlt]));
                    }
                    nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                    nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                }
                else if (pt==NtG[phase])    // If final point in phase
                {
                    indAlt = ind - 1;   // Use bounds for second to last point in phase (interior point bounds)
                    if (nlpigG.zBL[indAlt]==nlpigG.zBU[indAlt])
                    {
                        if (nlpigG.zBL[indAlt]==0)  // Lower bound is zero
                        {
                            nlpsG.ScaleZ[ind] = 1;
                            nlpsG.ShiftZ[ind] = 0;
                        }
                        else if (nlpigG.zBL[indAlt]>0)  // Lower bound is greater than zero
                        {
                            nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[indAlt];
                            nlpsG.ShiftZ[ind] = -1;
                        }
                        else if (nlpigG.zBL[indAlt]<0)  // Lower bound is less than zero
                        {
                            nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[indAlt];
                            nlpsG.ShiftZ[ind] = 1;
                        }
                    }
                    else
                    {
                        nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[indAlt]-nlpigG.zBL[indAlt]);
                        nlpsG.ShiftZ[ind] = (nlpigG.zBL[indAlt]+nlpigG.zBU[indAlt])/(2.0*(nlpigG.zBL[indAlt]-nlpigG.zBU[indAlt]));
                    }
                    nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                    nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                }
                else    // Interior point in phase
                {
                    if (nlpigG.zBL[ind]==nlpigG.zBU[ind])
                    {
                        if (nlpigG.zBL[ind]==0)  // Lower bound is zero
                        {
                            nlpsG.ScaleZ[ind] = 1;
                            nlpsG.ShiftZ[ind] = 0;
                        }
                        else if (nlpigG.zBL[ind]>0)  // Lower bound is greater than zero
                        {
                            nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[ind];
                            nlpsG.ShiftZ[ind] = -1;
                        }
                        else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                        {
                            nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[ind];
                            nlpsG.ShiftZ[ind] = 1;
                        }
                    }
                    else
                    {
                        nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[ind]-nlpigG.zBL[ind]);
                        nlpsG.ShiftZ[ind] = (nlpigG.zBL[ind]+nlpigG.zBU[ind])/(2.0*(nlpigG.zBL[ind]-nlpigG.zBU[ind]));
                    }
                    nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                    nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                }
                break;
                
            case 2: // Control variable
                if (nlpigG.zBL[ind]==nlpigG.zBU[ind])
                {
                    if (nlpigG.zBL[ind]==0)  // Lower bound is zero
                    {
                        nlpsG.ScaleZ[ind] = 1;
                        nlpsG.ShiftZ[ind] = 0;
                    }
                    else if (nlpigG.zBL[ind]>0)  // Lower bound is greater than zero
                    {
                        nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = -1;
                    }
                    else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                    {
                        nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = 1;
                    }
                }
                else
                {
                    nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[ind]-nlpigG.zBL[ind]);
                    nlpsG.ShiftZ[ind] = (nlpigG.zBL[ind]+nlpigG.zBU[ind])/(2.0*(nlpigG.zBL[ind]-nlpigG.zBU[ind]));
                }
                nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                break;
                
            case 3: // Integral variable
                if (nlpigG.zBL[ind]==nlpigG.zBU[ind])
                {
                    if (nlpigG.zBL[ind]==0)  // Lower bound is zero
                    {
                        nlpsG.ScaleZ[ind] = 1;
                        nlpsG.ShiftZ[ind] = 0;
                    }
                    else if (nlpigG.zBL[ind]>0)  // Lower bound is greater than zero
                    {
                        nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = -1;
                    }
                    else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                    {
                        nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = 1;
                    }
                }
                else
                {
                    nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[ind]-nlpigG.zBL[ind]);
                    nlpsG.ShiftZ[ind] = (nlpigG.zBL[ind]+nlpigG.zBU[ind])/(2.0*(nlpigG.zBL[ind]-nlpigG.zBU[ind]));
                }
                nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                break;
                
            case 4: // Initial time variable
                indAlt = ind + 1;   // Set alternate index to next index (final time bounds)
                if (nlpigG.zBL[ind]==nlpigG.zBU[indAlt])    // If lower bounds on initial time equals upper bounds on final time (shouldn't happen)
                {
                    if (nlpigG.zBL[ind]==0)  // Lower bound is zero
                    {
                        nlpsG.ScaleZ[ind] = 1;
                        nlpsG.ShiftZ[ind] = 0;
                    }
                    else if (nlpigG.zBL[ind]>0)  // Lower bound is greater than zero
                    {
                        nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = -1;
                    }
                    else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                    {
                        nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = 1;
                    }
                    printf("\nFinal time upper bounds equals lower time lower bounds...");
                }
                else
                {
                    nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[indAlt]-nlpigG.zBL[ind]);
                    nlpsG.ShiftZ[ind] = (nlpigG.zBL[ind]+nlpigG.zBU[indAlt])/(2.0*(nlpigG.zBL[ind]-nlpigG.zBU[indAlt]));
                }
                nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                break;
                
            case 5: // Final time variable
                indAlt = ind - 1;   // Set alternate index to previous index (initial time bounds)
                if (nlpigG.zBL[indAlt]==nlpigG.zBU[ind])    // If lower bounds on initial time equals upper bounds on final time (shouldn't happen)
                {
                    if (nlpigG.zBL[indAlt]==0)  // Lower bound is zero
                    {
                        nlpsG.ScaleZ[ind] = 1;
                        nlpsG.ShiftZ[ind] = 0;
                    }
                    else if (nlpigG.zBL[indAlt]>0)  // Lower bound is greater than zero
                    {
                        nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[indAlt];
                        nlpsG.ShiftZ[ind] = -1;
                    }
                    else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                    {
                        nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[indAlt];
                        nlpsG.ShiftZ[ind] = 1;
                    }
                    printf("\nFinal time upper bounds equals lower time lower bounds...");
                }
                else
                {
                    nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[ind]-nlpigG.zBL[indAlt]);
                    nlpsG.ShiftZ[ind] = (nlpigG.zBL[indAlt]+nlpigG.zBU[ind])/(2.0*(nlpigG.zBL[indAlt]-nlpigG.zBU[ind]));
                }
                nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                break;
                
            case 6: // Static parameter variable
                if (nlpigG.zBL[ind]==nlpigG.zBU[ind])
                {
                    if (nlpigG.zBL[ind]==0)  // Lower bound is zero
                    {
                        nlpsG.ScaleZ[ind] = 1;
                        nlpsG.ShiftZ[ind] = 0;
                    }
                    else if (nlpigG.zBL[ind]>0)  // Lower bound is greater than zero
                    {
                        nlpsG.ScaleZ[ind] = 1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = -1;
                    }
                    else if (nlpigG.zBL[ind]<0)  // Lower bound is less than zero
                    {
                        nlpsG.ScaleZ[ind] = -1.0/nlpigG.zBL[ind];
                        nlpsG.ShiftZ[ind] = 1;
                    }
                }
                else
                {
                    nlpsG.ScaleZ[ind] = 1.0/(nlpigG.zBU[ind]-nlpigG.zBL[ind]);
                    nlpsG.ShiftZ[ind] = (nlpigG.zBL[ind]+nlpigG.zBU[ind])/(2.0*(nlpigG.zBL[ind]-nlpigG.zBU[ind]));
                }
                nlpsG.minScaledZ[ind] = nlpigG.zBL[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                nlpsG.maxScaledZ[ind] = nlpigG.zBU[ind]*nlpsG.ScaleZ[ind] + nlpsG.ShiftZ[ind];
                break;
                
            default:    // Unrecognized variable
                printf("\nUnrecognized variable in getScalarZ(void)");
                break;
        }
    }
}

void getScalarH(void)   // Get ScaleH and ShiftH values from global structures nlpigG and infonlpG.NLPIndH
{
    int var,phase,comp,pt;
    int nlpindz;
    int nd = 0,ne = 0;
    doubleMatMat pathGradMeans;
    doubleMat eventGradMeans;

    pathGradMeans   = getPathGradientMeans();
    eventGradMeans  = getEventGradientMeans();

//    printf(pathGradMeans);
//    printf(eventGradMeans);
    
    if (DurationFlagG)  // If duration constraint enforced
    {
        nd = PG;
    }
    if (ContinuityFlagG)  // If continuity constraint enforced
    {
        ne = neG;
    }

    for (int ind=0; ind<LenHG; ind++)
    {
        var = infonlpG.NLPIndH.Var[ind];
        phase = infonlpG.NLPIndH.Phase[ind];
        comp = infonlpG.NLPIndH.Comp[ind];
        pt = infonlpG.NLPIndH.Pt[ind];

        switch (var)    // Constraint type
        {
            case 7: // Defect constraint
                nlpindz = mainNLPIndZ(1,phase,comp,pt); // Get index of corresponding state component at point in phase
                nlpsG.ScaleH[ind] = nlpsG.ScaleZ[nlpindz];  // Set scalar for defect constraint equal to scalar for corresponding state component at point in phase
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;

            case 8: // Path constraint
                if (pathGradMeans.mat[phase].val[comp]!=0)    // If mean path partial gradient norm is nonzero
                {
                    nlpsG.ScaleH[ind] = 1.0/pathGradMeans.mat[phase].val[comp]; // Set scalar for path constraint equal to 1 divided by the average path comp gradient norm
                }
                else
                {
                    nlpsG.ScaleH[ind] = 1.0;    // Set scalar for path constraint equal to 1
                }
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;

            case 9: // Approximation constraint
                nlpindz = mainNLPIndZ(3,phase,comp,pt); // Get index of corresponding integral component at point in phase
                nlpsG.ScaleH[ind] = nlpsG.ScaleZ[nlpindz];  // Set scalar for approximation constraint equal to scalar for corresponding integral component in phase
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;

            case 10:    // Event constraint
                if ((DurationFlagG)&&(ContinuityFlagG)&&(comp<nd))
                {
                    nlpsG.ScaleH[ind] = 1;
                }
                else if ((DurationFlagG)&&(comp<nd))
                {
                    nlpsG.ScaleH[ind] = 1;
                }
//                else if ((ContinuityFlagG)&&(comp<ne))
//                {
//                    nlpsG.ScaleH[ind] = 1;
//                }
                else
                {
                    if (eventGradMeans.val[comp-nd]!=0) // If mean event partial gradient norm is nonzero
                    {
                        nlpsG.ScaleH[ind] = 1.0/eventGradMeans.val[comp-nd];    // Set scalar for event constraint equal to 1 divided by the average event comp gradient norm
                    }
                    else
                    {
                        nlpsG.ScaleH[ind] = 1.0;    // Set scalar for path constraint equal to 1
                    }
                }
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;

            default:    // Unrecognized constraint
                printf("\nUnrecognized constraint in getScalarH(void)");
                break;
        }
    }
}

void getScalarH(doubleMatMat& pathScalars, doubleMat& eventScalars) // Get ScaleH and ShiftH values from global structures nlpigG and infonlpG.NLPIndH
{
    int var,phase,comp,pt;
    int nlpindz;
    int nd = 0, ne = 0;
//    doubleMatMat pathGradMeans;
    doubleMat eventGradMeans;
    
//    pathGradMeans   = getPathGradientMeans();
    eventGradMeans  = getEventGradientMeans();
    
//    printfMatrix(pathGradMeans);
//    printf(eventGradMeans);
    
    if (DurationFlagG)  // If duration constraint enforced
    {
        nd = PG;
    }
    if (ContinuityFlagG)    // If continuity constraint enforced
    {
        ne = neG;
    }
    
    for (int ind=0; ind<LenHG; ind++)
    {
        var = infonlpG.NLPIndH.Var[ind];
        phase = infonlpG.NLPIndH.Phase[ind];
        comp = infonlpG.NLPIndH.Comp[ind];
        pt = infonlpG.NLPIndH.Pt[ind];
        
        switch (var)    // Constraint type
        {
            case 7: // Defect constraint
                nlpindz = mainNLPIndZ(1,phase,comp,pt); // Get index of corresponding state component at point in phase
                nlpsG.ScaleH[ind] = nlpsG.ScaleZ[nlpindz];  // Set scalar for defect constraint equal to scalar for corresponding state component at point in phase
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;
                
            case 8: // Path constraint
                nlpsG.ScaleH[ind] = pathScalars.mat[phase].val[comp]; // Set scalar for path constraint equal to 1 divided by the average path comp gradient norm
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;
                
            case 9: // Approximation constraint
                nlpindz = mainNLPIndZ(3,phase,comp,pt); // Get index of corresponding integral component at point in phase
                nlpsG.ScaleH[ind] = nlpsG.ScaleZ[nlpindz];  // Set scalar for approximation constraint equal to scalar for corresponding integral component in phase
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;
                
            case 10:    // Event constraint
                if ((DurationFlagG)&&(ContinuityFlagG)&&(comp<nd))
                {
                    nlpsG.ScaleH[ind] = 1;
                }
                else if ((DurationFlagG)&&(comp<nd))
                {
                    nlpsG.ScaleH[ind] = 1;
                }
                else if ((ContinuityFlagG)&&(comp<nd+ne))
                {
                    if (eventGradMeans.val[comp-nd]!=0) // If mean event partial gradient norm is nonzero
                    {
                        nlpsG.ScaleH[ind] = 1.0/eventGradMeans.val[comp-nd];    // Set scalar for event constraint equal to 1 divided by the average event comp gradient norm
                    }
                    else
                    {
                        nlpsG.ScaleH[ind] = 1.0;    // Set scalar for path constraint equal to 1
                    }
                }
                else
                {
                    nlpsG.ScaleH[ind] = eventScalars.val[comp-nd-ne];   // Set scalar for event constraint equal to 1 divided by the average event comp gradient norm
                }
                nlpsG.minScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBL[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                nlpsG.maxScaledH[ind] = nlpsG.ScaleH[ind]*nlpigG.hBU[ind];  // Set scaled mininum bound to equal unscaled bound times constraint scalar
                break;
                
            default:    // Unrecognized constraint
                printf("\nUnrecognized constraint in getScalarH(const ...)");
                break;
        }
    }
}

void printf(const NLP_INIT_GUESS& nlpig, const NLP_SCALING& nlps)   // View NLP bounds and scalar values
{
    for (int i=0; i<nlpig.NumZ; i++)
    {
        printf("\nzBL[%d] = %.5f  |  ScaleZ[%d] = %.5f  |  ShiftZ[%d] = %.5f  |  zBU[%d] = %.5f  |  minScaledZ[%d] = %.5f  |  maxScaledZ[%d] = %.5f",i,nlpig.zBL[i],i,nlps.ScaleZ[i],i,nlps.ShiftZ[i],i,nlpig.zBU[i],i,nlps.minScaledZ[i],i,nlps.maxScaledZ[i]);
    }
    for (int i=0; i<nlpig.NumH; i++)
    {
        printf("\nhBL[%d] = %.5f  |  ScaleH[%d] = %.5f  |  ShiftH[%d] = %.5f  |  hBU[%d] = %.5f  |  minScaledH[%d] = %.5f  |  maxScaledH[%d] = %.5f",i,nlpig.hBL[i],i,nlps.ScaleH[i],i,nlps.ShiftH[i],i,nlpig.hBU[i],i,nlps.minScaledH[i],i,nlps.maxScaledH[i]);
    }
}

void getCostate(void)   // Compute values of costate from nlplmG
{
    int phase,comp,pt,nlpindZ,nlpindH,DJ;
    double Wval,Dval,DLsum;
    
    for (int i=0; i<LenHG; i++)
    {
        if (infonlpG.NLPIndH.Var[i]==7) // If defect constraint
        {
            phase                   = infonlpG.NLPIndH.Phase[i];
            comp                    = infonlpG.NLPIndH.Comp[i];
            pt                      = infonlpG.NLPIndH.Pt[i];
            Wval                    = rpmdG[phase].weightO[pt];
            nlpindZ                 = mainNLPIndZ(1,phase,comp,pt);
//            nlplmG.Costate[nlpindZ] = -nlplmG.UnscaledL[i]/Wval;
            nlplmG.Costate[nlpindZ] = -nlplmG.UnscaledL[i]/Wval*rpmdG[phase].fractionMat[pt];
       }
    }
    for (phase=0; phase<PG; phase++)    // for all phases
    {
        for (comp=0; comp<nxG[phase]; comp++)   // for all state components in phase
        {
            DLsum = 0;  // initialize sum to zero
            for (int i=0; i<rpmdG[phase].DOffCnt; i++)    // for all off diagonal indices
            {
                DJ = rpmdG[phase].DOffDiagJO[i];  // Get column index of current D matrix element
                if (DJ == NtG[phase])   // if final column
                {
                    pt      = rpmdG[phase].DOffDiagIO[i];          // Set point equal to row index associated with current D matrix element
                    nlpindH = mainNLPIndH(7,phase,comp,pt);     // Get index of corresponding NLP Lagrange Multiplier
//                    Dval    = rpmdG[phase].DOffDiagValO[i];      // Get value of current element in D matrix
                    Dval    = rpmdG[phase].DOffDiagVal[i];      // Get value of current element in D matrix
                    DLsum   = DLsum + Dval*nlplmG.UnscaledL[nlpindH];    // Add product to summation
                }
            }
            nlpindZ                 = mainNLPIndZ(1,phase,comp,NtG[phase]); // get index of corresponding state in NLP decision vector
            nlplmG.Costate[nlpindZ] = -DLsum; // Set value of costate at noncollocated end point
        }
    }
}

void getCostate(int LavrentievConstraintFlag)   // Compute values of costate from nlplmG. Input: flag indicating Lavrentiev constraints are being used
{
    int phase,comp,pt,nlpindZ,nlpindH,DJ;
    double Wval,Dval,DLsum;
    int nlpindH2;
    int lastSegFirstPt[PG];
    
    for (phase=0; phase<PG; phase++)
    {
        lastSegFirstPt[phase] = rpmdG[phase].sumColPoints - rpmdG[phase].ColPoints[rpmdG[phase].NumInterval-1]; // Compute index value (c) for first collocation point in last interval of phase
    }
    
    for (int i=0; i<LenHG; i++)
    {
        if (infonlpG.NLPIndH.Var[i]==7) // If defect constraint
        {
            phase                   = infonlpG.NLPIndH.Phase[i];    // Extract phase number
            comp                    = infonlpG.NLPIndH.Comp[i];     // Extract component number
            pt                      = infonlpG.NLPIndH.Pt[i];       // Extract point number
            if (pt<NtG[phase])  // If not final point in phase
            {
                Wval                    = rpmdG[phase].weightO[pt];                 // Extract LGR weight at point
                nlpindZ                 = mainNLPIndZ(1,phase,comp,pt,1);           // Extract index in nlp decision vector of corresponding state variable
                nlpindH2                = mainNLPIndH(7,phase,comp,NtG[phase],1);   // Extract index in nlp constraints vector of Lavrentiev constraint for corresponding defect constraint component
                if ((pt>=lastSegFirstPt[phase])&&(LavrentievConstraintCompG.mat[phase].val[comp]))   // If pt is in last interval of phase and Lavrentiev constraints active in phase for state comp
                {
                    nlplmG.Costate[nlpindZ] = -(nlplmG.UnscaledL[i]/Wval+nlplmG.UnscaledL[nlpindH2]*rpmdG[phase].DMat[pt*(rpmdG[phase].sumColPoints+1)+rpmdG[phase].sumColPoints])*rpmdG[phase].fractionMat[pt];    // Compute costate using transformation for modified LGR with Lavrentiev constraints (D_{N+1} is just zero for points in other intervals)
                }
                else    // pt is in interval before last interval in phase and/or normal LGR collocation
                {
                    nlplmG.Costate[nlpindZ] = -(nlplmG.UnscaledL[i]/Wval)*rpmdG[phase].fractionMat[pt]; // Compute costate normally
                }
            }
        }
    }
    for (phase=0; phase<PG; phase++)    // for all phases
    {
        for (comp=0; comp<nxG[phase]; comp++)   // for all state components in phase
        {
            DLsum = 0;  // initialize sum to zero
            for (int i=0; i<rpmdG[phase].DOffCnt; i++)    // for all off diagonal indices
            {
                DJ = rpmdG[phase].DOffDiagJO[i];  // Get column index of current D matrix element
                if (DJ == NtG[phase])   // if final column
                {
                    pt      = rpmdG[phase].DOffDiagIO[i];          // Set point equal to row index associated with current D matrix element
                    nlpindH = mainNLPIndH(7,phase,comp,pt);     // Get index of corresponding NLP Lagrange Multiplier
                    //                    Dval    = rpmdG[phase].DOffDiagValO[i];      // Get value of current element in D matrix
                    Dval    = rpmdG[phase].DOffDiagVal[i];      // Get value of current element in D matrix
                    DLsum   = DLsum + Dval*nlplmG.UnscaledL[nlpindH];    // Add product to summation
//                    printf("\nDval  = %.15e",Dval);
//                    printf("\nDLsum = %.15e",DLsum);
                }
            }
            nlpindZ                 = mainNLPIndZ(1,phase,comp,NtG[phase]); // get index of corresponding state in NLP decision vector
            if (LavrentievConstraintCompG.mat[phase].val[comp])  // If Lavrentiev constraint enforced in phase for state comp
            {
                nlpindH2                = mainNLPIndH(7,phase,comp,NtG[phase],1);   // Extract index in nlp constraints vector of Lavrentiev constraint for corresponding defect constraint component
                nlplmG.Costate[nlpindZ] = -(DLsum+nlplmG.UnscaledL[nlpindH2]*rpmdG[phase].LavRow.val[rpmdG[phase].LavRow.Len-1]);   // Set value of costate at noncollocated end point using transformation for modified LGR with Lavrentiev constraints
            }
            else
            {
                nlplmG.Costate[nlpindZ] = -DLsum;   // Set value of costate at noncollocated end point using transformation for normal LGR without Lavrentiev constraints
            }
            
//            printf("\nnlplmG.Costate[%d] = %.15e",nlpindZ,nlplmG.Costate[nlpindZ]);
        }
    }
}

void getNLPScalars(void)    // Compute scalar and shifter values for NLP variables and constraints (uses global infonlpG and nlpigG classes)
{
    nlpsG = getNLPS(LenZG,LenHG);
    getScalarZ();   // Get ScaleZ and ShiftZ values from global structures nlpigG and infonlpG.NLPIndZ
    getScalarH();   // Get ScaleH and ShiftH values from global structures nlpigG and infonlpG.NLPIndH
}

void getNLPScalars(doubleMatMat& pathScalars, doubleMat& eventScalars)  // Compute scalar and shifter values for NLP variables and constraints (uses global infonlpG and nlpigG classes)
{
    nlpsG = getNLPS(LenZG,LenHG);
    getScalarZ();   // Get ScaleZ and ShiftZ values from global structures nlpigG and infonlpG.NLPIndZ
    getScalarH(pathScalars,eventScalars);   // Get ScaleH and ShiftH values from global structures nlpigG and infonlpG.NLPIndH
}

doubleMatMat getPathGradientMeans(void) // Get mean values of path constraint gradients
{
    int phase,comp,pt;
    doubleMatMat pathGradMeans(PG); // Allocate memory for number phases in problem
    doubleMatMat pathGradNorms[PG]; // Allocate memory for number phases in problem
    int nlpindz;
    int numSample = 100;
    doubleMatMat randomStateVals[PG];
    doubleMatMat randomControlVals[PG];
    doubleMatMat randomTimeVals[PG];
    doubleMatMat randomStaticVals;
    double LB, UB;
    double randFrac;
    int randNum;
    doubleMatMatMat pathGradVals[PG];
    int numPartials[PG];
    int partialInd;
    doubleMat value(1);
    int var;
    ParametersStructMat parametersStructMat(PG);
    ParametersStructHDMat parametersStructHDMat(PG);
    
//    srand((unsigned int)time(NULL));
    srand((unsigned int)12345);
    
    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nppG[phase]>0)  // If one or more phase parameter in phase
        {
            parametersStructMat.parametersStruct[phase]     = getParametersStruct(1);     // Allocate memory for number of phase parameters in phase
            parametersStructHDMat.parametersStruct[phase]   = getParametersStructHD(1);   // Allocate memory for number of phase parameters in phase
            
            parametersStructMat.parametersStruct[phase].parametersMat[0] = getDoubleMat(nppG[phase]);        // Allocate memory for single point
            parametersStructHDMat.parametersStruct[phase].parametersMat[0] = getHyperDualMat(nppG[phase]);   // Allocate memory for single point
        }
        
        if (ncG[phase]>0)   // If one or more path constraints in phase
        {
            pathGradMeans.mat[phase] = getDoubleMat(ncG[phase]);  // Allocate memory for number of path constraints in phase
            pathGradVals[phase] = getDoubleMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
            pathGradNorms[phase] = getDoubleMatMat(ncG[phase]); // Allocate memory for number of path constraints in phase
            for (comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
            {
                pathGradVals[phase].mat[comp] = getDoubleMatMat(numSample);    // Allocate memory for each sample point
                for (pt=0; pt<numSample; pt++)  // For each sample point
                {
                    numPartials[phase] = nxG[phase] + nuG[phase] + 1 + nsG; // Compute maximum possible number of partials
                    pathGradVals[phase].mat[comp].mat[pt] = getDoubleMat(numPartials[phase]);    // Allocate memory for maximum possible number of partials
                }
                pathGradNorms[phase].mat[comp] = getDoubleMat(numSample); // Allocate memory for each sample point
            }
//            printf("\npathGradNorms[%d] = ",phase);
//            printfMatrix(pathGradNorms[phase]);

            if (nxG[phase]>0) // If one or more state components in phase
            {
                randomStateVals[phase]      = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
                for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    randomStateVals[phase].mat[comp]      = getDoubleMat(numSample);  // Allocate memory for number of sample points

                    nlpindz = mainNLPIndZ(1,phase,comp,1,1);    // Get index of corresponding state component at second point in phase
                    LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding state component in phase
                    UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding state component in phase

                    for (pt=0; pt<numSample; pt++)  // For each sample point
                    {
                        randNum     = rand();   // Get random integer value
                        randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible

                        randomStateVals[phase].mat[comp].val[pt] = LB + randFrac*(UB-LB); // Set random value at sample point for state component in phase
                    }
                }
            }

            if (nuG[phase]>0) // If one or more control components in phase
            {
                randomControlVals[phase] = getDoubleMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
                for (comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                {
                    randomControlVals[phase].mat[comp] = getDoubleMat(numSample); // Allocate memory for number of sample points

                    nlpindz = mainNLPIndZ(2,phase,comp,0,1);  // Get index of corresponding control component at first point in phase
                    LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding control component in phase
                    UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding control component in phase

                    for (pt=0; pt<numSample; pt++)  // For each sample point
                    {
                        randNum     = rand();   // Get random integer value
                        randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible

                        randomControlVals[phase].mat[comp].val[pt] = LB + randFrac*(UB-LB);   // Set random value at sample point for control component in phase
                    }
                }
            }

            randomTimeVals[phase] = getDoubleMatMat(1);   // Allocate memory for time in phase

            randomTimeVals[phase].mat[0] = getDoubleMat(numSample);  // Allocate memory for number of sample points

            nlpindz = mainNLPIndZ(4,phase,-1,-1,1);   // Get index of initial time in phase
            LB = nlpigG.zBL[nlpindz];   // Set lower bound for initial time in phase

            nlpindz = mainNLPIndZ(5,phase,-1,-1,1);   // Get index of final time in phase
            UB = nlpigG.zBU[nlpindz];   // Set upper bound for final time in phase

            for (pt=0; pt<numSample; pt++)  // For each sample point
            {
                randNum     = rand();   // Get random integer value
                randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible

                randomTimeVals[phase].mat[0].val[pt] = LB + randFrac*(UB-LB); // Set random value at sample point for time in phase
            }
        }
    }
    
//    printf("\npathGradMeans = ");
//    printf(pathGradMeans);

    if (nsG>0)  // If one or more static parameters in phase
    {
        randomStaticVals = getDoubleMatMat(nsG);    // Allocate memory for number of static parameters
        for (comp=0; comp<nsG; comp++)  // For each static parameter
        {
            randomStaticVals.mat[comp] = getDoubleMat(numSample); // Allocate memory for number of sample points

            nlpindz = mainNLPIndZ(6,-1,comp,-1,1);    // Get index of corresponding static parameter
            LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding static parameter
            UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding static parameter

            for (pt=0; pt<numSample; pt++)  // For each sample point
            {
                randNum     = rand();   // Get random integer value
                randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible

                randomStaticVals.mat[comp].val[pt] = LB + randFrac*(UB-LB);   // Set random value at sample point for corresponding static parameter
            }
        }
    }
    
    for (comp=0; comp<nsG; comp++)  // For each static parameter
    {
        sysinfoCDG.s[comp] = sysinfoG.s[comp];  // Save static parameter value
    }
    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (comp=0; comp<nxG[phase]; comp++)   // For each state component
        {
            sysinfoCDG.phaseinfo[phase].ptInfo[0].x[comp] = sysinfoG.phaseinfo[phase].ptInfo[0].x[comp];    // Save state component at first point in phase
        }
        for (comp=0; comp<nuG[phase]; comp++)   // For each control component
        {
            sysinfoCDG.phaseinfo[phase].ptInfo[0].u[comp] = sysinfoG.phaseinfo[phase].ptInfo[0].u[comp];    // Save control component at first point in phase
        }
        sysinfoCDG.phaseinfo[phase].ptInfo[0].t = sysinfoG.phaseinfo[phase].ptInfo[0].t;    // Save time at first point in phase
    }

    for (pt=0; pt<numSample; pt++)  // For each sample point
    {
        for (comp=0; comp<nsG; comp++)  // For each static parameter
        {
            sysinfoHDG.s[comp] = randomStaticVals.mat[comp].val[pt];  // Set static parameter to value at random sample pt
            sysinfoG.s[comp] = randomStaticVals.mat[comp].val[pt];  // Set static parameter to value at random sample pt
        }

        for (phase=0; phase<PG; phase++)    // For each phase in problem
        {
            if (ncG[phase]>0)   // If one or more path constraints in phase
            {
                for (comp=0; comp<nxG[phase]; comp++)   // For each state component
                {
                    sysinfoG.phaseinfo[phase].ptInfo[0].x[comp] = randomStateVals[phase].mat[comp].val[pt]; // Set state component at first point in phase to value at random sample pt
                    sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = randomStateVals[phase].mat[comp].val[pt]; // Set state component at first point in phase to value at random sample pt
                }
                for (comp=0; comp<nuG[phase]; comp++)   // For each control component
                {
                    sysinfoG.phaseinfo[phase].ptInfo[0].u[comp] = randomControlVals[phase].mat[comp].val[pt];   // Set control component at first point in phase to value at random sample pt
                    sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = randomControlVals[phase].mat[comp].val[pt];   // Set control component at first point in phase to value at random sample pt
                }
                sysinfoG.phaseinfo[phase].ptInfo[0].t = randomTimeVals[phase].mat[0].val[pt];   // Set time at first point in phase to value at random sample pt
                sysinfoHDG.phaseinfo[phase].ptInfo[0].t = randomTimeVals[phase].mat[0].val[pt];   // Set time at first point in phase to value at random sample pt
                
                for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                {
                    phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoG.phaseinfo[phase],sysinfoG.s,parametersStructMat.parametersStruct[phase]);        // Compute phase parameter param
                    phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);  // Compute phase parameter param
                }
                
                for (int constraint=0; constraint<ncG[phase]; constraint++) // For each path constraint in phase
                {
                    for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        if (PathStateDependMapG.mat[phase].mat[constraint].val[comp])  // If path constraint is dependent on state component in phase
                        {
                            partialInd = comp;  // Set partial index to current state component
                            var = 1;
                            
                            path_func_Grad_HD(phase,constraint,var,comp,parametersStructMat.parametersStruct[phase],sysinfoHDG,parametersStructHDMat.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of path constraint wrt state comp at first point in phase

                            pathGradVals[phase].mat[constraint].mat[pt].val[partialInd] = value.val[0];  // Extract partial of path constraint wrt to state component at first point in phase
                        }
                    }
                    
                    for (comp=0; comp<nuG[phase]; comp++)   // For each state component in phase
                    {
                        if (PathControlDependMapG.mat[phase].mat[constraint].val[comp])    // If path constraint is dependent on control component in phase
                        {
                            partialInd = nxG[phase] + comp; // Set partial index to current control component plus number of state components in phase
                            var = 2;
                            
                            path_func_Grad_HD(phase,constraint,var,comp,parametersStructMat.parametersStruct[phase],sysinfoHDG,parametersStructHDMat.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of path constraint wrt control comp at first point in phase

                            pathGradVals[phase].mat[constraint].mat[pt].val[partialInd] = value.val[0];  // Compute partial of path constraint wrt to control component at first point in phase
                        }
                    }
                    
                    if (PathTimeDependMapG.mat[phase].mat[constraint].val[0])  // If path constraint is dependent on time in phase
                    {
                        partialInd = nxG[phase] + nuG[phase];   // Set partial index to number of control components plus number of state components in phase
                        var = -1;
                        
                        path_func_Grad_HD(phase,constraint,var,-1,parametersStructMat.parametersStruct[phase],sysinfoHDG,parametersStructHDMat.parametersStruct[phase],value,stepeSizeG);   // Evaluate partial of path constraint wrt time at first point in phase

                        pathGradVals[phase].mat[constraint].mat[pt].val[partialInd] = value.val[0];  // Compute partial of path constraint wrt to time in phase
                    }
                    
                    for (comp=0; comp<nsG; comp++)  // For each static parameter
                    {
                        if (PathStaticDependMapG.mat[phase].mat[constraint].val[comp]) // If path constraint is dependent on static parameter comp
                        {
                            partialInd = nxG[phase] + nuG[phase] + 1 + comp;   // Set partial index to current static parameter comp plus number of control components plus number of state components in phase plus 1
                            var = 6;
                            
                            path_func_Grad_HD(phase,constraint,var,comp,parametersStructMat.parametersStruct[phase],sysinfoHDG,parametersStructHDMat.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of path constraint wrt static parameter comp at first point in phase

                            pathGradVals[phase].mat[constraint].mat[pt].val[partialInd] = value.val[0];  // Compute partial of path constraint wrt to static parameter component at first point in phase
                        }
                    }
                }
            }
        }
    }

    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int constraint=0; constraint<ncG[phase]; constraint++) // For each path constraint in problem
        {
            for (pt=0; pt<numSample; pt++)  // For each sample
            {
                for (partialInd=0; partialInd<numPartials[phase]; partialInd++) // For each potential partial of path constraint in phase
                {
                    pathGradNorms[phase].mat[constraint].val[pt] = pathGradNorms[phase].mat[constraint].val[pt] + pathGradVals[phase].mat[constraint].mat[pt].val[partialInd]*pathGradVals[phase].mat[constraint].mat[pt].val[partialInd];    // Sum square of path gradient values
                }
            }
            for (pt=0; pt<numSample; pt++)  // For each sample
            {
                pathGradNorms[phase].mat[constraint].val[pt] = sqrt(pathGradNorms[phase].mat[constraint].val[pt]);  // Take squareroot of some of the path gradient values to get norm
            }
        }
    }

    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int constraint=0; constraint<ncG[phase]; constraint++) // For each path constraint in problem
        {
            for (pt=0; pt<numSample; pt++)  // For each sample
            {
                pathGradMeans.mat[phase].val[constraint] = pathGradMeans.mat[phase].val[constraint] + pathGradNorms[phase].mat[constraint].val[pt];   // Add path gradient norm at sample point to sum
            }
            pathGradMeans.mat[phase].val[constraint] = pathGradMeans.mat[phase].val[constraint]/(double)numSample;  // Divide path gradient norm samples by number of samples to get mean value
        }
    }
    
    for (comp=0; comp<nsG; comp++)  // For each static parameter
    {
        sysinfoG.s[comp] = sysinfoCDG.s[comp];  // Save static parameter value
    }
    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (comp=0; comp<nxG[phase]; comp++)   // For each state component
        {
            sysinfoG.phaseinfo[phase].ptInfo[0].x[comp] = sysinfoCDG.phaseinfo[phase].ptInfo[0].x[comp];    // Save state component at first point in phase
        }
        for (comp=0; comp<nuG[phase]; comp++)   // For each control component
        {
            sysinfoG.phaseinfo[phase].ptInfo[0].u[comp] = sysinfoCDG.phaseinfo[phase].ptInfo[0].u[comp];    // Save control component at first point in phase
        }
        sysinfoG.phaseinfo[phase].ptInfo[0].t = sysinfoCDG.phaseinfo[phase].ptInfo[0].t;    // Save time at first point in phase
    }

    
//    for (phase=0; phase<PG; phase++)
//    {
//        printfMatrix(randomStateVals[phase]);
//        printfMatrix(randomControlVals[phase]);
//        printfMatrix(randomTimeVals[phase]);
//        printf(pathGradVals[phase]);
//    }
//    printfMatrix(randomStaticVals);
    
//    printfMatrix(pathGradMeans);
    
    return pathGradMeans;
}

doubleMat getEventGradientMeans(void)    // Get mean values of event constraint gradients
{
    int phase,comp,pt;
    doubleMat eventGradMeans(nbG+neG);  // Allocate memory for number of event constraints in problem
    doubleMat eventGradNorms[nbG+neG];  // Allocate memory for number of event constraints in problem
    int nlpindz;
    int nd = 0, ne = 0;
    int numSample = 100;
    doubleMatMat randomInitStateVals[PG];
    doubleMatMat randomFinalStateVals[PG];
    doubleMatMat randomInitTimeVals[PG];
    doubleMatMat randomFinalTimeVals[PG];
    doubleMatMat randomIntegralVals[PG];
    doubleMatMat randomStaticVals;
    double LB, UB;
    double randFrac;
    int randNum;
    doubleMatMat eventGradVals[nbG+neG];    // Allocate memory for number of event constraints in problem
    int partialInd;
    int numPartials=0;
    double value;
    int var;
    
//    srand((unsigned int)time(NULL));
    srand((unsigned int)12345);
    
    if (DurationFlagG)  // If duration constraint enforced
    {
        nd = PG;
    }
    if (ContinuityFlagG)  // If continuity constraint enforced
    {
        ne = neG;
    }
    
    if (nbG+neG>0)
    {
        for (phase=0; phase<PG; phase++)    // For each phase in problem
        {
            numPartials = numPartials + 2*nxG[phase] + nqG[phase] + 2;  // Add to sum 2 times the number of state components plus the number of integral components + 2 for phase
        }
        numPartials = numPartials + nsG;    // Add to sum the number of static parameters in problem
        
        for (phase=0; phase<PG; phase++)    // For each phase in problem
        {
            if (nxG[phase]>0) // If one or more state components in phase
            {
                randomInitStateVals[phase]  = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
                randomFinalStateVals[phase] = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
                for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    randomInitStateVals[phase].mat[comp]  = getDoubleMat(numSample);  // Allocate memory for number of sample points
                    randomFinalStateVals[phase].mat[comp] = getDoubleMat(numSample);  // Allocate memory for number of sample points
                    
                    nlpindz = mainNLPIndZ(1,phase,comp,0,1);  // Get index of corresponding state component at initial point in phase
                    LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding state component in phase
                    UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding state component in phase
                    
                    for (pt=0; pt<numSample; pt++)  // For each sample point
                    {
                        randNum     = rand();   // Get random integer value
                        randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                        
                        randomInitStateVals[phase].mat[comp].val[pt] = LB + randFrac*(UB-LB); // Set random value at sample point for state component in phase
                    }
                    
                    nlpindz = mainNLPIndZ(1,phase,comp,NtG[phase],1); // Get index of corresponding state component at final point in phase
                    LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding state component in phase
                    UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding state component in phase
                    
                    for (pt=0; pt<numSample; pt++)  // For each sample point
                    {
                        randNum     = rand();   // Get random integer value
                        randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                        
                        randomFinalStateVals[phase].mat[comp].val[pt] = LB + randFrac*(UB-LB);    // Set random value at sample point for state component in phase
                    }
                }
            }
            
            if (nqG[phase]>0) // If one or more integral components in phase
            {
                randomIntegralVals[phase] = getDoubleMatMat(nqG[phase]);    // Allocate memory for number of integral components in phase
                for (comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                {
                    randomIntegralVals[phase].mat[comp] = getDoubleMat(numSample);    // Allocate memory for number of sample points
                    
                    nlpindz = mainNLPIndZ(3,phase,comp,-1,1); // Get index of corresponding integral component in phase
                    LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding integral component in phase
                    UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding integral component in phase
                    
                    for (pt=0; pt<numSample; pt++)  // For each sample point
                    {
                        randNum     = rand();   // Get random integer value
                        randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                        
                        randomIntegralVals[phase].mat[comp].val[pt] = LB + randFrac*(UB-LB);  // Set random value at sample point for integral component in phase
                    }
                }
            }
            
            randomInitTimeVals[phase]   = getDoubleMatMat(1);   // Allocate memory for time in phase
            randomFinalTimeVals[phase]  = getDoubleMatMat(1);   // Allocate memory for time in phase
            
            randomInitTimeVals[phase].mat[0]  = getDoubleMat(numSample);  // Allocate memory for number of sample points
            randomFinalTimeVals[phase].mat[0] = getDoubleMat(numSample);  // Allocate memory for number of sample points
            
            nlpindz = mainNLPIndZ(4,phase,-1,-1,1);   // Get index of initial time in phase
            LB = nlpigG.zBL[nlpindz];   // Set lower bound for initial time in phase
            UB = nlpigG.zBU[nlpindz];   // Set upper bound for initial time in phase
            
            for (pt=0; pt<numSample; pt++)  // For each sample point
            {
                randNum     = rand();   // Get random integer value
                randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                
                randomInitTimeVals[phase].mat[0].val[pt] = LB + randFrac*(UB-LB); // Set random value at sample point for initial time in phase
            }
            
            nlpindz = mainNLPIndZ(5,phase,-1,-1,1);   // Get index of final time in phase
            LB = nlpigG.zBL[nlpindz];   // Set lower bound for final time in phase
            UB = nlpigG.zBU[nlpindz];   // Set upper bound for final time in phase
            
            for (pt=0; pt<numSample; pt++)  // For each sample point
            {
                randNum     = rand();   // Get random integer value
                randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                
                randomFinalTimeVals[phase].mat[0].val[pt] = LB + randFrac*(UB-LB);    // Set random value at sample point for initial time in phase
            }
        }
        
        if (nsG>0)  // If one or more static parameters in phase
        {
            randomStaticVals = getDoubleMatMat(nsG);    // Allocate memory for number of static parameters
            for (comp=0; comp<nsG; comp++)  // For each static parameter
            {
                randomStaticVals.mat[comp] = getDoubleMat(numSample); // Allocate memory for number of sample points
                
                nlpindz = mainNLPIndZ(6,-1,comp,-1,1);    // Get index of corresponding static parameter
                LB = nlpigG.zBL[nlpindz];   // Set lower bound for corresponding static parameter
                UB = nlpigG.zBU[nlpindz];   // Set upper bound for corresponding static parameter
                
                for (pt=0; pt<numSample; pt++)  // For each sample point
                {
                    randNum     = rand();   // Get random integer value
                    randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
                    
                    randomStaticVals.mat[comp].val[pt] = LB + randFrac*(UB-LB);   // Set random value at sample point for corresponding static parameter
                }
            }
        }
        
        for (int event=0; event<nbG+neG; event++)   // For each event constraint in problem
        {
            eventGradNorms[event] = getDoubleMat(numSample);    // Allocate memory for number of sample points
            eventGradVals[event] = getDoubleMatMat(numSample);  // Allocate memory for number of sample points
            for (pt=0; pt<numSample; pt++)  // For each sample point
            {
                eventGradVals[event].mat[pt] = getDoubleMat(numPartials); // Allocate memory for maximum possible number of partials
            }
        }
        
        for (comp=0; comp<nsG; comp++)  // For each static parameter
        {
            sysinfoCDG.s[comp] = sysinfoG.s[comp];  // Save static parameter value
        }
        for (phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (comp=0; comp<nxG[phase]; comp++)   // For each state component
            {
                sysinfoCDG.phaseinfo[phase].x0[comp] = sysinfoG.phaseinfo[phase].x0[comp]; // Save initial state component in phase
                sysinfoCDG.phaseinfo[phase].xf[comp] = sysinfoG.phaseinfo[phase].xf[comp]; // Save final state component in phase
            }
            for (comp=0; comp<nqG[phase]; comp++)   // For each integral component
            {
                sysinfoCDG.phaseinfo[phase].q[comp] = sysinfoG.phaseinfo[phase].q[comp];    // Save integral component in phase
            }
            sysinfoCDG.phaseinfo[phase].t0 = sysinfoG.phaseinfo[phase].t0;    // Save initial time in phase
            sysinfoCDG.phaseinfo[phase].tf = sysinfoG.phaseinfo[phase].tf;    // Save final time in phase
        }

        for (pt=0; pt<numSample; pt++)    // For each sample point
        {
            for (comp=0; comp<nsG; comp++)  // For each static parameter in problem
            {
                sysinfoG.s[comp] = randomStaticVals.mat[comp].val[pt];  // Set integral comp in phase to random value
                sysinfoHDG.s[comp] = randomStaticVals.mat[comp].val[pt];  // Set integral comp in phase to random value
            }
            
            for (phase=0; phase<PG; phase++)
            {
                for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    sysinfoG.phaseinfo[phase].x0[comp]      = randomInitStateVals[phase].mat[comp].val[pt];   // Set initial state comp in phase to random value
                    sysinfoHDG.phaseinfo[phase].x0[comp]    = randomInitStateVals[phase].mat[comp].val[pt];   // Set initial state comp in phase to random value
                    sysinfoG.phaseinfo[phase].xf[comp]      = randomFinalStateVals[phase].mat[comp].val[pt];  // Set final state comp in phase to random value
                    sysinfoHDG.phaseinfo[phase].xf[comp]    = randomFinalStateVals[phase].mat[comp].val[pt];  // Set final state comp in phase to random value
                }
                
                for (comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                {
                    sysinfoHDG.phaseinfo[phase].q[comp] = randomIntegralVals[phase].mat[comp].val[pt];  // Set integral comp in phase to random value
                }
                
                sysinfoG.phaseinfo[phase].t0    = randomInitTimeVals[phase].mat[0].val[pt];   // Set initial time comp in phase to random value
                sysinfoHDG.phaseinfo[phase].t0  = randomInitTimeVals[phase].mat[0].val[pt];   // Set initial time comp in phase to random value
                sysinfoG.phaseinfo[phase].tf    = randomFinalTimeVals[phase].mat[0].val[pt];  // Set final time comp in phase to random value
                sysinfoHDG.phaseinfo[phase].tf  = randomFinalTimeVals[phase].mat[0].val[pt];  // Set final time comp in phase to random value
            }
            
            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
            {
                endpoint_parameters_func(param,sysinfoG.phaseinfo,sysinfoG.s,endpointparametersG.val);       // Compute endpoint parameter using random values
                endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointparametersHDG.val);   // Compute endpoint parameter using random values
//                endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointparametersHDG.val);   // Compute endpoint parameter using random values

            }
            
            for (int event=0; event<nbG+neG; event++)   // For each event constraint in problem
            {
                partialInd = 0; // Initialize index to first possible partial
                for (phase=0; phase<PG; phase++)    // For each phase in problem
                {
                    for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        if (EventInitStateDependMapG.mat[phase].mat[event+nd].val[comp]) // If event constraint is dependent on initial state component in phase
                        {
                            var = 1;
                            eve_func_Grad_HD(event+nd,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);

                            eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to initial state component in phase
                            
                            partialInd++;   // Increment partial index to next possible partial
                        }
                    }
                    
                    for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        if (EventFinalStateDependMapG.mat[phase].mat[event+nd].val[comp])  // If event constraint is dependent on final state component in phase
                        {
                            var = 2;
                            eve_func_Grad_HD(event+nd,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);

                            eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to final state component in phase
                            
                            partialInd++;   // Increment partial index to next possible partial
                        }
                    }
                    
                    for (comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                    {
                        if (EventIntegralDependMapG.mat[phase].mat[event+nd].val[comp])    // If event constraint is dependent on integral component in phase
                        {
                            var = 3;
                            eve_func_Grad_HD(event+nd,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);
                            
                            eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to integral component in phase
                            
                            partialInd++;   // Increment partial index to next possible partial
                        }
                    }
                    
                    if (EventInitTimeDependMapG.mat[phase].mat[event+nd].val[0])   // If event constraint is dependent on initial time in phase
                    {
                        var = 4;
                        eve_func_Grad_HD(event+nd,phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);

                        eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to initial time in phase
                        
                        partialInd++;   // Increment partial index to next possible partial
                    }
                    
                    if (EventFinalTimeDependMapG.mat[phase].mat[event+nd].val[0])  // If event constraint is dependent on final time in phase
                    {
                        var = 5;
                        eve_func_Grad_HD(event+nd,phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);

                        eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to final time in phase
                        
                        partialInd++;   // Increment partial index to next possible partial
                    }
                }
                
                for (comp=0; comp<nsG; comp++)  // For each static parameter in problem
                {
                    if (EventStaticDependMapG.mat[event+nd].val[comp])   // If event constraint is dependent on static parameter comp in phase
                    {
                        var = 6;
                        eve_func_Grad_HD(event+nd,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);
                        
                        eventGradVals[event].mat[pt].val[partialInd] = value; // Compute partial of event constraint wrt to static parameter comp in phase
                        
                        partialInd++;   // Increment partial index to next possible partial
                    }
                }
                
                for (partialInd=0; partialInd<numPartials; partialInd++)    // For each possible event partial
                {
                    eventGradNorms[event].val[pt] = eventGradNorms[event].val[pt] + eventGradVals[event].mat[pt].val[partialInd]*eventGradVals[event].mat[pt].val[partialInd];  // Add square of event partial value to sum
                }
                eventGradNorms[event].val[pt] = sqrt(eventGradNorms[event].val[pt]);    // Take squareroot of sum to get norm of event gradient
                
                eventGradMeans.val[event] = eventGradMeans.val[event] + eventGradNorms[event].val[pt];  // Add event gradient norm at sample point to sum
            }
        }
        
        for (int event=0; event<nbG+neG; event++)   // For each event constraint
        {
            eventGradMeans.val[event] = eventGradMeans.val[event]/(double)numSample;    // Divide sum of sampled event gradient norms by number of sample points to get mean
        }
        
        for (comp=0; comp<nsG; comp++)  // For each static parameter
        {
            sysinfoCDG.s[comp] = sysinfoG.s[comp];  // Save static parameter value
        }
        for (phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (comp=0; comp<nxG[phase]; comp++)   // For each state component
            {
                sysinfoCDG.phaseinfo[phase].x0[comp] = sysinfoG.phaseinfo[phase].x0[comp]; // Save initial state component in phase
                sysinfoCDG.phaseinfo[phase].xf[comp] = sysinfoG.phaseinfo[phase].xf[comp]; // Save final state component in phase
            }
            for (comp=0; comp<nqG[phase]; comp++)   // For each integral component
            {
                sysinfoCDG.phaseinfo[phase].q[comp] = sysinfoG.phaseinfo[phase].q[comp];    // Save integral component in phase
            }
            sysinfoCDG.phaseinfo[phase].t0 = sysinfoG.phaseinfo[phase].t0;    // Save initial time in phase
            sysinfoCDG.phaseinfo[phase].tf = sysinfoG.phaseinfo[phase].tf;    // Save final time in phase
        }
    }
    
    for (phase=0; phase<PG; phase++)
    {
//        printfMatrix(randomInitStateVals[phase]);
//        printfMatrix(randomFinalStateVals[phase]);
//        printfMatrix(randomInitTimeVals[phase]);
//        printfMatrix(randomFinalTimeVals[phase]);
//        printfMatrix(randomIntegralVals[phase]);
//        printf4MATLAB("eventGradNorms",eventGradNorms[phase]);
    }
//    printfMatrix(randomStaticVals);
    
//    printf4MATLAB("eventGradMeans",eventGradMeans);
    
    return eventGradMeans;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------System Info functions---------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void setSystemInfo(const infoNLPIndZ& NLPIndZ, const Number* Z)
{
    int var,phase,comp,pt;
    
//    printf("\nGetting HERE 1.25");
//    printf("\nGetting HERE 1.25");
//    printf("\nGetting HERE 1.25");
    
    for (int indZ=0; indZ<NLPIndZ.Len; indZ++)
    {
        var     = NLPIndZ.Var[indZ];    // Get variable type of NLP Decision Vector element
        phase   = NLPIndZ.Phase[indZ];  // Get phase of NLP Decision Vector element
        comp    = NLPIndZ.Comp[indZ];   // Get component of NLP Decision Vector element
        pt      = NLPIndZ.Pt[indZ];     // Get point of NLP Decision Vector element
        
        if (var==1)   // If state variable
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].x[comp]    = Z[indZ];
//            sysinfoG.phaseinfo[phase].ptInfo[pt].lam[comp]  = 0;
        }
        else if (var==2)    // If control variable
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].u[comp] = Z[indZ];
        }
        else if (var==3)    // If integral variable
        {
            sysinfoG.phaseinfo[phase].q[comp] = Z[indZ];
        }
        else if (var==4)    // If initial time variable
        {
            sysinfoG.phaseinfo[phase].t0 = Z[indZ];
        }
        else if (var==5)    // If final time variable
        {
            sysinfoG.phaseinfo[phase].tf = Z[indZ];
        }
        else if (var==6)    // If static parameter variable
        {
            sysinfoG.s[comp] = Z[indZ];
        }
    }
    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (pt=0; pt<(NtG[phase]+1); pt++) // For each discretization point in phase
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].t = 0.5*(sysinfoG.phaseinfo[phase].tf-sysinfoG.phaseinfo[phase].t0)*sysinfoG.phaseinfo[phase].ptInfo[pt].tau + 0.5*(sysinfoG.phaseinfo[phase].tf+sysinfoG.phaseinfo[phase].t0);  // Compute time at point pt in phase
        }
        for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            sysinfoG.phaseinfo[phase].x0[comp] = sysinfoG.phaseinfo[phase].ptInfo[0].x[comp];   // Set value of initial state component comp in phase
            sysinfoG.phaseinfo[phase].xf[comp] = sysinfoG.phaseinfo[phase].ptInfo[NtG[phase]].x[comp];  // Set value of final state component comp in phase
        }
    }
}

void setSystemInfo(const infoNLPIndZ& NLPIndZ, const Number* Z, const Number* Costate)
{
    int var,phase,comp,pt;
    
    for (int indZ=0; indZ<NLPIndZ.Len; indZ++)
    {
        var     = NLPIndZ.Var[indZ];    // Get variable type of NLP Decision Vector element
        phase   = NLPIndZ.Phase[indZ];  // Get phase of NLP Decision Vector element
        comp    = NLPIndZ.Comp[indZ];   // Get component of NLP Decision Vector element
        pt      = NLPIndZ.Pt[indZ];     // Get point of NLP Decision Vector element
        
        if (var==1)   // If state variable
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].x[comp] = Z[indZ];
            sysinfoG.phaseinfo[phase].ptInfo[pt].lam[comp] = Costate[indZ];
        }
        else if (var==2)    // If control variable
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].u[comp] = Z[indZ];
        }
        else if (var==3)    // If integral variable
        {
            sysinfoG.phaseinfo[phase].q[comp] = Z[indZ];
        }
        else if (var==4)    // If initial time variable
        {
            sysinfoG.phaseinfo[phase].t0 = Z[indZ];
        }
        else if (var==5)    // If final time variable
        {
            sysinfoG.phaseinfo[phase].tf = Z[indZ];
        }
        else if (var==6)    // If static parameter variable
        {
            sysinfoG.s[comp] = Z[indZ];
        }
    }
    for (phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (pt=0; pt<(NtG[phase]+1); pt++) // For each discretization point in phase
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].t = 0.5*(sysinfoG.phaseinfo[phase].tf-sysinfoG.phaseinfo[phase].t0)*sysinfoG.phaseinfo[phase].ptInfo[pt].tau + 0.5*(sysinfoG.phaseinfo[phase].tf+sysinfoG.phaseinfo[phase].t0);  // Compute time at point pt in phase
        }
        for (comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            sysinfoG.phaseinfo[phase].x0[comp] = sysinfoG.phaseinfo[phase].ptInfo[0].x[comp];   // Set value of initial state component comp in phase
            sysinfoG.phaseinfo[phase].xf[comp] = sysinfoG.phaseinfo[phase].ptInfo[NtG[phase]].x[comp];  // Set value of final state component comp in phase
        }
    }
}

void setSystemInfoConst(void)   // Set sysinfoG size and values of system variables that do not need to be interpolated (s,q,t0,tf,x0,xf,u0,uf)
{
    
//    sysinfosolG = getSystemInfo(sysinfoG);  // Set sysinfosolG to solution sysinfoG
//    printf("\nsysinfosolG = ");
//    printf4MATLAB(sysinfosolG);
    
    int Ninterp[PG];    // Allocate memory for each phase in problem
    
    for (int i=0; i<PG; i++)    // For each phase in problem
    {
        Ninterp[i] = NtG[i] + rpmdG[i].NumInterval; // Set number of collocation point in phase to number on previous mesh plus an additional collocation point for each interval used for phase of previous mesh
    }
    
    sysinfoG = getSystemInfo(PG,nsG,nxG,nuG,nqG,Ninterp);   // Allocate memory for interpolation mesh grid
//    printf("\nsysinfoG = ");
//    printf4MATLAB(sysinfoG);
    
    InitPhaseParameters(Ninterp);   // Allocate memory for new number of grid points
    
    for (int j=0; j<nsG; j++)   // For each static parameter in problem
    {
        sysinfoG.s[j] = sysinfosolG.s[j];   // Extract value of static parameter j from solution sysinfosolG
    }
    
    for (int i=0; i<PG; i++)    // For each phase in problem
    {
        for (int j=0; j<nqG[i]; j++)    // For each integral component in phase i
        {
            sysinfoG.phaseinfo[i].q[j] = sysinfosolG.phaseinfo[i].q[j]; // Extract value of integral component j in phase i from solution sysinfosolG
        }
        for (int j=0; j<nxG[i]; j++)    // For each state component in phase i
        {
            sysinfoG.phaseinfo[i].x0[j] = sysinfosolG.phaseinfo[i].x0[j];   // Extract value of initial state component j in phase i from solution sysinfosolG
            sysinfoG.phaseinfo[i].xf[j] = sysinfosolG.phaseinfo[i].xf[j];   // Extract value of final state component j in phase i from solution sysinfosolG
        }
        sysinfoG.phaseinfo[i].t0 = sysinfosolG.phaseinfo[i].t0; // Extract value of initial time in phase i from solution sysinfosolG
        sysinfoG.phaseinfo[i].tf = sysinfosolG.phaseinfo[i].tf; // Extract value of final time in phase i from solution sysinfosolG
        for (int j=0; j<nxG[i]; j++)
        {
            sysinfoG.phaseinfo[i].ptInfo[0].x[j] = sysinfosolG.phaseinfo[i].ptInfo[0].x[j]; // Extract value of state component j at initial point in phase i from solution sysinfosolG
            sysinfoG.phaseinfo[i].ptInfo[Ninterp[i]].x[j] = sysinfosolG.phaseinfo[i].ptInfo[NtG[i]].x[j];   // Extract value of state component j at final point in phase i from solution sysinfosolG
        }
        for (int j=0; j<nuG[i]; j++)
        {
            sysinfoG.phaseinfo[i].ptInfo[0].u[j] = sysinfosolG.phaseinfo[i].ptInfo[0].u[j]; // Extract value of control component j at initial point in phase i from solution sysinfosolG
            sysinfoG.phaseinfo[i].ptInfo[Ninterp[i]].u[j] = sysinfosolG.phaseinfo[i].ptInfo[NtG[i]].u[j];   // Extract value of control component j at final point in phase i from solution sysinfosolG
        }
        sysinfoG.phaseinfo[i].ptInfo[0].t = sysinfosolG.phaseinfo[i].t0; // Extract time at initial point in phase i from solution sysinfosolG
        sysinfoG.phaseinfo[i].ptInfo[Ninterp[i]].t = sysinfosolG.phaseinfo[i].tf;   // Extract time at final point in phase i from solution sysinfosolG
        sysinfoG.phaseinfo[i].ptInfo[0].tau = -1;   // Set tau at initial point in phase i from solution sysinfosolG
        sysinfoG.phaseinfo[i].ptInfo[Ninterp[i]].tau = 1;   // Set tau at final point in phase i from solution sysinfosolG
    }
    
//    printf("\nsysinfoG = ");
//    printf4MATLAB(sysinfoG);
}

void setSystemInfoConst(systemInfo& sysinfointerp)  // Set sysinfointerp size and values of system variables that do not need to be interpolated (s,q,t0,tf,x0,xf,u0,uf)
{
    
    //    sysinfosolG = getSystemInfo(sysinfoG);  // Set sysinfosolG to solution sysinfoG
    //    printf("\nsysinfosolG = ");
    //    printf4MATLAB(sysinfosolG);
    
    int Ninterp[PG];    // Allocate memory for each phase in problem
    
    for (int i=0; i<PG; i++)    // For each phase in problem
    {
        Ninterp[i] = NtG[i] + rpmdG[i].NumInterval; // Set number of collocation point in phase to number on previous mesh plus an additional collocation point for each interval used for phase of previous mesh
    }
    
    sysinfointerp = getSystemInfo(PG,nsG,nxG,nuG,nqG,Ninterp);  // Allocate memory for interpolation mesh grid
    //    printf("\nsysinfoG = ");
    //    printf4MATLAB(sysinfoG);
    
//    InitPhaseParameters(Ninterp);   // Allocate memory for new number of grid points
    
    for (int j=0; j<nsG; j++)   // For each static parameter in problem
    {
        sysinfointerp.s[j] = sysinfosolG.s[j];  // Extract value of static parameter j from solution sysinfosolG
    }
    
    for (int i=0; i<PG; i++)    // For each phase in problem
    {
        for (int j=0; j<nqG[i]; j++)    // For each integral component in phase i
        {
            sysinfointerp.phaseinfo[i].q[j] = sysinfosolG.phaseinfo[i].q[j]; // Extract value of integral component j in phase i from solution sysinfosolG
        }
        for (int j=0; j<nxG[i]; j++)    // For each state component in phase i
        {
            sysinfointerp.phaseinfo[i].x0[j] = sysinfosolG.phaseinfo[i].x0[j];   // Extract value of initial state component j in phase i from solution sysinfosolG
            sysinfointerp.phaseinfo[i].xf[j] = sysinfosolG.phaseinfo[i].xf[j];   // Extract value of final state component j in phase i from solution sysinfosolG
        }
        sysinfointerp.phaseinfo[i].t0 = sysinfosolG.phaseinfo[i].t0; // Extract value of initial time in phase i from solution sysinfosolG
        sysinfointerp.phaseinfo[i].tf = sysinfosolG.phaseinfo[i].tf; // Extract value of final time in phase i from solution sysinfosolG
        for (int j=0; j<nxG[i]; j++)
        {
            sysinfointerp.phaseinfo[i].ptInfo[0].x[j] = sysinfosolG.phaseinfo[i].ptInfo[0].x[j]; // Extract value of state component j at initial point in phase i from solution sysinfosolG
            sysinfointerp.phaseinfo[i].ptInfo[Ninterp[i]].x[j] = sysinfosolG.phaseinfo[i].ptInfo[NtG[i]].x[j];   // Extract value of state component j at final point in phase i from solution sysinfosolG
        }
        for (int j=0; j<nuG[i]; j++)
        {
            sysinfointerp.phaseinfo[i].ptInfo[0].u[j] = sysinfosolG.phaseinfo[i].ptInfo[0].u[j]; // Extract value of control component j at initial point in phase i from solution sysinfosolG
            sysinfointerp.phaseinfo[i].ptInfo[Ninterp[i]].u[j] = sysinfosolG.phaseinfo[i].ptInfo[NtG[i]].u[j];   // Extract value of control component j at final point in phase i from solution sysinfosolG
        }
        sysinfointerp.phaseinfo[i].ptInfo[0].t = sysinfosolG.phaseinfo[i].t0; // Extract time at initial point in phase i from solution sysinfosolG
        sysinfointerp.phaseinfo[i].ptInfo[Ninterp[i]].t = sysinfosolG.phaseinfo[i].tf;   // Extract time at final point in phase i from solution sysinfosolG
        sysinfointerp.phaseinfo[i].ptInfo[0].tau = -1;   // Set tau at initial point in phase i from solution sysinfosolG
        sysinfointerp.phaseinfo[i].ptInfo[Ninterp[i]].tau = 1;   // Set tau at final point in phase i from solution sysinfosolG
    }
    
    //    printf("\nsysinfoG = ");
    //    printf4MATLAB(sysinfoG);
}

void setSystemInfoPhase(int phase, phaseData& interpData) // Set sysinfoG.phaseinfo values using interpolated values for phase (interior points for x, u, and t)
{
    for (int pt=1; pt<interpData.NumColPts; pt++)   // For each interior collocation point in phase
    {
        for (int comp=0; comp<interpData.NumX; comp++)  // For each state component in phase
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].x[comp] = interpData.x[comp].val[pt];  // Extract interpolated value of state at point
        }
        for (int comp=0; comp<interpData.NumU; comp++)  // For each control component in phase
        {
            sysinfoG.phaseinfo[phase].ptInfo[pt].u[comp] = interpData.u[comp].val[pt];  // Extract interpolated value of control at point
        }
        sysinfoG.phaseinfo[phase].ptInfo[pt].t = interpData.t[pt];  // Extract interpolated value of time at point
        sysinfoG.phaseinfo[phase].ptInfo[pt].tau = interpData.tau[pt];  // Extract interpolated value of tau at point
    }
}

void setSystemInfoPhase(int phase, phaseData& interpData, systemInfo& sysinfointerp)    // Set sysinfointerp.phaseinfo values using interpolated values for phase (interior points for x, u, and t)
{
    for (int pt=1; pt<interpData.NumColPts; pt++)   // For each interior collocation point in phase
    {
        for (int comp=0; comp<interpData.NumX; comp++)  // For each state component in phase
        {
            sysinfointerp.phaseinfo[phase].ptInfo[pt].x[comp] = interpData.x[comp].val[pt]; // Extract interpolated value of state at point
        }
        for (int comp=0; comp<interpData.NumU; comp++)  // For each control component in phase
        {
            sysinfointerp.phaseinfo[phase].ptInfo[pt].u[comp] = interpData.u[comp].val[pt]; // Extract interpolated value of control at point
        }
        sysinfointerp.phaseinfo[phase].ptInfo[pt].t = interpData.t[pt];     // Extract interpolated value of time at point
        sysinfointerp.phaseinfo[phase].ptInfo[pt].tau = interpData.tau[pt]; // Extract interpolated value of tau at point
    }
}

void setSystemInfoBC(void)  // Set sysinfoBCG values using sysinfoG
{
    for (int j=0; j<sysinfoBCG.NumS; j++)   // For each static parameter in problem
    {
        sysinfoBCG.s[j] = sysinfoG.s[j];    // Extract static parameter value j
    }
    for (int i=0; i<sysinfoBCG.NumP; i++)   // For each phase of problem
    {
        sysinfoBCG.phaseinfo[i].t0 = sysinfoG.phaseinfo[i].t0;    // Extract initial time value for phase i
        sysinfoBCG.phaseinfo[i].tf = sysinfoG.phaseinfo[i].tf;    // Extract initial time value for phase i
        for (int j=0; j<sysinfoBCG.phaseinfo[i].NumQ; j++)    // For each integral component in phase i
        {
            sysinfoBCG.phaseinfo[i].q[j] = sysinfoG.phaseinfo[i].q[j];    // Extract integral component value j for phase i
        }
        for (int j=0; j<sysinfoBCG.phaseinfo[i].NumX; j++)    // For each state component in phase i
        {
            sysinfoBCG.phaseinfo[i].x0[j] = sysinfoG.phaseinfo[i].x0[j];  // Extract initial state component value j for phase i
            sysinfoBCG.phaseinfo[i].xf[j] = sysinfoG.phaseinfo[i].xf[j];  // Extract final state component value j for phase i
        }
        for (int k=0; k<sysinfoBCG.phaseinfo[i].NumPts; k++)  // For each discretization point in phase i
        {
            for (int j=0; j<sysinfoBCG.phaseinfo[i].NumX; j++)    // For each state component in phase i
            {
                sysinfoBCG.phaseinfo[i].ptInfo[k].x[j] = sysinfoG.phaseinfo[i].ptInfo[k].x[j];  // Extract state component j value at discretization point k in phase i
            }
            for (int j=0; j<sysinfoBCG.phaseinfo[i].NumU; j++)    // For each control component in phase i
            {
                sysinfoBCG.phaseinfo[i].ptInfo[k].u[j] = sysinfoG.phaseinfo[i].ptInfo[k].u[j];  // Extract control component j value at discretization point k in phase i
            }
            sysinfoBCG.phaseinfo[i].ptInfo[k].t = sysinfoG.phaseinfo[i].ptInfo[k].t;    // Extract time at point k in phase i
        }
    }
}

void setSystemInfoHD(void)  // Set sysinfoHDG values using sysinfoG
{
    for (int j=0; j<sysinfoHDG.NumS; j++)   // For each static parameter in problem
    {
        sysinfoHDG.s[j] = sysinfoG.s[j];    // Extract static parameter value j
    }
    for (int i=0; i<sysinfoHDG.NumP; i++)   // For each phase of problem
    {
        sysinfoHDG.phaseinfo[i].t0 = sysinfoG.phaseinfo[i].t0;    // Extract initial time value for phase i
        sysinfoHDG.phaseinfo[i].tf = sysinfoG.phaseinfo[i].tf;    // Extract initial time value for phase i
        for (int j=0; j<sysinfoHDG.phaseinfo[i].NumQ; j++)    // For each integral component in phase i
        {
            sysinfoHDG.phaseinfo[i].q[j] = sysinfoG.phaseinfo[i].q[j];    // Extract integral component value j for phase i
        }
        for (int j=0; j<sysinfoHDG.phaseinfo[i].NumX; j++)    // For each state component in phase i
        {
            sysinfoHDG.phaseinfo[i].x0[j] = sysinfoG.phaseinfo[i].x0[j];  // Extract initial state component value j for phase i
            sysinfoHDG.phaseinfo[i].xf[j] = sysinfoG.phaseinfo[i].xf[j];  // Extract final state component value j for phase i
        }
        for (int k=0; k<sysinfoHDG.phaseinfo[i].NumPts; k++)  // For each discretization point in phase i
        {
            for (int j=0; j<sysinfoHDG.phaseinfo[i].NumX; j++)    // For each state component in phase i
            {
                sysinfoHDG.phaseinfo[i].ptInfo[k].x[j] = sysinfoG.phaseinfo[i].ptInfo[k].x[j];  // Extract state component j value at discretization point k in phase i
            }
            for (int j=0; j<sysinfoHDG.phaseinfo[i].NumU; j++)    // For each control component in phase i
            {
                sysinfoHDG.phaseinfo[i].ptInfo[k].u[j] = sysinfoG.phaseinfo[i].ptInfo[k].u[j];  // Extract control component j value at discretization point k in phase i
            }
            sysinfoHDG.phaseinfo[i].ptInfo[k].t = sysinfoG.phaseinfo[i].ptInfo[k].t;    // Extract time at point k in phase i
        }
    }
}

void setSystemInfoCD(void)  // Set sysinfoCDG values using sysinfoG
{
    for (int j=0; j<sysinfoCDG.NumS; j++)   // For each static parameter in problem
    {
        sysinfoCDG.s[j] = sysinfoG.s[j];    // Extract static parameter value j
    }
    for (int i=0; i<sysinfoCDG.NumP; i++)   // For each phase of problem
    {
        sysinfoCDG.phaseinfo[i].t0 = sysinfoG.phaseinfo[i].t0;    // Extract initial time value for phase i
        sysinfoCDG.phaseinfo[i].tf = sysinfoG.phaseinfo[i].tf;    // Extract initial time value for phase i
        for (int j=0; j<sysinfoCDG.phaseinfo[i].NumQ; j++)    // For each integral component in phase i
        {
            sysinfoCDG.phaseinfo[i].q[j] = sysinfoG.phaseinfo[i].q[j];    // Extract integral component value j for phase i
        }
        for (int j=0; j<sysinfoCDG.phaseinfo[i].NumX; j++)    // For each state component in phase i
        {
            sysinfoCDG.phaseinfo[i].x0[j] = sysinfoG.phaseinfo[i].x0[j];    // Extract initial state component value j for phase i
            sysinfoCDG.phaseinfo[i].xf[j] = sysinfoG.phaseinfo[i].xf[j];    // Extract final state component value j for phase i
        }
        for (int k=0; k<sysinfoCDG.phaseinfo[i].NumPts; k++)  // For each discretization point in phase i
        {
            for (int j=0; j<sysinfoCDG.phaseinfo[i].NumX; j++)    // For each state component in phase i
            {
                sysinfoCDG.phaseinfo[i].ptInfo[k].x[j] = sysinfoG.phaseinfo[i].ptInfo[k].x[j];  // Extract state component j value at discretization point k in phase i
            }
            for (int j=0; j<sysinfoCDG.phaseinfo[i].NumU; j++)    // For each control component in phase i
            {
                sysinfoCDG.phaseinfo[i].ptInfo[k].u[j] = sysinfoG.phaseinfo[i].ptInfo[k].u[j];  // Extract control component j value at discretization point k in phase i
            }
            sysinfoCDG.phaseinfo[i].ptInfo[k].t = sysinfoG.phaseinfo[i].ptInfo[k].t;    // Extract time at point k in phase i
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------Derivative Sparsity Maps-------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void viewGradPat(void)
{
    int kmod;
    
    printf("\n");
    printf("\nNLP Objective Gradient Sparsity Pattern:");
    printf("\n------------------------------------------------------------");
    printf("\n  ");
    for (int k=0; k<LenZG; k++)
    {
        kmod = k+1;
        while (kmod>=10)
        {
            kmod = kmod - 10;
        }
        printf("%d ",kmod);
    }
    printf("\n1 ");
    for (int k=0; k<LenZG; k++)
    {
        if (infonlpG.NLPGrad.Stat[k])
        {
            printf("<>");
        }
        else
        {
            printf("__");
        }
    }
    printf(" 1");
    printf("\n  ");
    for (int k=0; k<LenZG; k++)
    {
        kmod = k+1;
        while (kmod>=10)
        {
            kmod = kmod - 10;
        }
        printf("%d ",kmod);
    }
    printf("\n");
}

void viewJacPat(void)
{
    int i,j,k;
    int kmod;
    int imod;
    int JacPat[LenHG*LenZG];
    
    for (i=0; i<LenHG; i++)
    {
        for (j=0; j<LenZG; j++)
        {
            JacPat[i*LenZG+j] = 0;
        }
    }
    for (k=0; k<infonlpG.NLPJac.Len; k++)
    {
        i = infonlpG.NLPJac.Row[k];
        j = infonlpG.NLPJac.Col[k];
        JacPat[i*LenZG+j] = 1;
    }
    printf("\n");
    printf("\nNLP Constraints Jacobian Sparsity Pattern:");
    printf("\n------------------------------------------------------------");
    
    for (i=0; i<LenHG; i++)
    {
        if (i==0)
        {
            printf("\n  ");
            for (k=0; k<LenZG; k++)
            {
                kmod = k+1;
                while (kmod>=10)
                {
                    kmod = kmod - 10;
                }
                printf("%d ",kmod);
            }
        }
        printf("\n");
        imod = i+1;
        while (imod>=10)
        {
            imod = imod - 10;
        }
        printf("%d ",imod);
        for (j=0; j<LenZG; j++)
        {
            if (JacPat[i*LenZG+j])
            {
                printf("<>");
            }
            else
            {
                printf("__");
            }
        }
        printf(" %d",imod);
    }
    printf("\n  ");
    for (k=0; k<LenZG; k++)
    {
        kmod = k+1;
        while (kmod>=10)
        {
            kmod = kmod - 10;
        }
        printf("%d ",kmod);
    }
    printf("\n");
}

void viewHessPat(void)
{
    int i,j,k;
    int kmod;
    int imod;
    int HessPat[LenZG*LenZG];
    
    for (i=0; i<LenZG; i++)
    {
        for (j=0; j<LenZG; j++)
        {
            HessPat[i*LenZG+j] = 0;
        }
    }
    for (k=0; k<infonlpG.NLPHess.Len; k++)
    {
        i = infonlpG.NLPHess.Row[k];
        j = infonlpG.NLPHess.Col[k];
        HessPat[i*LenZG+j] = 1;
        HessPat[j*LenZG+i] = 1;
    }
    printf("\n");
    printf("\nNLP Lagrangian Hessian Sparsity Pattern:");
    printf("\n------------------------------------------------------------");
    
    for (i=0; i<LenZG; i++)
    {
        if (i==0)
        {
            printf("\n  ");
            for (k=0; k<LenZG; k++)
            {
                kmod = k+1;
                while (kmod>=10)
                {
                    kmod = kmod - 10;
                }
                printf("%d ",kmod);
            }
        }
        
        imod = i+1;
        while (imod>=10)
        {
            imod = imod - 10;
        }
        printf("\n");
        printf("%d ",imod);
        for (j=0; j<LenZG; j++)
        {
            if (HessPat[i*LenZG+j])
            {
                printf("<>");
            }
            else
            {
                printf("__");
            }
        }
        printf(" %d",imod);
    }
    printf("\n  ");
    for (k=0; k<LenZG; k++)
    {
        kmod = k+1;
        while (kmod>=10)
        {
            kmod = kmod - 10;
        }
        printf("%d ",kmod);
    }
    printf("\n");
}

//void refineSparsePat(int LavrentievConstraintFlag)
void refineSparsePat(void)
{
    int LavrentievConstraintFlag = LavrentievConstraintFlagG;
//int status;             // Placeholder for result of evaluating NLP Objective Gradient, Constraints Vector, Constraints Jacobian, and Lagrangian Hessian
    Number Z[LenZG];        // Placeholder for values of NLP Decision Vector
    Number Lambda[LenHG];   // Placeholder for values of Lagrange Multipliers of NLP Constraints Vector
    
    double perturbVal=1e-1; // Perturbation value to prevent zero cancellations in nonzero partial evaluations
    
    double randFrac;
    int randNum;
    
    srand((unsigned int)654321);
    
    // Set global NLP Decision Vector class using provided initial guess values
    for (int i=0; i<LenZG; i++) // For each variable in NLP Decision Vector
    {
        Z[i] = nlpigG.z[i]; // Extract value of NLP Decision Vector variable
        if (Z[i]==0)
        {
            randNum     = rand();   // Get random integer value
            randFrac    = (double)randNum/(double)RAND_MAX; // Divide random integer value by maximum integer possible
            Z[i] = perturbVal*randFrac;
//            Z[i] = perturbVal*1;
        }
    }
    
//    if (scaledG)    // If scaling used
//    {
//        nlpdvG = getNLPDV(LenZG,Z,2,nlpsG); // Set values of scaled and unscaled values of NLP Decision Vector (using unscaled values)
//    }
//    else
//    {
//        nlpdvG = getNLPDV(LenZG,Z,0,nlpsG); // Set values unscaled values of NLP Decision Vector (using unscaled values, scaled initialized to zero)
//    }
    nlpdvG = getNLPDV(LenZG,Z,0,nlpsG); // Set values unscaled values of NLP Decision Vector (using unscaled values, scaled initialized to zero)
//    printf4MATLAB(nlpdvG);
    
    // Set global NLP Lagrange Multipliers class using nonzero initial values
    for (int i=0; i<LenHG; i++) // For each constraint in NLP Constraints Vector
    {
        Lambda[i] = 0.001;    // Initialize Lagrange Multiplier to 1e-3
    }
//    if (scaledG)    // If scaling used
//    {
//        nlplmG = getNLPLM(LenZG,LenHG,Lambda,2,nlpsG);  // Set values of scaled and unscaled values of Lagrange Multipliers of NLP Constraints Vector (using unscaled values)
//    }
//    else
//    {
//        nlplmG = getNLPLM(LenZG,LenHG,Lambda,0,nlpsG);  // Set values unscaled values of Lagrange Multipliers of NLP Constraints Vector (using unscaled values, scaled initialized to zero)
//    }
    nlplmG = getNLPLM(LenZG,LenHG,Lambda,0,nlpsG);  // Set values unscaled values of Lagrange Multipliers of NLP Constraints Vector (using unscaled values, scaled initialized to zero)

    getCostate(1);   // Extract costates of original continuous time optimal control problem using Lagrange Multipliers and LGR weights
    
//    printf4MATLAB(nlplmG);
    
    // Set global systemInfo class using unscaled NLP Decision Vector and Costate values
    sysinfoG = getSystemInfo(PG,nsG,nxG,nuG,nqG,NtG,rpmdG);


    setSystemInfo(infonlpG.NLPIndZ,nlpdvG.UnscaledZ,nlplmG.Costate);
//    printf(sysinfoG);
//    printf4MATLAB(sysinfoG);
//
    // Initialize global systemInfoHD class
    sysinfoHDG = getSystemInfoHD(PG,nsG,nxG,nuG,nqG,NtG);
    // Set global systemInfoHD class using global sysinfoG variable
    setSystemInfoHD();
//    printf(sysinfoHDG);
    
    // Initialize global systemInfoCD class
    sysinfoCDG = sysinfoG;
    // Set global systemInfoCD class using global sysinfoG variable
    setSystemInfoCD();
    
//    if (derivativeSupplierG==0)
//    {
//        //
//    }
    if (derivativeSupplierG==1)
    {
        // Initialize global systemInfoBC class
        sysinfoBCG = getSystemInfoBC(PG,nsG,nxG,nuG,nqG,NtG);
        // Set global systemInfoBC class using global sysinfoG variable
        setSystemInfoBC();
        //    printf(sysinfoBCG);
    }
    

    // Initialize any phase parameters used in computations
    InitPhaseParameters(NtG);
    
    InitEndpointParameters();
    
    ComputeParameters(sysinfoG,phaseparametersG,endpointparametersG);

//    if (derivativeSupplierG==0)
//    {
        SetParametersHD();
//    }
    if (derivativeSupplierG==1)
    {
        SetParametersBC();
    }
    
    // Parameter computations appear to work
//    printf(phaseparametersG);
//    printf(endpointparametersG);

    intMat preStatGrad, preStatJac, preStatHess;

//    printf("\nParameterDependenciesFlagG = %d",ParameterDependenciesFlagG);

    if (ParameterDependenciesFlagG==0)  // If phase and endpoint parameter dependency mappings have not yet been determines
    {
        
        DetermineParameterDependencies();   // Determine dependencies of phase and endpoint parameters wrt to variables and functions
        
        DetermineFunctionMapping(1);        // Determine the mapping for functions used in problem
        
        allocateDerivativeVars();           // Allocate memory for derivative variables using dependency mappings
        
//        printf(DynamicTimeDependMapG);
//        printf(DynamicStateDependMapG);
//        printf(DynamicControlDependMapG);
//        printf(DynamicStaticDependMapG);
//        printf(PathTimeDependMapG);
//        printf(PathStateDependMapG);
//        printf(PathControlDependMapG);
//        printf(PathStaticDependMapG);
//        printf(LagrangeTimeDependMapG);
//        printf(LagrangeStateDependMapG);
//        printf(LagrangeControlDependMapG);
//        printf(LagrangeStaticDependMapG);
//        printf(ObjectiveInitStateDependMapG);
//        printf(ObjectiveFinalStateDependMapG);
//        printf(ObjectiveIntegralDependMapG);
//        printf(ObjectiveInitTimeDependMapG);
//        printf(ObjectiveFinalTimeDependMapG);
//        printf(ObjectiveStaticDependMapG);
//        printf(EventInitStateDependMapG);
//        printf(EventFinalStateDependMapG);
//        printf(EventIntegralDependMapG);
//        printf(EventInitTimeDependMapG);
//        printf(EventFinalTimeDependMapG);
//        printf(EventStaticDependMapG);
    }
    if ((MeshIterG==0)||(initDerivativeVarsFlagG==1))   // First mesh iteration
    {
        initDerivativeVarsFlagG = 0;
        initDerivativeVars();   // Initialize structures for derivative values
    }
    else
    {
        reinitDerivativeVars(); // Reinitialize structures for derivative values
    }

    if (LavrentievConstraintFlagG)  // If active removes Lavrentiev constraints for dynamic functions that are not dependent on the control (should use)
    {
        int controlDependFlag;
        for (int phase=0; phase<PG; phase++)
        {
            //        printf(DynamicControlDependMapG.mat[phase]);
            for (int comp=0; comp<nxG[phase]; comp++)
            {
                controlDependFlag = 0;
                for (int comp2=0; comp2<nuG[phase]; comp2++)
                {
                    controlDependFlag = controlDependFlag + DynamicControlDependMapG.mat[phase].mat[comp].val[comp2];
                }
                if (controlDependFlag==0)   // State comp in phase is not dependent on any control
                {
                    LavrentievConstraintCompG.mat[phase].val[comp] = 0;  // Set Lavrentiev constraint to inactive for state comp
                }
            }
        }

        // Update information for transcribed NLP resulting from LGR collocation using defined mesh grid
        getInfoNLPUpdate(LavrentievConstraintFlagG);

        // Get parameterized constructor for NLP Initial Guess Class after update
        nlpigG = getNLPIG(LenZG,LenHG);

        getNLPZInit();
        getNLPLambdaInit();

        //    printf(infonlpG);

        nlplmG = getNLPLM(LenZG,LenHG,Lambda,0,nlpsG);  // Reset values unscaled values of Lagrange Multipliers of NLP Constraints Vector (using unscaled values, scaled initialized to zero) after updating using control dependency information

        getCostate(1);   // Extract costates of original continuous time optimal control problem using Lagrange Multipliers and LGR weights

        //    printf4MATLAB(nlplmG);

        // Get global systemInfo class using unscaled NLP Decision Vector and Costate values
        sysinfoG = getSystemInfo(PG,nsG,nxG,nuG,nqG,NtG,rpmdG);

        setSystemInfo(infonlpG.NLPIndZ,nlpdvG.UnscaledZ,nlplmG.Costate);
        //    printf(sysinfoG);
        //    printf4MATLAB(sysinfoG);

        // Initialize global systemInfoHD class
        sysinfoHDG = getSystemInfoHD(PG,nsG,nxG,nuG,nqG,NtG);
        // Set global systemInfoHD class using global sysinfoG variable
        setSystemInfoHD();
//        printf(sysinfoHDG);

        // Initialize global systemInfoCD class
        sysinfoCDG = sysinfoG;
        
        if (derivativeSupplierG==1)
        {
            // Initialize global systemInfoBC class
            sysinfoBCG = getSystemInfoBC(PG,nsG,nxG,nuG,nqG,NtG);
            // Set global systemInfoBC class using global sysinfoG variable
            setSystemInfoBC();
            //    printf(sysinfoBCG);
        }


    }

    // Parameterized constructor for NLP Scaling Class
    if (userScalarsG)
    {
        getNLPScalars(pathScalarsG,eventScalarsG);
    }
    else
    {
        getNLPScalars();
    }

//    printf(nlpdvG);
//    printf(nlpsG);
//    printf(nlpigG,nlpsG);

    // Evaluate NLP Objective Gradient using current values of NLP Decision Vector
    nlpogG = getNLPOG(LenZG);   // Allocate memory for each variable in NLP Decision Vector

    // Evaluate NLP Constraints Jacobian using current values of NLP Decision Vector
    nlpcjG = getNLPCJ(infonlpG.NLPJac.Len); // Allocate memory for each nonzero in NLP Constraints Jacobian

    // Evaluate NLP Lagrangian Hessian using current values of NLP Decision Vector
    nlplhG = getNLPLH(infonlpG.NLPHess.Len);    // Allocate memory for each nonzero in NLP Lagrangian Hessian lower triangle

    preStatGrad = preRefineGradPat();   // Pre-refine sparsity pattern of NLP Objective Gradient

//    printf4MATLAB("preStatGrad",preStatGrad);
//    infonlpG.NLPGrad = getInfoNLPGrad(LenZG,preStatGrad);
    infonlpG.NLPGrad = getInfoNLPGrad(preStatGrad);
//    viewGradPat();

    preStatJac  = preRefineJacPat();    // Pre-refine sparsity pattern of NLP Constraints Jacobian

    int nnzJac;
    nnzJac = preStatJac.val[nlpcjG.NumJac];
    int rowJac[nnzJac];
    int colJac[nnzJac];
    int indJac=0;

    for (int i=0; i<nlpcjG.NumJac; i++) // For each potentially nonzero partial in Constraints Jacobian
    {
        if (preStatJac.val[i])  // If NLP Constraints Jacobian partial is active
        {
            rowJac[indJac] = infonlpG.NLPJac.Row[i];    // Extract row of Constraints Jacobian for active partial
            colJac[indJac] = infonlpG.NLPJac.Col[i];    // Extract column of Constraints Jacobian for active partial
            indJac         = indJac + 1;                // Increment index by one
        }
        else
        {
            //
        }
    }
//    viewJacPat();
    infonlpG.NLPJac = getInfoNLPJac(nnzJac,rowJac,colJac);
//    viewJacPat();

    int nnzHess;
    int indHess=0;

    preStatHess = preRefineHessPat();   // Pre-refine sparsity pattern of NLP Lagrangian Hessian

    nnzHess = preStatHess.val[nlplhG.NumHess];
    int preRowHess[nnzHess];
    int preColHess[nnzHess];

    for (int i=0; i<nlplhG.NumHess; i++) // For each potentially nonzero partial in Lagrangian Hessian
    {
        if (preStatHess.val[i]) // If NLP Lagrangian Hessian partial is active
        {
            preRowHess[indHess]    = infonlpG.NLPHess.Row[i];  // Extract row of Lagrangian Hessian for active partial
            preColHess[indHess]    = infonlpG.NLPHess.Col[i];  // Extract column of Lagrangian Hessian for active partial
            indHess             = indHess + 1;              // Increment index by one
        }
        else
        {
            //
        }
    }
//    viewHessPat();
    infonlpG.NLPHess = getInfoNLPHess(nnzHess,preRowHess,preColHess);
//    viewHessPat();

    nlpdiG = getNLPDI(nlpdiG.NumGradO,nlpdiG.NumJacO,nlpdiG.NumHessO,infonlpG.NLPGrad.NNZ,infonlpG.NLPJac.Len,infonlpG.NLPHess.Len);
//    printf(nlpdiG);

    nlplhG = getNLPLH(infonlpG.NLPHess.Len);    // Allocate memory for each nonzero in NLP Lagrangian Hessian lower triangle
    
    switch (derivativeSupplierG)
    {
        case 3:
            // Don't further refine Hessian sparsity pattern
            break;
            
        default:
            // Evaluate NLP Lagrangian Hessian using current values of NLP Decision Vector
            //    evalNLPLagHessBC(LavrentievConstraintFlag);
            evalNLPLagHessHD(LavrentievConstraintFlag);
            //    printf4MATLAB(nlplhG);
            
            intMat statHess;
            
            statHess = refineHessPat();
            
            if ((MeshIterG==0)||(CheckSecondDerivativesFlagG==1))
            {
                CheckSecondDerivativesFlagG = 0;
                CheckSecondDerivatives(1);
            }
            else
            {
                // Do nothing
            }
            
            nnzHess = statHess.val[nlplhG.NumHess];
            int rowHess[nnzHess];
            int colHess[nnzHess];
            indHess=0;
            
            //    printf4MATLAB("statHess",statHess);
            
            for (int i=0; i<nlplhG.NumHess; i++) // For each potentially nonzero partial in Lagrangian Hessian
            {
                if (statHess.val[i]) // If NLP Lagrangian Hessian partial is active
                {
                    rowHess[indHess]    = infonlpG.NLPHess.Row[i];  // Extract row of Lagrangian Hessian for active partial
                    colHess[indHess]    = infonlpG.NLPHess.Col[i];  // Extract column of Lagrangian Hessian for active partial
                    indHess             = indHess + 1;              // Increment index by one
                }
                else
                {
                    //
                }
            }
            infonlpG.NLPHess = getInfoNLPHess(nnzHess,rowHess,colHess);
            //    viewHessPat();
            break;
    }


//    nlpdiG = getNLPDI(nlpdiG.NumGradO,nlpdiG.NumJacO,nlpdiG.NumHessO,infonlpG.NLPGrad.NNZ,infonlpG.NLPJac.Len,infonlpG.NLPHess.Len);
    nlpdiG = getNLPDI(nlpdiG.NumGradR,nlpdiG.NumJacR,nlpdiG.NumHessR,infonlpG.NLPGrad.NNZ,infonlpG.NLPJac.Len,infonlpG.NLPHess.Len);
//    printf(nlpdiG);

    // Evaluate NLP Objective Gradient using current values of NLP Decision Vector
//    evalNLPObjGrad();
//    printf4MATLAB(nlpogG);

    // Evaluate NLP Constraints Jacobian using current values of NLP Decision Vector
    nlpcjG = getNLPCJ(infonlpG.NLPJac.Len); // Allocate memory for each nonzero in NLP Constraints Jacobian
//    evalNLPConJacBC(1);
//    printf4MATLAB(nlpcjG);

    // Evaluate NLP Lagrangian Hessian using current values of NLP Decision Vector
    nlplhG = getNLPLH(infonlpG.NLPHess.Len);    // Allocate memory for each nonzero in NLP Lagrangian Hessian lower triangle
//    evalNLPLagHessBC(1);
//    printf4MATLAB(nlplhG);

    // Evaluate NLP Constraints Vector using current values of NLP Decision Vector
    nlpcvG = getNLPCV(LenHG);   // Allocate memory for each variable in NLP Constraints Vector
//    evalNLPConVec();
//    printf4MATLAB(nlpcvG);

    if (scaledG)    // If scaling used
    {
        setNLPDV(nlpigG.z,2);   // Set values of scaled and unscaled values of global NLP Decision Vector class (using scaled values)
    }
    else
    {
        setNLPDV(nlpigG.z,0);   // Set values of scaled and unscaled values of global NLP Decision Vector class (using unscaled values, scaled values left zero)
    }

    setSystemInfo(infonlpG.NLPIndZ,nlpdvG.UnscaledZ,nlplmG.Costate);
    
    ComputeParameters(sysinfoG,phaseparametersG,endpointparametersG);
    
    setSystemInfoHD();
    SetParametersHD();
    setSystemInfoCD();
    SetParametersCD();

    if (derivativeSupplierG==1)
    {
        setSystemInfoBC();
        SetParametersBC();
    }
    
    
//    printf("\nGET HERE");
//    printf("\nGET HERE");
//    printf("\nGET HERE");
    
}

intMat refineJacPat(void)   // Refine sparsity pattern of NLP Constraints Jacobian
{
    
    intMat statJac(nlpcjG.NumJac+1);    // Placeholder for refined NLP Constraints Jacobian partial statuses plus holder for number of nonzero partials in refined NLP Constraints Jacobian (last element)
    int indZ;                       // Placeholder for index in NLP Decision Vector
    int indH;                       // Placeholder for index in NLP Constraints Vector
    int lz,iz,jz,kz;                // Placeholder for NLP Decision Vector info
    int lh,ih,jh,kh;                // Placeholder for NLP Constraints Vector info
    int indZ2;                      // Second placeholder for index in NLP Decision Vector
    int indH2;                      // Second placeholder for index in NLP Constraints Vector
    int lz2,iz2,jz2,kz2;            // Second placeholder for NLP Decision Vector info
    int lh2,ih2,jh2,kh2;            // Second placeholder for NLP Constraints Vector info
    
    // Refine NLP Constraints Jacobian sparsity pattern
    for (int i=0; i<nlpcjG.NumJac; i++) // For each potentially nonzero partial in Constraints Jacobian
    {
        if (statJac.val[i]==0)  // If partial has not been identified as nonzero yet
        {
            if ((bool)nlpcjG.UnscaledJac[i])    // If NLP Constraints Jacobian partial is nonzero
            {
                statJac.val[i]  = 1;            // Set status of partial to active
                statJac.val[nlpcjG.NumJac]  = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                
                // Get Constraints Jacobian partial information
                indH = infonlpG.NLPJac.Row[i];   // Extract constraint index of which partial is being taken for
                indZ = infonlpG.NLPJac.Col[i];   // Extract variable index with which partial of constraint is being taken wrt
                
                // Get constraint information
                lh = infonlpG.NLPIndH.Var[indH];    // Extract type of constraint
                ih = infonlpG.NLPIndH.Phase[indH];  // Extract phase of constraint
                jh = infonlpG.NLPIndH.Comp[indH];   // Extract component of constraint
                kh = infonlpG.NLPIndH.Pt[indH];     // Extract point of constraint
                
                // Get variable information
                lz = infonlpG.NLPIndZ.Var[indZ];    // Extract type of variable
                iz = infonlpG.NLPIndZ.Phase[indZ];  // Extract phase of variable
                jz = infonlpG.NLPIndZ.Comp[indZ];   // Extract component of variable
                kz = infonlpG.NLPIndZ.Pt[indZ];     // Extract point of variable
                
                //                printf("\nlh = %d  |  ih = %d  |  jh = %d  |  kh = %d",lh,ih,jh,kh);
                //                printf("\nlz = %d  |  iz = %d  |  jz = %d  |  kz = %d",lz,iz,jz,kz);
                //                printf("\nnlpcjG.UnscaledJac[%d] = %.25f",i,nlpcjG.UnscaledJac[i]);
                
                if ((lh==7)&&(lz==1))   // If defect constraint and state variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    
                    if (ih==iz) // If in same phase
                    {
                        if (jh!=jz) // If not the same state component
                        {
                            //printf("\njh = %d  |  jz = %d",jh,jz);
                            
                            for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                            {
                                if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                                {
                                    // Get Constraints Jacobian partial information
                                    indH2 = infonlpG.NLPJac.Row[j]; // Extract constraint index of which partial is being taken for
                                    indZ2 = infonlpG.NLPJac.Col[j]; // Extract variable index with which partial of constraint is being taken wrt
                                    
                                    // Get constraint information
                                    lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                    ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                    jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                    kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                    
                                    // Get variable information
                                    lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                    iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                    jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                    kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                    
                                    if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                    {
                                        if ((ih==ih2)&&(iz==iz2))   // If phases match
                                        {
                                            if ((jh==jh2)&&(jz==jz2))   // If components match
                                            {
                                                if (kh2==kz2)   // If constraint and variable at same point
                                                {
                                                    statJac.val[j]  = 1;            // Set status of partial to active
                                                    statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==7)&&(lz==2))  // If defect constraint and control variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            if (kh2==kz2)   // If constraint and variable at same point
                                            {
                                                statJac.val[j]  = 1;            // Set status of partial to active
                                                statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==7)&&(lz==6))  // If defect constraint and static variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    //printf("\njh = %d  |  jz = %d",jh,jz);
                    
                    for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                    {
                        if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                        {
                            // Get Constraints Jacobian partial information
                            indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                            indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                            
                            // Get constraint information
                            lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                            ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                            jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                            kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                            
                            // Get variable information
                            lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                            iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                            jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                            kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                            
                            if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                            {
                                if ((ih==ih2)&&(iz==iz2))   // If phases match
                                {
                                    if ((jh==jh2)&&(jz==jz2))   // If components match
                                    {
                                        statJac.val[j]  = 1;            // Set status of partial to active
                                        statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==8)&&(lz==1))  // If path constraint and state variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            if (kh2==kz2)   // If constraint and variable at same point
                                            {
                                                statJac.val[j]  = 1;            // Set status of partial to active
                                                statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==8)&&(lz==2))  // If path constraint and control variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            if (kh2==kz2)   // If constraint and variable at same point
                                            {
                                                statJac.val[j]  = 1;            // Set status of partial to active
                                                statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==8)&&(lz==4))  // If path constraint and initial variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            statJac.val[j]  = 1;            // Set status of partial to active
                                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==8)&&(lz==5))  // If path constraint and final variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            statJac.val[j]  = 1;            // Set status of partial to active
                                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==8)&&(lz==6))  // If path constraint and static variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            statJac.val[j]  = 1;            // Set status of partial to active
                                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==9)&&(lz==1))  // If approximation constraint and state variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            statJac.val[j]  = 1;            // Set status of partial to active
                                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lh==9)&&(lz==2))  // If approximation constraint and control variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        
                        for (int j=0; j<nlpcjG.NumJac; j++) // For each potentially nonzero partial in Constraints Jacobian
                        {
                            if (statJac.val[j]==0)  // If partial has not been identified as nonzero yet
                            {
                                // Get Constraints Jacobian partial information
                                indH2   = infonlpG.NLPJac.Row[j];   // Extract constraint index of which partial is being taken for
                                indZ2   = infonlpG.NLPJac.Col[j];   // Extract variable index with which partial of constraint is being taken wrt
                                
                                // Get constraint information
                                lh2 = infonlpG.NLPIndH.Var[indH2];      // Extract type of constraint
                                ih2 = infonlpG.NLPIndH.Phase[indH2];    // Extract phase of constraint
                                jh2 = infonlpG.NLPIndH.Comp[indH2];     // Extract component of constraint
                                kh2 = infonlpG.NLPIndH.Pt[indH2];       // Extract point of constraint
                                
                                // Get variable information
                                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                                
                                if ((lh==lh2)&&(lz==lz2))   // If constraints and variables match
                                {
                                    if ((ih==ih2)&&(iz==iz2))   // If phases match
                                    {
                                        if ((jh==jh2)&&(jz==jz2))   // If components match
                                        {
                                            statJac.val[j]  = 1;            // Set status of partial to active
                                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                // Get Constraints Jacobian partial information
                indH    = infonlpG.NLPJac.Row[i];   // Extract constraint index of which partial is being taken for
                indZ    = infonlpG.NLPJac.Col[i];   // Extract variable index with which partial of constraint is being taken wrt
                
                // Get constraint information
                lh  = infonlpG.NLPIndH.Var[indH];   // Extract type of constraint
                ih  = infonlpG.NLPIndH.Phase[indH]; // Extract phase of constraint
                jh  = infonlpG.NLPIndH.Comp[indH];  // Extract component of constraint
                kh  = infonlpG.NLPIndH.Pt[indH];    // Extract point of constraint
                
                // Get variable information
                lz  = infonlpG.NLPIndZ.Var[indZ];   // Extract type of variable
                iz  = infonlpG.NLPIndZ.Phase[indZ]; // Extract phase of variable
                jz  = infonlpG.NLPIndZ.Comp[indZ];  // Extract component of variable
                kz  = infonlpG.NLPIndZ.Pt[indZ];    // Extract point of variable
                
                if ((lh==7)&&(lz==4))   // If defect constraint and initial time variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        statJac.val[i]  = 1;            // Set status of partial to active
                        statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                    }
                }
                else if ((lh==7)&&(lz==5))  // If defect constraint and final time variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        statJac.val[i]  = 1;            // Set status of partial to active
                        statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                    }
                }
                else if ((lh==9)&&(lz==3))   // If approximation constraint and integral variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        if (jh==jz) // If same componenet
                        {
                            statJac.val[i]  = 1;            // Set status of partial to active
                            statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                        }
                    }
                }
                else if ((lh==9)&&(lz==4))   // If approximation constraint and initial time variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        statJac.val[i]  = 1;            // Set status of partial to active
                        statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                    }
                }
                else if ((lh==9)&&(lz==5))  // If approximation constraint and final time variable
                {
                    //printf("\nlh = %d  |  lz = %d",lh,lz);
                    if (ih==iz) // If in same phase
                    {
                        statJac.val[i]  = 1;            // Set status of partial to active
                        statJac.val[nlpcjG.NumJac]      = statJac.val[nlpcjG.NumJac] + 1;   // Increment number of nonzero partials by one
                    }
                }
                else
                {
                    // Status of partial remains unchanged
                }
                
            }
        }
    }
    
    return statJac;
    
}

intMat refineHessPat(void)  // Refine sparsity pattern of NLP Lagrangian Hessian
{
    intMat statHess(nlplhG.NumHess+1);  // Placeholder for refined NLP Lagrangian Hessian partial statuses and holder for number of nonzero partials in refined NLP Lagrangian Hessian (last element)
    int indZ1;                          // First placeholder for index in NLP Decision Vector
    int lz1,iz1,jz1,kz1;                // Placeholder for NLP Decision Vector info
    int indZ2;                          // Second placeholder for index in NLP Decision Vector
    int lz2,iz2,jz2,kz2;                // Second placeholder for NLP Decision Vector info
    int indZ12;                         // Additional first placeholder for index in NLP Decision Vector
    int indZ22;                         // Additional second placeholder for index in NLP Decision Vector
    int lz12,iz12,jz12,kz12;            // Additional first placeholder for NLP Decision Vector info
    int lz22,iz22,jz22,kz22;            // Additional second placeholder for NLP Decision Vector info
//    double cutOffVal = 1e-32;           // Cut off value for absolute size of nonzero partials
    
    // Refine NLP Lagrangian Hessian sparsity pattern
    for (int i=0; i<nlplhG.NumHess; i++)    // For each potentially nonzero partial in Lagrangian Hessian lower triangle
    {
//        printf4MATLAB("statHess",statHess);
        if (statHess.val[i]==0) // If partial has not been identified as nonzero yet
        {
            if ((bool)nlplhG.UnscaledHess[i])   // If NLP Lagrangian Hessian partial is nonzero
//            if (((bool)nlplhG.UnscaledHess[i])&&(abs(nlplhG.UnscaledHess[i])>cutOffVal))    // If NLP Lagrangian Hessian partial is nonzero and greater than cutOffVal
            {
                statHess.val[i] = 1;            // Set status of partial to active
                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                
                // Get Lagrangian Hessian partial information
                indZ1 = infonlpG.NLPHess.Row[i];    // Extract index of first partial in NLP Decision Vector
                indZ2 = infonlpG.NLPHess.Col[i];    // Extract index of second partial in NLP Decision Vector
                
                // Get variable information of first partial
                lz1 = infonlpG.NLPIndZ.Var[indZ1];      // Extract type of variable
                iz1 = infonlpG.NLPIndZ.Phase[indZ1];    // Extract phase of variable
                jz1 = infonlpG.NLPIndZ.Comp[indZ1];     // Extract component of variable
                kz1 = infonlpG.NLPIndZ.Pt[indZ1];       // Extract point of variable
                
                // Get variable information of second partial
                lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
                iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
                jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
                kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
                
//                printf("\nlz1 = %d  |  iz1 = %d  |  jz1 = %d  |  kz1 = %d",lz1,iz1,jz1,kz1);
//                printf("\nlz2 = %d  |  iz2 = %d  |  jz2 = %d  |  kz2 = %d",lz2,iz2,jz2,kz2);
                
                if ((lz1==1)&&(lz2==1)) // If both partials wrt state variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    
                    if (iz1==iz2)   // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        if (kz1==kz2)   // If at same point
                        {
                            if ((kz1>0)&&(kz1<NtG[iz1]))    // If not initial nor terminal point
                            {
                                for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                                {
                                    if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                                    {
                                        // Get Lagrangian Hessian information
                                        indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                        indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                        // Get variable information of first partial
                                        lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                        iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                        jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                        kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                        // Get variable information of second partial
                                        lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                        iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                        jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                        kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                        if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                        {
                                            if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                            {
                                                if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                                {
                                                    if ((kz12==kz22)&&(kz12<NtG[iz1]))  // If variables at same point and not terminal point
                                                    {
                                                        statHess.val[j] = 1;            // Set status of partial to active
                                                        statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==1)&&(lz2==2))    // If first partial wrt state variable and second partial wrt control variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        if (kz1==kz2)   // If at same point
                        {
                            for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                            {
                                if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                                {
                                    // Get Lagrangian Hessian information
                                    indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                    indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                    // Get variable information of first partial
                                    lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                    iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                    jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                    kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                    // Get variable information of second partial
                                    lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                    iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                    jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                    kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                    if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                    {
                                        if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                        {
                                            if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                            {
                                                if (kz12==kz22) // If variables at same point
                                                {
                                                    statHess.val[j] = 1;            // Set status of partial to active
                                                    statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==2)&&(lz2==1))    // If first partial wrt control variable and second partial wrt state variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        if (kz1==kz2)   // If at same point
                        {
                            for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                            {
                                if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                                {
                                    // Get Lagrangian Hessian information
                                    indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                    indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                    // Get variable information of first partial
                                    lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                    iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                    jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                    kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                    // Get variable information of second partial
                                    lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                    iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                    jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                    kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                    if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                    {
                                        if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                        {
                                            if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                            {
                                                if (kz12==kz22) // If variables at same point
                                                {
                                                    statHess.val[j] = 1;            // Set status of partial to active
                                                    statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==2)&&(lz2==2))    // If both partials wrt control variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        //printf("\njh = %d  |  jz = %d",jh,jz);
                        if (kz1==kz2)   // If at same point
                        {
                            for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                            {
                                if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                                {
                                    // Get Lagrangian Hessian information
                                    indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                    indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                    // Get variable information of first partial
                                    lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                    iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                    jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                    kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                    // Get variable information of second partial
                                    lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                    iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                    jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                    kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                    if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                    {
                                        if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                        {
                                            if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                            {
                                                if (kz12==kz22) // If variables at same point
                                                {
                                                    statHess.val[j] = 1;            // Set status of partial to active
                                                    statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==1)&&(lz2==4))    // If first partial wrt state variable and second partial wrt initial variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz1==jz12)  // If components match
                                        {
                                            if (kz12<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==4)&&(lz2==1))    // If first partial wrt initial variable and second partial wrt state variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz2==jz22)  // If components match
                                        {
                                            if (kz22<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==2)&&(lz2==4))    // If first partial wrt control variable and second partial wrt initial variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz1==jz12)  // If components match
                                        {
                                            if (kz12<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==4)&&(lz2==2))    // If first partial wrt initial variable and second partial wrt control variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz2==jz22)  // If components match
                                        {
                                            if (kz22<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==1)&&(lz2==5))    // If first partial wrt state variable and second partial wrt final variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz1==jz12)  // If components match
                                        {
                                            if (kz12<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==5)&&(lz2==1))    // If first partial wrt final variable and second partial wrt state variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz2==jz22)  // If components match
                                        {
                                            if (kz22<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==2)&&(lz2==5))    // If first partial wrt control variable and second partial wrt final variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz1==jz12)  // If components match
                                        {
                                            if (kz12<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==5)&&(lz2==2))    // If first partial wrt final variable and second partial wrt control variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    if (iz1==iz2)   // If in same phase
                    {
                        for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                        {
                            if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                            {
                                // Get Lagrangian Hessian information
                                indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                                indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                                // Get variable information of first partial
                                lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                                iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                                jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                                kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                                // Get variable information of second partial
                                lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                                iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                                jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                                kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                                if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                                {
                                    if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                    {
                                        if (jz2==jz22)  // If components match
                                        {
                                            if (kz22<NtG[iz1])  // If collocation point
                                            {
                                                statHess.val[j] = 1;            // Set status of partial to active
                                                statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==1)&&(lz2==6))    // If first partial wrt state variable and second partial wrt static variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                    {
                        if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                        {
                            // Get Lagrangian Hessian information
                            indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                            indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                            // Get variable information of first partial
                            lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                            iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                            jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                            kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                            // Get variable information of second partial
                            lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                            iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                            jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                            kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                            if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                            {
                                if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                {
                                    if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                    {
                                        if (kz12<NtG[iz1])  // If collocation point
                                        {
                                            statHess.val[j] = 1;            // Set status of partial to active
                                            statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==6)&&(lz2==1))    // If first partial wrt static variable and second partial wrt state variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                    {
                        if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                        {
                            // Get Lagrangian Hessian information
                            indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                            indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                            // Get variable information of first partial
                            lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                            iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                            jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                            kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                            // Get variable information of second partial
                            lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                            iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                            jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                            kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                            if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                            {
                                if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                {
                                    if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                    {
                                        if (kz22<NtG[iz2])  // If collocation point
                                        {
                                            statHess.val[j] = 1;            // Set status of partial to active
                                            statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==2)&&(lz2==6))    // If first partial wrt control variable and second partial wrt static variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                    {
                        if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                        {
                            // Get Lagrangian Hessian information
                            indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                            indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                            // Get variable information of first partial
                            lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                            iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                            jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                            kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                            // Get variable information of second partial
                            lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                            iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                            jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                            kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                            if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                            {
                                if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                {
                                    if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                    {
                                        if (kz12<NtG[iz1])  // If collocation point
                                        {
                                            statHess.val[j] = 1;            // Set status of partial to active
                                            statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                else if ((lz1==6)&&(lz2==2))    // If first partial wrt static variable and second partial wrt control variable
                {
                    //printf("\nlz1 = %d  |  lz2 = %d",lz1,lz2);
                    for (int j=0; j<nlplhG.NumHess; j++)    // For each potentially nonzero partial in Lagrangian Hessian
                    {
                        if (statHess.val[j]==0) // If partial has not been identified as nonzero yet
                        {
                            // Get Lagrangian Hessian information
                            indZ12 = infonlpG.NLPHess.Row[j];   // Extract index of first partial in NLP Decision Vector
                            indZ22 = infonlpG.NLPHess.Col[j];   // Extract index of second partial in NLP Decision Vector
                           
                            // Get variable information of first partial
                            lz12 = infonlpG.NLPIndZ.Var[indZ12];    // Extract type of variable
                            iz12 = infonlpG.NLPIndZ.Phase[indZ12];  // Extract phase of variable
                            jz12 = infonlpG.NLPIndZ.Comp[indZ12];   // Extract component of variable
                            kz12 = infonlpG.NLPIndZ.Pt[indZ12];     // Extract point of variable
                           
                            // Get variable information of second partial
                            lz22 = infonlpG.NLPIndZ.Var[indZ22];    // Extract type of variable
                            iz22 = infonlpG.NLPIndZ.Phase[indZ22];  // Extract phase of variable
                            jz22 = infonlpG.NLPIndZ.Comp[indZ22];   // Extract component of variable
                            kz22 = infonlpG.NLPIndZ.Pt[indZ22];     // Extract point of variable
                           
                            if ((lz1==lz12)&&(lz2==lz22))   // If both variables match
                            {
                                if ((iz1==iz12)&&(iz2==iz22))   // If phases match
                                {
                                    if ((jz1==jz12)&&(jz2==jz22))   // If components match
                                    {
                                        if (kz22<NtG[iz2])  // If collocation point
                                        {
                                            statHess.val[j] = 1;            // Set status of partial to active
                                            statHess.val[nlplhG.NumHess]     = statHess.val[nlplhG.NumHess] + 1;  // Increment number of nonzero partials by one
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else
            {
                //
            }
        }
    }
    
    return statHess;
}

intMat preRefineGradPat(void)   // Pre-refine sparsity pattern of NLP Objective Gradient
{
    
//    intMat statGrad(LenZG+1);   // Placeholder for refined NLP Objective Gradient partial statuses plus holder for number of nonzero partials in refined NLP Objective Gradient (last element)
    intMat statGrad(LenZG);     // Placeholder for refined NLP Objective Gradient partial statuses
    int nlpindz;                // Placeholder for index in NLP Decision Vector
    int l,i,j,k;                // Placeholder for NLP Decision Vector info
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        i = phase;  // Set phase number to phase
        if (nxG[phase]) // If one or more state components in phase
        {
            l = 1;  // Set variable type to state
            k = 0;  // Set point number to initial
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveInitStateDependMapG.mat[phase].val[comp])   // If objective function is dependent on initial state component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for initial state component comp in phase
                    statGrad.val[nlpindz] = 1;
//                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
            k = NtG[phase]; // Set point number to final
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveFinalStateDependMapG.mat[phase].val[comp])  // If objective function is dependent on final state component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for final state component comp in phase
                    statGrad.val[nlpindz] = 1;
//                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
        
        if (nqG[phase]) // If one or more integral components in phase
        {
            l = 3;  // Set variable type to integral
            k = -1; // Set point number to undefined
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveIntegralDependMapG.mat[phase].val[comp])    // If objective function is dependent on integral component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for integral component comp in phase
                    statGrad.val[nlpindz] = 1;
//                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
        
        l = 4;  // Set variable type to initial time
        k = -1; // Set point number to undefined
        j = -1; // Set component number to undefined
        if (ObjectiveInitTimeDependMapG.mat[phase].val[0])   // If objective function is dependent on initial time in phase
        {
            nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for initial time in phase
            statGrad.val[nlpindz] = 1;
//            statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
        }
        
        l = 5;  // Set variable type to final time
        k = -1; // Set point number to undefined
        j = -1; // Set component number to undefined
        if (ObjectiveFinalTimeDependMapG.mat[phase].val[0])  // If objective function is dependent on final time in phase
        {
            nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for final time in phase
            statGrad.val[nlpindz] = 1;
//            statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
        }
    }
    
    if (nsG)    // If one or more static parameters in phase
    {
        l = 6;  // Set variable type to integral
        i = -1; // Set phase number to undefined
        k = -1; // Set point number to undefined
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            j = comp;   // Set component number to comp
            if (ObjectiveStaticDependMapG.mat[0].val[comp])  // If objective function in phase is dependent on static parameter comp
            {
                nlpindz = mainNLPIndZ(l,i,j,k); // Get NLP Decision Vector index for static parameter comp
                if (statGrad.val[nlpindz])  // If NLP Objective dependency on static parameter comp already flagged
                {
                    // Do nothing
                }
                else    // Static parameter dependency not yet flagged
                {
                    statGrad.val[nlpindz] = 1;
                    //                        statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
    }
    
    return statGrad;
}

intMat preRefineGradPat(int LavrentievConstraintFlag)   // Pre-refine sparsity pattern of NLP Objective Gradient.Input: flag indicating Lavrentiev constraints are being used
{
    
    //    intMat statGrad(LenZG+1);   // Placeholder for refined NLP Objective Gradient partial statuses plus holder for number of nonzero partials in refined NLP Objective Gradient (last element)
    intMat statGrad(LenZG);     // Placeholder for refined NLP Objective Gradient partial statuses
    int nlpindz;                // Placeholder for index in NLP Decision Vector
    int l,i,j,k;                // Placeholder for NLP Decision Vector info
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        i = phase;  // Set phase number to phase
        if (nxG[phase]) // If one or more state components in phase
        {
            l = 1;  // Set variable type to state
            k = 0;  // Set point number to initial
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveInitStateDependMapG.mat[phase].val[comp])   // If objective function is dependent on initial state component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for initial state component comp in phase
                    statGrad.val[nlpindz] = 1;
                    //                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
            k = NtG[phase]; // Set point number to final
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveFinalStateDependMapG.mat[phase].val[comp])  // If objective function is dependent on final state component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for final state component comp in phase
                    statGrad.val[nlpindz] = 1;
                    //                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
        
        if (nqG[phase]) // If one or more integral components in phase
        {
            l = 3;  // Set variable type to integral
            k = -1; // Set point number to undefined
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                j = comp;   // Set component number to comp
                if (ObjectiveIntegralDependMapG.mat[phase].val[comp])    // If objective function is dependent on integral component comp in phase
                {
                    nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for integral component comp in phase
                    statGrad.val[nlpindz] = 1;
                    //                    statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
        
        l = 4;  // Set variable type to initial time
        k = -1; // Set point number to undefined
        j = -1; // Set component number to undefined
        if (ObjectiveInitTimeDependMapG.mat[phase].val[0])   // If objective function is dependent on initial time in phase
        {
            nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for initial time in phase
            statGrad.val[nlpindz] = 1;
            //            statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
        }
        
        l = 5;  // Set variable type to final time
        k = -1; // Set point number to undefined
        j = -1; // Set component number to undefined
        if (ObjectiveFinalTimeDependMapG.mat[phase].val[0])  // If objective function is dependent on final time in phase
        {
            nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for final time in phase
            statGrad.val[nlpindz] = 1;
            //            statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
        }
    }
    
    if (nsG)    // If one or more static parameters in phase
    {
        l = 6;  // Set variable type to integral
        i = -1; // Set phase number to undefined
        k = -1; // Set point number to undefined
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            j = comp;   // Set component number to comp
            if (ObjectiveStaticDependMapG.mat[0].val[comp])  // If objective function in phase is dependent on static parameter comp
            {
                nlpindz = mainNLPIndZ(l,i,j,k,1);   // Get NLP Decision Vector index for static parameter comp
                if (statGrad.val[nlpindz])  // If NLP Objective dependency on static parameter comp already flagged
                {
                    // Do nothing
                }
                else    // Static parameter dependency not yet flagged
                {
                    statGrad.val[nlpindz] = 1;
                    //                        statGrad.val[LenZG] = statGrad.val[LenZG] + 1;
                }
            }
        }
    }
    
    return statGrad;
}

intMat preRefineJacPat(void)    // Pre-refine sparsity pattern of NLP Constraints Jacobian
{
    intMat statJac(nlpcjG.NumJac+1);    // Placeholder for refined NLP Constraints Jacobian partial statuses plus holder for number of nonzero partials in refined NLP Constraints Jacobian (last element)
    int indZ;                       // Placeholder for index in NLP Decision Vector
    int indH;                       // Placeholder for index in NLP Constraints Vector
    int lz,iz,jz,kz;                // Placeholder for NLP Decision Vector info
    int lh,ih,jh,kh;                // Placeholder for NLP Constraints Vector info
    
    // Refine NLP Constraints Jacobian sparsity pattern
    for (int i=0; i<nlpcjG.NumJac; i++) // For each potentially nonzero partial in Constraints Jacobian
    {
        // Get Constraints Jacobian partial information
        indH = infonlpG.NLPJac.Row[i];   // Extract constraint index of which partial is being taken for
        indZ = infonlpG.NLPJac.Col[i];   // Extract variable index with which partial of constraint is being taken wrt
        
        // Get constraint information
        lh = infonlpG.NLPIndH.Var[indH];    // Extract type of constraint
        ih = infonlpG.NLPIndH.Phase[indH];  // Extract phase of constraint
        jh = infonlpG.NLPIndH.Comp[indH];   // Extract component of constraint
        kh = infonlpG.NLPIndH.Pt[indH];     // Extract point of constraint
        
        // Get variable information
        lz = infonlpG.NLPIndZ.Var[indZ];    // Extract type of variable
        iz = infonlpG.NLPIndZ.Phase[indZ];  // Extract phase of variable
        jz = infonlpG.NLPIndZ.Comp[indZ];   // Extract component of variable
        kz = infonlpG.NLPIndZ.Pt[indZ];     // Extract point of variable
        
//        printf("\nlh = %d  |  ih = %d  |  jh = %d  |  kh = %d",lh,ih,jh,kh);
//        printf("\nlz = %d  |  iz = %d  |  jz = %d  |  kz = %d",lz,iz,jz,kz);
        
        switch (lh) // Constraint function type
        {
            case 7: // Defect constraint type
//                if (ih==2)
//                {
//                    printf("\nlh = %d  |  ih = %d  |  jh = %d  |  kh = %d",lh,ih,jh,kh);
//                    printf("\nlz = %d  |  iz = %d  |  jz = %d  |  kz = %d",lz,iz,jz,kz);
//                    printf("\nstatJac.val[%d] = %d",i,statJac.val[i]);
//                }

                switch (lz) // NLP variable type
                {
                    case 1: // State variable type
//                        if (ih==2)
//                        {
//                            printf("\nState variable");
//                            printf("\nDynamicStateDependMapG.mat[%d].mat[%d].val[%d] = %d",ih,jh,jz,DynamicStateDependMapG.mat[ih].mat[jh].val[jz]);
//                        }
                        if (jh==jz) // If defect constraint and state components are same
                        {
                            if (kh==NtG[ih])    // If Lavrentiev constraint
                            {
                                if (kz==kh) // If defect and variable applid at same point
                                {
                                    statJac.val[i] = 1; // Indicate partial is nonzero
                                    statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                                }
                                else
                                {
                                    if (rpmdG[ih].ColPointsInterval[kz]==rpmdG[ih].ColPointsAltInt[kh]) // If defect constraint applied at point kh is in same interval as state component kz alternative interval
                                    {
                                        statJac.val[i] = 1; // Indicate partial is nonzero
                                        statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                                    }
                                }
                            }
                            else
                            {
                                if (rpmdG[ih].ColPointsInterval[kh]==rpmdG[ih].ColPointsInterval[kz])   // If defect constraint applied at point kh is in same interval as state component kz interval
                                {
                                    statJac.val[i] = 1; // Indicate partial is nonzero
                                    statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                                }
                                else if (rpmdG[ih].ColPointsInterval[kh]==rpmdG[ih].ColPointsAltInt[kz])    // If defect constraint applied at point kh is in same interval as state component kz alternative interval
                                {
                                    statJac.val[i] = 1; // Indicate partial is nonzero
                                    statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                                }
                            }
                        }
                        else
                        {
                            if (DynamicStateDependMapG.mat[ih].mat[jh].val[jz])    // If dynamic function jh is dependent on state component jz in phase ih
                            {
                                statJac.val[i] = 1; // Indicate partial is nonzero
                                statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                            }
                        }
                        break;
                        
                    case 2: // Control variable type
//                        if (ih==2)
//                        {
//                            printf("\nControl variable");
//                            printf("\nDynamicControlDependMapG.mat[%d].mat[%d].val[%d] = %d",ih,jh,jz,DynamicControlDependMapG.mat[ih].mat[jh].val[jz]);
//                        }
                        if (DynamicControlDependMapG.mat[ih].mat[jh].val[jz])  // If dynamic function jh is dependent on control component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 4: // Initial time variable type
//                        if (ih==2)
//                        {
//                            printf("\nInitial time variable");
//                        }
                        statJac.val[i] = 1; // Indicate partial is nonzero
                        statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        break;
                        
                    case 5: // Final time variable type
//                        if (ih==2)
//                        {
//                            printf("\nFinal time variable");
//                        }
                        statJac.val[i] = 1; // Indicate partial is nonzero
                        statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        break;
                        
                    case 6: // Static parameter variable type
//                        if (ih==2)
//                        {
//                            printf("\nStatic variable");
//                            printf("\nDynamicStaticDependMapG.mat[%d].mat[%d].val[%d] = %d",ih,jh,jz,DynamicStaticDependMapG.mat[ih].mat[jh].val[jz]);
//                        }
                        if (DynamicStaticDependMapG.mat[ih].mat[jh].val[jz])   // If dynamic function jh in phase ih is dependent on static parameter jz
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    default:    // Unrecognized variable type
                        printf("\nUnrecognized partial for defect constraint being taken wrt variable type %d",lz);
                        break;
                }
//                if (ih==2)
//                {
//                    printf("\nstatJac.val[%d] = %d",i,statJac.val[i]);
//                }
                break;
                
            case 8: // Path constraint type
                switch (lz) // NLP variable type
                {
                    case 1: // State variable type
                        if (PathStateDependMapG.mat[ih].mat[jh].val[jz])   // If path function jh is dependent on state component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 2: // Control variable type
                        if (PathControlDependMapG.mat[ih].mat[jh].val[jz]) // If path function jh is dependent on control component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 4: // Initial time variable type
                        if (PathTimeDependMapG.mat[ih].mat[jh].val[0]) // If path function jh is dependent on time in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 5: // Final time variable type
                        if (PathTimeDependMapG.mat[ih].mat[jh].val[0]) // If path function jh is dependent on time in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 6: // Static parameter variable type
                        if (PathStaticDependMapG.mat[ih].mat[jh].val[jz])  // If path function jh in phase ih is dependent on static parameter jz
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    default:    // Unrecognized variable type
                        printf("\nUnrecognized partial for path constraint being taken wrt variable type %d",lz);
                        break;
                }
                break;
                
            case 9: // Approximation constraint type
                switch (lz) // NLP variable type
                {
                    case 1: // State variable type
                        if (LagrangeStateDependMapG.mat[ih].mat[jh].val[jz])   // If lagrange function jh is dependent on state component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 2: // Control variable type
                        if (LagrangeControlDependMapG.mat[ih].mat[jh].val[jz]) // If lagrange function jh is dependent on control component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 3: // Integral variable type
                        if (jh==jz) // Make sure jh and jz are same component
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 4: // Initial time variable type
                        statJac.val[i] = 1; // Indicate partial is nonzero
                        statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        break;
                        
                    case 5: // Final time variable type
                        statJac.val[i] = 1; // Indicate partial is nonzero
                        statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        break;
                        
                    case 6: // Static parameter variable type
                        if (LagrangeStaticDependMapG.mat[ih].mat[jh].val[jz])  // If lagrange function jh in phase ih is dependent on static parameter jz
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    default:    // Unrecognized variable type
                        printf("\nUnrecognized partial for approximation constraint being taken wrt variable type %d",lz);
                        break;
                }
                break;
                
            case 10:    // Event constraint type
                switch (lz) // NLP variable type
                {
                    case 1: // State variable type
                        if (kz==0)  // If initial point
                        {
                            if (EventInitStateDependMapG.mat[iz].mat[jh].val[jz])  // If event function jh is dependent on initial state component jz in phase iz
                            {
                                statJac.val[i] = 1; // Indicate partial is nonzero
                                statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                            }
                        }
                        else if (kz==NtG[iz])   // If final point
                        {
                            if (EventFinalStateDependMapG.mat[iz].mat[jh].val[jz]) // If event function jh is dependent on final state component jz in phase iz
                            {
                                statJac.val[i] = 1; // Indicate partial is nonzero
                                statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                            }
                        }
                        break;
                        
                    case 3: // Integral variable type
                        if (EventIntegralDependMapG.mat[iz].mat[jh].val[jz])   // If event function jh is dependent on integral component jz in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 4: // Initial time variable type
                        if (EventInitTimeDependMapG.mat[iz].mat[jh].val[0])    // If event function jh is dependent on initial time in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 5: // Final time variable type
                        if (EventFinalTimeDependMapG.mat[iz].mat[jh].val[0])   // If event function jh is dependent on final time in phase ih
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    case 6: // Static parameter variable type
                        if (EventStaticDependMapG.mat[jh].val[jz])   // If event function jh is dependent on static parameter jz
                        {
                            statJac.val[i] = 1; // Indicate partial is nonzero
                            statJac.val[nlpcjG.NumJac] = statJac.val[nlpcjG.NumJac] + 1;    // Increment number of nonzero elements by one
                        }
                        break;
                        
                    default:    // Unrecognized variable type
                        printf("\nUnrecognized partial for approximation constraint being taken wrt variable type %d",lz);
                        break;
                }
                break;
                
            default:
                printf("\nUnrecognized function type %d",lh);
                break;
        }
    }
    
    return statJac;
}


intMat preRefineHessPat(void)   // Pre-refine sparsity pattern of NLP Lagrangian Hessian
{
    
    intMat statHess(nlplhG.NumHess+1);  // Placeholder for refined NLP Lagrangian Hessian partial statuses and holder for number of nonzero partials in refined NLP Lagrangian Hessian (last element)
    int indZ1;                          // First placeholder for index in NLP Decision Vector
    int lz1,iz1,jz1,kz1;                // Placeholder for NLP Decision Vector info
    int indZ2;                          // Second placeholder for index in NLP Decision Vector
    int lz2,iz2,jz2,kz2;                // Second placeholder for NLP Decision Vector info
    int event;                          // Holder for event number
    int comp;                           // Holder for component number
    int phase;                          // Holder for phase number
    int nd = 0, ne = 0;
    
    if (DurationFlagG)  // If duration constraint enforced
    {
        nd = PG;
    }
    if (ContinuityFlagG)  // If continuity constraint enforced
    {
        ne = neG;
    }

    // Refine NLP Lagrangian Hessian sparsity pattern
    for (int i=0; i<nlplhG.NumHess; i++)    // For each potentially nonzero partial in Lagrangian Hessian lower triangle
    {
        // Get Lagrangian Hessian partial information
        indZ1 = infonlpG.NLPHess.Row[i];    // Extract variable index with which first partial is being taken wrt
        indZ2 = infonlpG.NLPHess.Col[i];    // Extract variable index with which second partial is being taken wrt
        
        // Get variable information for first partial
        lz1 = infonlpG.NLPIndZ.Var[indZ1];      // Extract type of variable
        iz1 = infonlpG.NLPIndZ.Phase[indZ1];    // Extract phase of variable
        jz1 = infonlpG.NLPIndZ.Comp[indZ1];     // Extract component of variable
        kz1 = infonlpG.NLPIndZ.Pt[indZ1];       // Extract point of variable
        
        // Get variable information for second partial
        lz2 = infonlpG.NLPIndZ.Var[indZ2];      // Extract type of variable
        iz2 = infonlpG.NLPIndZ.Phase[indZ2];    // Extract phase of variable
        jz2 = infonlpG.NLPIndZ.Comp[indZ2];     // Extract component of variable
        kz2 = infonlpG.NLPIndZ.Pt[indZ2];       // Extract point of variable
        
        switch (lz1)    // First partial variable type
        {
            case 1: // State type
                switch (lz2)    // Second partial variable type
                {
                    case 1: // State type
                        if (iz1==iz2)   // If state variables are in same phase
                        {
                            if ((kz1==0)&&(kz2==0)) // If both variables are at initial point in phase iz1=iz2
                            {
                                if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2]))   // If objective function is dependent on initial state component jz1 and initial state component jz2 in phase iz1==iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on intial state component jz1 and initial state component jz2 in phase iz1==iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))   // If dynamic function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If path function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If lagrange function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                    else    // No event constraints
                                    {
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))   // If dynamic function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If path function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If lagrange function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if ((kz1==0)&&(kz2==NtG[iz2])) // If first variable at initial point and second variable at final point in phase iz1=iz2
                            {
                                if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2]))  // If objective function is dependent on initial state component jz1 and final state component jz2 in phase iz1==iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on initial state component jz1 and final state component jz2 in phase iz1==iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else if ((kz1==NtG[iz1])&&(kz2==0)) // If first variable at final point and second variable at initial point in phase iz1=iz2
                            {
                                if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2]))  // If objective function is dependent on final state component jz1 and initial state component jz2 in phase iz1==iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on final state component jz1 and initial state component jz2 in phase iz1==iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else if ((kz1==NtG[iz1])&&(kz2==NtG[iz2]))  // If first variable at final point and second variable at final point in phase iz1=iz2
                            {
                                if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2])) // If objective function is dependent on final state component jz1 and final state component jz2 in phase iz1==iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on final state component jz1 and final state component jz2 in phase iz1==iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else if (kz1==kz2)  // If both variables at same point kz1=kz2 in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))   // If dynamic function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If path function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If lagrange function comp is a function of state component jz1 and state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        else    // state variables in different phases
                        {
                            if ((kz1==0)&&(kz2==0)) // If both variables are at initial point in phases iz1 and iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on intial state component jz1 and initial state component jz2 in phase iz1==iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if ((kz1==0)&&(kz2==NtG[iz2])) // If first variable at initial point in phase iz1 and second variable at final point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on initial state component jz1 and final state component jz2 in phase iz1==iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if ((kz1==NtG[iz1])&&(kz2==0)) // If first variable at final point in phase iz1 and second variable at initial point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on final state component jz1 and initial state component jz2 in phase iz1==iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if ((kz1==NtG[iz1])&&(kz2==NtG[iz2]))  // If first variable at final point in phase iz1 and second variable at final point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on final state component jz1 and final state component jz2 in phase iz1==iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        if (iz1==iz2)   // If state variable and control variable are in same phase
                        {
                            if (kz1==kz2)  // If both variables at same point kz1=kz2 in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicControlDependMapG.mat[iz2].mat[comp].val[jz2])) // If dynamic function comp is a function of state component jz1 and control component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathControlDependMapG.mat[iz2].mat[comp].val[jz2]))   // If path function comp is a function of state component jz1 and control component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeControlDependMapG.mat[iz2].mat[comp].val[jz2]))   // If lagrange function comp is a function of control component jz1 and state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 3: // Integral type
                        if (iz1==iz2)   // If state variable and integral variable are in same phase iz1=iz2
                        {
                            if (kz1==0) // If state variable at initial point in phases iz1
                            {
                                if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2]))    // If objective function is dependent on initial state component jz1 and integral component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on intial state component jz1 and integral component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2]))   // If objective function is dependent on final state component jz1 and integral component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on final state component jz1 and integral component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                        }
                        else    // state variable and integral variable in different phases
                        {
                            if (kz1==0) // If state variable at initial point in phases iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on intial state component jz1 in phase iz1 and integral component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on final state component jz1 in phase iz1 and integral component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 4: // Initial time type
                        if (iz1==iz2)   // If state variable and initial time variable are in same phase iz1=iz2
                        {
                            if (kz1==0) // If state variable at initial point in phase iz1
                            {
                                if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitTimeDependMapG.mat[iz2].val[0]))  // If objective function is dependent on initial state component jz1 and initial time in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))    // If event function is dependent on intial state component jz1 and initial time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                        
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                    else    // no event constraints
                                    {
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitTimeDependMapG.mat[iz2].val[0])) // If objective function is dependent on final state component jz1 and initial time in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on final state component jz1 and initial time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else    // State variable at interior point in phase iz1
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        else    // state variable and initial time variable in different phases
                        {
                            if (kz1==0) // If state variable at initial point in phase iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))    // If event function is dependent on intial state component jz1 in phase iz1 and initial time in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on final state component jz1 in phase iz1 and initial time in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if (iz1==iz2)   // If state variable and final time variable are in same phase iz1=iz2
                        {
                            if (kz1==0) // If state variable at initial point in phase iz1
                            {
                                if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalTimeDependMapG.mat[iz2].val[0])) // If objective function is dependent on initial state component jz1 and final time in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on intial state component jz1 and final time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                        
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                    else    // no event constraints
                                    {
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalTimeDependMapG.mat[iz2].val[0]))    // If objective function is dependent on final state component jz1 and final time in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on final state component jz1 and final time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else    // State variable at interior point in phase iz1
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])    // If dynamic function comp is a function of state component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz1 and time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])   // If lagrange function comp is a function of state component jz1 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        else    // state variable and final time variable in different phases
                        {
                            if (kz1==0) // If state variable at initial point in phase iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on intial state component jz1 in phase iz1 and final time in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on final state component jz1 in phase iz1 and final time in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        if (kz1==0) // If state variable at initial point in phase iz1
                        {
                            if ((ObjectiveInitStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveStaticDependMapG.mat[0].val[jz2]))  // If objective function is dependent on initial state component jz1 in phase iz1 and static parameter jz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventStaticDependMapG.mat[event].val[jz2]))   // If event function is dependent on intial state component jz1 in phase iz1 and static parameter jz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz1]
                                        {
                                            if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2]))  // If dynamic function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1]
                                            {
                                                if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If path function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1]
                                            {
                                                if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If lagrange function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz1]
                                        {
                                            if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2]))  // If dynamic function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1]
                                            {
                                                if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If path function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1]
                                            {
                                                if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If lagrange function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (kz1==NtG[iz1]) // If state variable at final point in phase iz1
                        {
                            if ((ObjectiveFinalStateDependMapG.mat[iz1].val[jz1])&&(ObjectiveStaticDependMapG.mat[0].val[jz2])) // If objective function is dependent on final state component jz1 in phase iz1 and static parameter jz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalStateDependMapG.mat[iz1].mat[event].val[jz1])&&(EventStaticDependMapG.mat[event].val[jz2]))  // If event function is dependent on final state component jz1 in phase iz1 and static parameter jz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // state variable at interior point in phase iz1
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                comp = 0;   // Initialize to first component number
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz1]
                                {
                                    if ((DynamicStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2]))  // If dynamic function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1]
                                    {
                                        if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If path function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1]
                                    {
                                        if ((LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If lagrange function comp in phase iz1 is a function of state component jz1 in phase iz1 and static parameter jz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            case 2: // Control type
                switch (lz2)
                {
                    case 1: // State type
                        if (iz1==iz2)   // If control variable and state variable are in same phase
                        {
                            if (kz1==kz2)  // If both variables at same point kz1=kz2 in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if ((DynamicControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2])) // If dynamic function comp is a function of control component jz1 and state component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2]))   // If path function comp is a function of control component jz1 and state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if ((LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2]))   // If lagrange function comp is a function of control component jz1 and state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        if (iz1==iz2)   // If control variables are in same phase
                        {
                            if (kz1==kz2)  // If both variables at same point kz1=kz2 in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    
                                    if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                        {
                                            if ((DynamicControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicControlDependMapG.mat[iz2].mat[comp].val[jz2]))   // If dynamic function comp is a function of control component jz1 and control component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathControlDependMapG.mat[iz2].mat[comp].val[jz2])) // If path function comp is a function of control component jz1 and control component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if ((LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeControlDependMapG.mat[iz2].mat[comp].val[jz2])) // If lagrange function comp is a function of control component jz1 and control component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 3: // Integral type
                        // Do nothing
                        break;
                        
                    case 4: // Initial time type
                        if (iz1==iz2)   // If control variable and initial time variable are in same phase iz1=iz2
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicControlDependMapG.mat[iz1].mat[comp].val[jz1])  // If dynamic function comp is a function of control component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                    {
                                        if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))  // If path function comp is a function of control component jz1 and time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                    {
                                        if (LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz1]) // If lagrange function comp is a function of control component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if (iz1==iz2)   // If control variable and initial time variable are in same phase iz1=iz2
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicControlDependMapG.mat[iz1].mat[comp].val[jz1])  // If dynamic function comp is a function of control component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                    {
                                        if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))  // If path function comp is a function of control component jz1 and time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                    {
                                        if (LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz1]) // If lagrange function comp is a function of control component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1
                            {
                                comp = 0;   // Initialize to first component number
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz1]
                                {
                                    if ((DynamicControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2]))    // If dynamic function comp in phase iz1 is a function of control component jz1 in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                        }
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1
                            {
                                comp = 0;   // Initialize to first constraint number
                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1]
                                {
                                    if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))  // If path function comp in phase iz1 is a function of control component jz1 in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next constraint number
                                }
                            }
                        }
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1
                            {
                                comp = 0;   // Initialize to first function number
                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1]
                                {
                                    if ((LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2]))  // If lagrange function comp in phase iz1 is a function of control component jz1 in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next function number
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            case 3: // Integral type
                switch (lz2)
                {
                    case 1: // State type
                        if (iz1==iz2)   // If integral variable and state variable are in same phase iz1=iz2
                        {
                            if (kz2==0) // If state variable at initial point in phases iz2
                            {
                                if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2]))    // If objective function is dependent on integral component jz1 and initial state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on integral component jz1 and initial state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                            {
                                if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2]))   // If objective function is dependent on integral component jz1 and final state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on integral component jz1 and final state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                        }
                        else    // integral variable and state variable in different phases
                        {
                            if (kz2==0) // If state variable at initial point in phases iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on integral component jz1 in phase iz1 and initial state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on integral component jz1 in phase iz1 and final state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        // Do nothing
                        break;
                        
                    case 3: // Integral type
                        if (iz1==iz2)   // If integral variables are in same phase iz1=iz2
                        {
                            if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2])) // If objective function is dependent on integral component jz1 and integral component jz2 in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on integral component jz1 and integral component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // integral variables are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on integral component jz1 in phase iz1 and integral component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 4: // Initial time type
                        if (iz1==iz2)   // If integral variable and initial time variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveInitTimeDependMapG.mat[iz2].val[0]))   // If objective function is dependent on integral component jz1 and initial time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0])) // If event function is dependent on integral component jz1 and initial time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // integral variable and initial time variable are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0])) // If event function is dependent on integral component jz1 in phase iz1 and initial time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if (iz1==iz2)   // If integral variable and final time variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveFinalTimeDependMapG.mat[iz2].val[0]))  // If objective function is dependent on integral component jz1 and final time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))    // If event function is dependent on integral component jz1 and final time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // integral variable and initial time variable are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))    // If event function is dependent on integral component jz1 in phase iz1 and final time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        if ((ObjectiveIntegralDependMapG.mat[iz1].val[jz1])&&(ObjectiveStaticDependMapG.mat[0].val[jz2]))   // If objective function in phase iz1 is dependent on integral component jz1 in phase iz1 and static parameter jz2
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventIntegralDependMapG.mat[iz1].mat[event].val[jz1])&&(EventStaticDependMapG.mat[event].val[jz2]))    // If event function is dependent on integral component jz1 in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            case 4: // Initial time type
                switch (lz2)
                {
                    case 1: // State type
                        if (iz1==iz2)   // If initial time variable and state variable are in same phase iz1=iz2
                        {
                            if (kz2==0) // If state variable at initial point in phase iz1=iz2
                            {
                                if ((ObjectiveInitTimeDependMapG.mat[iz1].val[0])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2]))  // If objective function is dependent on initial time and initial state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on intial time and initial state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                        
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                    else    // no event constraints
                                    {
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz1=iz2
                            {
                                if ((ObjectiveInitTimeDependMapG.mat[iz1].val[0])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2])) // If objective function is dependent on initial time and initial state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on intial time and final state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else    // state variable at interior point in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        else    // initial time variable and state variable in different phases
                        {
                            if (kz2==0) // If state variable at initial point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on intial time in phase iz1 and initial state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on intial time in phase iz1 and final state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        if (iz1==iz2)   // If initial time variable and control variable are in same phase iz1=iz2
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                comp = 0;   // Initialize to first component number
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                {
                                    if (DynamicControlDependMapG.mat[iz1].mat[comp].val[jz2])  // If dynamic function comp is a function of control component jz2 in phase iz1=iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                    {
                                        if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))  // If path function comp is a function of control component jz2 and time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                    {
                                        if (LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz2]) // If lagrange function comp is a function of control component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 3: // Integral type
                        if (iz1==iz2)   // If initial time variable and integral variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveInitTimeDependMapG.mat[iz1].val[0])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2]))   // If objective function is dependent on initial time  and integral component jz2 in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on initial time and integral component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // initial time variable and integral variable are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2])) // If event function is dependent on initial time in phase iz1 and integral component jz1 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 4: // Initial time type
                        if (iz1==iz2)   // If initial time variables are in same phase iz1=iz2
                        {
                            if (ObjectiveInitTimeDependMapG.mat[iz1].val[0]) // If objective function is dependent on initial time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if (EventInitTimeDependMapG.mat[iz1].mat[event].val[0])    // If event function is dependent on initial time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else    // initial time variables are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))   // If event function is dependent on initial time in phase iz1 and initial time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if (iz1==iz2)   // If initial time variable and final time variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveInitTimeDependMapG.mat[iz1].val[0])&&(ObjectiveFinalTimeDependMapG.mat[iz2].val[0]))    // If objective function is dependent on initial time and final time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on initial time and final time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else    // initial time variables are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on initial time and final time in phase iz1=iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        if ((ObjectiveInitTimeDependMapG.mat[iz1].val[0])&&(ObjectiveStaticDependMapG.mat[0].val[jz2])) // If objective function in phaze iz1 is dependent on initial time in phaze iz1 and static parameter jz2
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventInitTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventStaticDependMapG.mat[event].val[jz2]))  // If event function is dependent on initial time in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                                
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2])   // If dynamic function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathTimeDependMapG.mat[iz1].mat[comp].val[0])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))   // If path function comp in phase iz1 is a function of initial time in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2])  // If lagrange function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                            else    // no event constraints
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2])   // If dynamic function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathTimeDependMapG.mat[iz1].mat[comp].val[0])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))   // If path function comp in phase iz1 is a function of initial time in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2])  // If lagrange function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            case 5: // Final time type
                switch (lz2)
                {
                    case 1: // State type
                        if (iz1==iz2)   // If initial time variable and state variable are in same phase iz1=iz2
                        {
                            if (kz2==0) // If state variable at initial point in phase iz2
                            {
                                if ((ObjectiveFinalTimeDependMapG.mat[iz1].val[0])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2])) // If objective function is dependent on final time and initial state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on final time and initial state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                        
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                    else    // no event constraints
                                    {
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first constraint number
                                                while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                                {
                                                    if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz1].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next constraint number
                                                }
                                            }
                                        }
                                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                        {
                                            if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                            {
                                                comp = 0;   // Initialize to first function number
                                                while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                                {
                                                    if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                                    {
                                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                    }
                                                    comp++; // Increment to next function number
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                            {
                                if ((ObjectiveFinalTimeDependMapG.mat[iz1].val[0])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2]))    // If objective function is dependent on final time and final state component jz2 in phase iz1=iz2
                                {
                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                }
                                else    // Need to check other functions for dependencies
                                {
                                    if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                    {
                                        event = 0;  // Initialize to first event constraint
                                        while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                        {
                                            if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on final time and final state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            event++;    // Increment to next event number
                                        }
                                    }
                                }
                            }
                            else    // state variable at interior point in phase iz1=iz2
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    comp = 0;   // Initialize to first component number
                                    while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                    {
                                        if (DynamicStateDependMapG.mat[iz1].mat[comp].val[jz2])    // If dynamic function comp is a function of state component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next component number
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathStateDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))    // If path function comp is a function of state component jz2 and time in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStateDependMapG.mat[iz1].mat[comp].val[jz2])   // If lagrange function comp is a function of state component jz2 in phase iz1=iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        else    // final time variable and state variable in different phases
                        {
                            if (kz2==0) // If state variable at initial point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on final time in phase iz1 and initial state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                            else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on final time in phase iz1 and final state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        if (iz1==iz2)   // If final time variable and control variable are in same phase iz1=iz2
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                comp = 0;   // Initialize to first component number
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                {
                                    if (DynamicControlDependMapG.mat[iz1].mat[comp].val[jz2])  // If dynamic function comp is a function of control component jz2 in phase iz1=iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                    {
                                        if ((PathControlDependMapG.mat[iz1].mat[comp].val[jz2])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))  // If path function comp is a function of control component jz2 and time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                    {
                                        if (LagrangeControlDependMapG.mat[iz1].mat[comp].val[jz2]) // If lagrange function comp is a function of control component jz2 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 3: // Integral type
                        if (iz1==iz2)   // If initial time variable and integral variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveFinalTimeDependMapG.mat[iz1].val[0])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2]))  // If objective function is dependent on final time  and integral component jz2 in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on final time and integral component jz1 in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // initial time variable and integral variable are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on final time in phase iz1 and integral component jz1 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 4: // Initial time type
                        if (iz1==iz2)   // If initial time variable and final time variable are in same phase iz1=iz2
                        {
                            if ((ObjectiveFinalTimeDependMapG.mat[iz1].val[0])&&(ObjectiveInitTimeDependMapG.mat[iz2].val[0]))    // If objective function is dependent on initial time and final time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on initial time and final time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else    // final time and initial time variables are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on initial time and final time in phase iz1=iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if (iz1==iz2)   // If final time variables are in same phase iz1=iz2
                        {
                            if (ObjectiveFinalTimeDependMapG.mat[iz1].val[0])    // If objective function is dependent on final time in phase iz1=iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if (EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])   // If event function is dependent on final time in phase iz1=iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                            {
                                                if (DynamicTimeDependMapG.mat[iz1].mat[comp].val[0])   // If dynamic function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                            {
                                                if (PathTimeDependMapG.mat[iz1].mat[comp].val[0])  // If path function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                            {
                                                if (LagrangeTimeDependMapG.mat[iz1].mat[comp].val[0])  // If lagrange function comp is a function of time in phase iz1=iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else    // final time variables are in different phases
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0])) // If event function is dependent on final time in phase iz1 and final time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        if ((ObjectiveFinalTimeDependMapG.mat[iz1].val[0])&&(ObjectiveStaticDependMapG.mat[0].val[jz2]))    // If objective function in phaze iz1 is dependent on final time in phaze iz1 and static parameter jz2
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventFinalTimeDependMapG.mat[iz1].mat[event].val[0])&&(EventStaticDependMapG.mat[event].val[jz2])) // If event function is dependent on final time in phase iz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                                
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2])   // If dynamic function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathTimeDependMapG.mat[iz1].mat[comp].val[0])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))   // If path function comp in phase iz1 is a function of time in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2])  // If lagrange function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                            else    // no event constraints
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz1]>0) // If one or more dynamic functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz1])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz1=iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz1].mat[comp].val[jz2])   // If dynamic function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz1]>0) // If one or more path constraints in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz1]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz1=iz2]
                                        {
                                            if ((PathTimeDependMapG.mat[iz1].mat[comp].val[0])&&(PathStaticDependMapG.mat[iz1].mat[comp].val[jz2]))   // If path function comp in phase iz1 is a function of time in phase iz1 and static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz1]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz1]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz1=iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz1].mat[comp].val[jz2])  // If lagrange function comp in phase iz1 is a function of static parameter jz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            case 6: // Static type
                switch (lz2)
                {
                    case 1: // State type
                        if (kz2==0) // If state variable at initial point in phase iz2
                        {
                            if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveInitStateDependMapG.mat[iz2].val[jz2]))  // If objective function in phase iz2 is dependent on static parameter jz1 and initial state component jz2 in phase iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventInitStateDependMapG.mat[iz2].mat[event].val[jz2]))   // If event function is dependent on static parameter jz1 and intial state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                    
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if ((DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))  // If dynamic function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                            {
                                                if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If path function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                            {
                                                if ((LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If lagrange function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                                else    // no event constraints
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if ((DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))  // If dynamic function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                            {
                                                if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If path function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                            {
                                                if ((LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If lagrange function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else if (kz2==NtG[iz2]) // If state variable at final point in phase iz2
                        {
                            if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveFinalStateDependMapG.mat[iz2].val[jz2])) // If objective function in phase iz2 is dependent on static parameter jz1 and final state component jz2 in phase iz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            else    // Need to check other functions for dependencies
                            {
                                if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                                {
                                    event = 0;  // Initialize to first event constraint
                                    while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                    {
                                        if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventFinalStateDependMapG.mat[iz2].mat[event].val[jz2]))  // If event function is dependent on static parameter jz1 and final state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        event++;    // Increment to next event number
                                    }
                                }
                            }
                        }
                        else    // interior point in phase
                        {
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                comp = 0;   // Initialize to first component number
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                {
                                    if ((DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(DynamicStateDependMapG.mat[iz2].mat[comp].val[jz2]))  // If dynamic function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                {
                                    comp = 0;   // Initialize to first constraint number
                                    while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                    {
                                        if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If path function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next constraint number
                                    }
                                }
                            }
                            if (statHess.val[i]==0) // If partial still not flagged as nonzero
                            {
                                if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                {
                                    comp = 0;   // Initialize to first function number
                                    while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                    {
                                        if ((LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(LagrangeStateDependMapG.mat[iz2].mat[comp].val[jz2]))    // If lagrange function comp in phase iz2 is a function of static parameter jz1 and state component jz2 in phase iz2
                                        {
                                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                        }
                                        comp++; // Increment to next function number
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 2: // Control type
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            comp = 0;   // Initialize to first component number
                            if (nxG[iz2]>0) // If one or more dynamic functions in phase iz2
                            {
                                while ((statHess.val[i]==0)&&(comp<(nxG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                {
                                    if ((DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(DynamicControlDependMapG.mat[iz2].mat[comp].val[jz2]))    // If dynamic function comp in phase iz2 is a function of static parameter jz1 and control component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next component number
                                }
                            }
                        }
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                            {
                                comp = 0;   // Initialize to first constraint number
                                while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                {
                                    if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathControlDependMapG.mat[iz2].mat[comp].val[jz2]))  // If path function comp in phase iz2 is a function of static parameter jz1 and control component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next constraint number
                                }
                            }
                        }
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if (nqG[iz2]>0) // If one or more lagrange functions in phase iz2
                            {
                                comp = 0;   // Initialize to first function number
                                while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                {
                                    if ((LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(LagrangeControlDependMapG.mat[iz2].mat[comp].val[jz2]))  // If lagrange function comp in phase iz2 is a function of static parameter jz1 and control component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    comp++; // Increment to next function number
                                }
                            }
                        }
                        break;
                        
                    case 3: // Integral type
                        if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveIntegralDependMapG.mat[iz2].val[jz2]))   // If objective function in phase iz2 is dependent on static parameter jz1 and integral component jz1 in phase iz1
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventIntegralDependMapG.mat[iz2].mat[event].val[jz2]))    // If event function is dependent on static parameter jz1 and integral component jz2 in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                            }
                        }
                        break;
                        
                    case 4: // Initial time type
                        if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveInitTimeDependMapG.mat[iz2].val[0])) // If objective function in phaze iz1 is dependent on static parameter jz1 and initial time in phaze iz2
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventInitTimeDependMapG.mat[iz2].mat[event].val[0]))  // If event function is dependent on static parameter jz1 and initial time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                                
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz2]>0) // If one or more dynamic functions in phase iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])   // If dynamic function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                        {
                                            if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))   // If path function comp in phase iz2 is a function of initial time in phase iz2 and static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])  // If lagrange function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                            else    // no event constraints
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz2]>0) // If one or more dynamic functions in phase iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])   // If dynamic function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                        {
                                            if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))   // If path function comp in phase iz2 is a function of initial time in phase iz2 and static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])  // If lagrange function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 5: // Final time type
                        if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveFinalTimeDependMapG.mat[iz2].val[0]))    // If objective function in phaze iz1 is dependent on static parameter jz1 and final time in phaze iz2
                        {
                            statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                            statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                        }
                        else    // Need to check other functions for dependencies
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventFinalTimeDependMapG.mat[iz2].mat[event].val[0])) // If event function is dependent on static parameter jz1 and final time in phase iz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                                
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz2]>0) // If one or more dynamic functions in phase iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])   // If dynamic function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                        {
                                            if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))   // If path function comp in phase iz2 is a function of initial time in phase iz2 and static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])  // If lagrange function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                            else    // no event constraints
                            {
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nxG[iz2]>0) // If one or more dynamic functions in phase iz2
                                    {
                                        comp = 0;   // Initialize to first component number
                                        while ((statHess.val[i]==0)&&(comp<(nxG[iz2])))  // while partial has not yet been flagged as nonzero and comp<nxG[iz2]
                                        {
                                            if (DynamicStaticDependMapG.mat[iz2].mat[comp].val[jz1])   // If dynamic function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next component number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (ncG[iz2]>0) // If one or more path constraints in phase iz2
                                    {
                                        comp = 0;   // Initialize to first constraint number
                                        while ((statHess.val[i]==0)&&(comp<(ncG[iz2]))) // while partial has not yet been flagged as nonzero and comp<ncG[iz2]
                                        {
                                            if ((PathStaticDependMapG.mat[iz2].mat[comp].val[jz1])&&(PathTimeDependMapG.mat[iz2].mat[comp].val[0]))   // If path function comp in phase iz2 is a function of initial time in phase iz2 and static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next constraint number
                                        }
                                    }
                                }
                                if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                {
                                    if (nqG[iz2]>0) // If one or more lagrange functions in phase iz1=iz2
                                    {
                                        comp = 0;   // Initialize to first function number
                                        while ((statHess.val[i]==0)&&(comp<(nqG[iz2]))) // while partial has not yet been flagged as nonzero and comp<nqG[iz2]
                                        {
                                            if (LagrangeStaticDependMapG.mat[iz2].mat[comp].val[jz1])  // If lagrange function comp in phase iz2 is a function of static parameter jz1
                                            {
                                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                            }
                                            comp++; // Increment to next function number
                                        }
                                    }
                                }
                            }
                        }
                        break;
                        
                    case 6: // Static type
                        phase = 0;
                        while ((statHess.val[i]==0)&&(phase<PG))   // while partial has not yet been flagged as nonzero and phase<PG
                        {
                            if ((ObjectiveStaticDependMapG.mat[0].val[jz1])&&(ObjectiveStaticDependMapG.mat[0].val[jz2])) // If objective function in phase is dependent on static parameter jz1 and static parameter jz2
                            {
                                statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                            }
                            phase++;    // Increment to next phase number
                        }
                        if (statHess.val[i]==0) // If partial still not flagged as nonzero
                        {
                            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
                            {
                                event = 0;  // Initialize to first event constraint
                                while ((statHess.val[i]==0)&&(event<(nbG+nd+ne)))   // while partial has not yet been flagged as nonzero and event<nbG+nd+ne
                                {
                                    if ((EventStaticDependMapG.mat[event].val[jz1])&&(EventStaticDependMapG.mat[event].val[jz2])) // If event function is dependent on static parameter jz1 and static parameter jz2
                                    {
                                        statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                        statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                    }
                                    event++;    // Increment to next event number
                                }
                                
                                phase = 0;
                                while ((statHess.val[i]==0)&&(phase<PG))    // while partial has not yet been flagged as nonzero and phase<PG
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[phase]>0) // If one or more dynamic functions in phase
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[phase])))   // while partial has not yet been flagged as nonzero and comp<nxG[phase]
                                            {
                                                if ((DynamicStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[phase].mat[comp].val[jz2])) // If dynamic function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[phase]>0) // If one or more path constraints in phase
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[phase]))) // while partial has not yet been flagged as nonzero and comp<ncG[phase]
                                            {
                                                if ((PathStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[phase].mat[comp].val[jz2]))   // If path function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[phase]>0) // If one or more lagrange functions in phase
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[phase]))) // while partial has not yet been flagged as nonzero and comp<nqG[phase]
                                            {
                                                if ((LagrangeStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[phase].mat[comp].val[jz2]))   // If lagrange function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                    phase++;
                                }
                            }
                            else    // no event constraints
                            {
                                phase = 0;
                                while ((statHess.val[i]==0)&&(phase<PG))    // while partial has not yet been flagged as nonzero and phase<PG
                                {
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nxG[phase]>0) // If one or more dynamic functions in phase
                                        {
                                            comp = 0;   // Initialize to first component number
                                            while ((statHess.val[i]==0)&&(comp<(nxG[phase])))   // while partial has not yet been flagged as nonzero and comp<nxG[phase]
                                            {
                                                if ((DynamicStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(DynamicStaticDependMapG.mat[phase].mat[comp].val[jz2])) // If dynamic function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next component number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (ncG[phase]>0) // If one or more path constraints in phase
                                        {
                                            comp = 0;   // Initialize to first constraint number
                                            while ((statHess.val[i]==0)&&(comp<(ncG[phase]))) // while partial has not yet been flagged as nonzero and comp<ncG[phase]
                                            {
                                                if ((PathStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(PathStaticDependMapG.mat[phase].mat[comp].val[jz2]))   // If path function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next constraint number
                                            }
                                        }
                                    }
                                    if (statHess.val[i]==0) // If partial still not flagged as nonzero
                                    {
                                        if (nqG[phase]>0) // If one or more lagrange functions in phase
                                        {
                                            comp = 0;   // Initialize to first function number
                                            while ((statHess.val[i]==0)&&(comp<(nqG[phase]))) // while partial has not yet been flagged as nonzero and comp<nqG[phase]
                                            {
                                                if ((LagrangeStaticDependMapG.mat[phase].mat[comp].val[jz1])&&(LagrangeStaticDependMapG.mat[phase].mat[comp].val[jz2]))   // If lagrange function comp in phase is a function of static parameter jz1 and static parameter jz2
                                                {
                                                    statHess.val[i] = 1;                                                // Indicate partial in Lagrangian Hessian is nonzero
                                                    statHess.val[nlplhG.NumHess] = statHess.val[nlplhG.NumHess] + 1;    // Increment number of nonzeros in Lagrangian Hessian by one
                                                }
                                                comp++; // Increment to next function number
                                            }
                                        }
                                    }
                                    phase++;
                                }
                            }
                        }
                        break;
                        
                    default:
                        break;
                }
                break;
                
            default:
                break;
        }
    }
    
    return statHess;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------CGPOPS DISPLAY function--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void DisplayCGPOPSVersion(void)
{
    
    printf("\n---------------------------------------------------------------------------------------");
    printf("\n|                                                                                     |");
    printf("\n|                                                                                     |");
    printf("\n|                       ______ ______ ____   ____   ____  _____                       |");
    printf("\n|                      / ____// ____// __ \\ / __ \\ / __ \\/ ___/                       |");
    printf("\n|                     / /    / / __ / /_/ // / / // /_/ /\\_  \\                        |");
    printf("\n|                    / /___ / /_/ // ____// /_/ // ____/___/ /                        |");
    printf("\n|                    \\____/ \\____//_/     \\____//_/    /____/                         |");
    printf("\n|                                                                                     |");
    printf("\n| CGPOPS Version 21.0                                                                 |");
    printf("\n|                                                                                     |");
    printf("\n---------------------------------------------------------------------------------------");
    printf("\n|                                                                                     |");
    printf("\n| Authored by Yunus M. Agamawi & Anil V. Rao                                          |");
    printf("\n| Vehicle Dynamics & Optimization Laboratory                                          |");
    printf("\n|                                                                                     |");
    printf("\n---------------------------------------------------------------------------------------");
    
    // Display selected derivative supplier
    
    if (derivativeSupplierG==0) // Hyper-Dual derivative approximation
    {
        printf("\nDerivative Supplier: Hyper-Dual\n");
    }
    else if (derivativeSupplierG==1) // Bicomplex-step derivative approximation
    {
        printf("\nDerivative Supplier: Bicomplex-step\n");
    }
    else if (derivativeSupplierG==2)    // Central finite difference derivative approximation
    {
        printf("\nDerivative Supplier: Central Finite Difference\n");
    }
    else if (derivativeSupplierG==3)    // Central finite difference derivative approximation
    {
        printf("\nDerivative Supplier: Central Finite Difference Naive\n");
    }
    else if (derivativeSupplierG==4)    // Algorithmic differentiation
    {
        printf("\nDerivative Supplier: Algorithmic Differentiation\n");
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------IPOPT Handler function---------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////


//void CGPOPS_IPOPT_caller(doubleMat& wrapper_data, clock_t start_t)  // CGPOPS caller for handler of IPOPT application
void CGPOPS_IPOPT_caller(doubleMat& cgpopsResults)  // CGPOPS caller for handler of IPOPT application
{
    if (initGlobalVarsFlagG==0)
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n-------------ERROR: Make call to initGlobalVar before setting calling CGPOPS_IPOPT_caller global variable-------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        runIPOPTFlagG = 0;
    }
    else if (setRPMDGFlagG!=PG)
    {
        if (setRPMDGFlagG==0)
        {
            
        }
        else if (setRPMDGFlagG>PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n--------------------------ERROR: setRPMDG called more times than number of phases in problem--------------------------");
            printf("\n---------------------------------------------- Attempting to continue anyway -----------------------------------------");
            printf("\n----------------------------------------------------------------------------------------------------------------------");
        }
        else if (setRPMDGFlagG<PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n--------------------------ERROR: setRPMDG called less times than number of phases in problem--------------------------");
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
    }
    else if (setInfoNLPGFlagG==0)
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n-------------ERROR: Make call to setInfoNLPG before setting calling CGPOPS_IPOPT_caller global variable-------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        runIPOPTFlagG = 0;
    }
    else if (setNLPPBGFlagG!=PG)
    {
        if (setNLPPBGFlagG==0)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n------------------------ERROR: setNLPPBG called zero times for %d number of phases in problem-------------------------",PG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
        else if (setNLPPBGFlagG>PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n-------------------------ERROR: setNLPPBG called %d times for %d number of phases in problem--------------------------",setNLPPBGFlagG,PG);
//            printf("\n---------------------------------------------- Attempting to continue anyway -----------------------------------------");
            printf("\n----------------------------------------------------------------------------------------------------------------------");
//            setNLPPGGFlagG = PG;
            runIPOPTFlagG = 0;
        }
        else if (setNLPPBGFlagG<PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n--------------------------ERROR: setNLPPBG called %d times for %d number of phases in problem--------------------------",setNLPPBGFlagG,PG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
    }
    else if (setNLPPGGFlagG!=PG)
    {
        if (setNLPPGGFlagG==0)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n------------------------ERROR: setNLPPBG called zero times for %d number of phases in problem-------------------------",PG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
        else if (setNLPPGGFlagG>PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n--------------------------ERROR: setNLPPBG called %d times for %d number of phases in problem-------------------------",setNLPPGGFlagG,PG);
//            printf("\n---------------------------------------------- Attempting to continue anyway -----------------------------------------");
            printf("\n----------------------------------------------------------------------------------------------------------------------");
//            setNLPPGGFlagG = PG;
            runIPOPTFlagG = 0;
        }
        else if (setNLPPGGFlagG<PG)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n--------------------------ERROR: setNLPPBG called %d times for %d number of phases in problem-------------------------",setNLPPGGFlagG,PG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
    }
    else if (setNLPWBGFlagG==0)
    {
        if (nsG>0)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n------------------------------ERROR: setNLPWBG called zero times for %d static parameters-----------------------------",nsG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
        else if (nbG>0)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n------------------------------ERROR: setNLPWBG called zero times for %d event constraints-----------------------------",nbG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
        else if ((nsG==0)&&(nbG==0))
        {
            // Whole problem bounds
            double sl[nsG], su[nsG];
            double bl[nbG], bu[nbG];
            
            // Set parameterized constructor for NLP Whole Bounds Class
            setNLPWBG(sl,su,bl,bu);
        }
    }
    else if (setNLPWGGFlagG==0)
    {
        if (nsG>0)
        {
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            printf("\n------------------------------ERROR: setNLPWGG called zero times for %d static parameters-----------------------------",nsG);
            printf("\n----------------------------------------------------------------------------------------------------------------------");
            runIPOPTFlagG = 0;
        }
        else
        {
            double sg[nsG];
            // Set parameterized constructor for NLP Phase Guess Class
            setNLPWGG(sg);
        }
    }
    
    if ((setInfoNLPGFlagG==1)&&(setNLPPBGFlagG==PG)&&(setNLPPGGFlagG==PG)&&(setNLPWBGFlagG==1)&&(setNLPWGGFlagG==1))
    {
        // Get parameterized constructor for NLP Initial Guess Class
        nlpigG = getNLPIG(LenZG,LenHG);
//        printf(nlpigG);
        
        if ((warmStartBinFlagG==1)&&(strFileBinG!=0))   // If using warm start from binary file
        {
            // Obtain systemInfo structure from save solution on binary file
            sysinfowarmG = scanf4SystemInfoBIN(strFileBinG);
//            printf("\n\n\n\n\n");
//            printf("\nsysinfowarmG:");
//            printf(sysinfowarmG);
            
            // Initialize NLP Decision Vector Z using warm start solution
            getNLPZInitWarm();
//            printf(nlpigG);
        }
        else
        {
            // Initialize NLP Decision Vector Z using provided variable bounds and initial and final guess values
            getNLPZInit();
//            printf(nlpigG);
        }
        
        // Initialize NLP Constraints Multipliers using provided constraints bounds
        getNLPLambdaInit();
        
        // Construct structure for storing number of nonzeros in nlp derivative matrices
        nlpdiG = getNLPDI(infonlpG.NLPGrad.NNZ,infonlpG.NLPJac.Len,infonlpG.NLPHess.Len);
        
        // Refine Sparsity Patterns of NLP Derivative Matrices
        refineSparsePat();
    }
    
    if (viewSparsePatFlagG==1)
    {
        if (viewGradPatFlagG==1)
        {
            viewGradPat();
        }
        if (viewJacPatFlagG==1)
        {
            viewJacPat();
        }
        if (viewHessPatFlagG==1)
        {
            viewHessPat();
        }
    }
    
    if (runIPOPTFlagG)
    {
        int numMesh=1;
        if (maxMeshIterG>0)
        {
            numMesh = maxMeshIterG;
        }
        doubleMatMat MeshHistoryFracs(numMesh);
        intMatMat MeshHistoryColPts(numMesh);
        doubleMatMat MeshHistoryTimes(numMesh);
        doubleMatMat MeshHistoryMaxErr(numMesh);
        intMatMat MeshHistoryPhasePts(numMesh);
        intMatMat MeshHistoryPhaseSegs(numMesh);
        double cpu_total_time;
        
        DisplayCGPOPSVersion();
        
        double runTimeIPOPT;
        printf("\n");
        runTimeIPOPT = CGPOPS_IPOPT_handler();
        printf("\n");
        printf("\niterIPOPTG = %d;",iterIPOPTG);
        printf("\nrunTimeIPOPT = %.15f;",runTimeIPOPT);
        //    printf4MATLAB(sysinfoG);
        
        runtimeG = runTimeIPOPT;
        
        int retint;
        retint = ComputeHamiltonian();
        
        MeshHistoryTimes.mat[MeshIterG]   = getMeshColPtTimes();
        MeshHistoryFracs.mat[MeshIterG]   = getMeshFractions();
        MeshHistoryColPts.mat[MeshIterG]     = getMeshColPts();
        MeshHistoryPhasePts.mat[MeshIterG]   = getMeshPhasePts();
        MeshHistoryPhaseSegs.mat[MeshIterG]  = getMeshPhaseSegs();
        
        int newMeshStat;
        printf("\n");
        newMeshStat = meshRefine();
        
        MeshHistoryMaxErr.mat[MeshIterG-1]   = getMeshMaxErr();

        int iter=0;
        int iterLim=maxMeshIterG;
        int userinput,exit=0,run=1;
        while ((newMeshStat)&&(MeshIterG<maxMeshIterG)&&(iter<iterLim))
        {
            
            userinput = 1;
            while (userinput&&!run)
            {
                std::cout << "\nOptions: 0 = continue\n\t 1 = break\n\t 2 = run\n\t 3 = meshRefineData\n\t 4 = RPMD\n\t 5 = IPOPT solution\n\t Enter input: ";
                std::cin >> userinput;
                std::cout << "The value you entered is " << userinput << ".\n";
                if (userinput==1)
                {
                    exit = 1;
                    userinput = 0;
                }
                else if (userinput==2)
                {
                    run = 1;
                    userinput = 0;
                }
                else if (userinput==3)
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf(mrdG[p]);
                    }
                }
                else if (userinput==4)
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf(rpmdG[p]);
                    }
                }
                else if (userinput==5)
                {
                    printf(sysinfosolG);
                }
            }
            if (exit)
            {
                break;
            }
            
            printf("\nMesh error tolerance was NOT met on previous mesh grid: MeshIterG = %d",MeshIterG);
            printf("\nMesh grid was refined using mesh refinement technique: %s\n\n",meshRefineTechG);
            
            runTimeIPOPT = CGPOPS_IPOPT_handler();
            retint = ComputeHamiltonian();
            
            MeshHistoryTimes.mat[MeshIterG]   = getMeshColPtTimes();
            MeshHistoryFracs.mat[MeshIterG]   = getMeshFractions();
            MeshHistoryColPts.mat[MeshIterG]     = getMeshColPts();
            MeshHistoryPhasePts.mat[MeshIterG]   = getMeshPhasePts();
            MeshHistoryPhaseSegs.mat[MeshIterG]  = getMeshPhaseSegs();
            //        printf("\n");
            //        printf("\nrunTimeIPOPT = %.15f;",runTimeIPOPT);
            //        printf4MATLAB(sysinfoG);
            newMeshStat = meshRefine();
            
            MeshHistoryMaxErr.mat[MeshIterG-1]   = getMeshMaxErr();
            iter++;
        }
        
        
        end_CGPOPS_tG = clock();
        
        cpu_total_time = ((double) (end_CGPOPS_tG-start_CGPOPS_tG))/CLOCKS_PER_SEC;
        
        runtimeG = cpu_total_time;
        
//        printf(sysinfosolG);
        
        if (SaveIPOPTSolutionFlagG>0)
        {
            CGPOPS_IPOPT_solution_saver(1);
        }
        
        if (MeshIterG>=maxMeshIterG)
        {
            printf("\nMaximum mesh iteration reached: MeshIterG = %d ( = maxMeshIterG = %d)",MeshIterG,maxMeshIterG);
        }
        if (newMeshStat==0)
        {
            printf("\nrunTimeCGPOPS = %.15f;",cpu_total_time);
            //        printf4MATLAB(sysinfosolG);
            printf("\nMesh error tolerance was MET on final mesh grid: MeshIterG = %d",MeshIterG);
            printf("\nMesh grid was refined using mesh refinement technique: %s\n\n",meshRefineTechG);
            //        printf(mrdG[0]);
//            retint = ComputeHamiltonian();
        }
        
        printf("\n\nCPU Total Time Used: %.15f secs\n",cpu_total_time);
        printf("\niterIPOPTG = %d;",iterIPOPTG);
        printf("\nipoptTimeG = %.15f secs\n",ipoptNLPTimeG);
        cgpopsResults = getDoubleMat(4);
        cgpopsResults.val[0] = iterIPOPTG;
        cgpopsResults.val[1] = ipoptNLPTimeG;
        cgpopsResults.val[2] = cpu_total_time;
        cgpopsResults.val[3] = ipoptNLPObjG;
        
        
        if (derivativeSupplierG==0)
        {
            printf("\nderivativeSupplierG = Hyper-Dual");
            
            if (saveMeshRefineFlagG==1)
            {
                printf4MSCRIPT("cgpopsMeshHistoryTimesHD",MeshHistoryTimes);
                printf4MSCRIPT("cgpopsMeshHistoryFracsHD",MeshHistoryFracs);
                printf4MSCRIPT("cgpopsMeshHistoryColPtsHD",MeshHistoryColPts);
                printf4MSCRIPT("cgpopsMeshHistoryMaxErrHD",MeshHistoryMaxErr);
                printf4MSCRIPT("cgpopsMeshHistoryPhasePtsHD",MeshHistoryPhasePts);
                printf4MSCRIPT("cgpopsMeshHistoryPhaseSegsHD",MeshHistoryPhaseSegs);
            }
            
            if (saveHamiltonianG==1)
            {
                printf4MSCRIPT("cgpopsHamiltonianHD",HamiltonianG);
            }
            if (saveLTIHG==1)
            {
                if ((PorigG!=PG)&&(MeshIterG==1))
                {
                    for (int p=0; p<PorigG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHHD",LinearTermsHamiltonianG.mat[p]);
                    }
                }
                else
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHHD",LinearTermsHamiltonianG.mat[p]);
                    }
                }
            }
        }
        else if (derivativeSupplierG==1)
        {
            printf("\nderivativeSupplierG = Bicomplex-step");
            
            if (saveMeshRefineFlagG==1)
            {
                printf4MSCRIPT("cgpopsMeshHistoryTimesBC",MeshHistoryTimes);
                printf4MSCRIPT("cgpopsMeshHistoryFracsBC",MeshHistoryFracs);
                printf4MSCRIPT("cgpopsMeshHistoryColPtsBC",MeshHistoryColPts);
                printf4MSCRIPT("cgpopsMeshHistoryMaxErrBC",MeshHistoryMaxErr);
                printf4MSCRIPT("cgpopsMeshHistoryPhasePtsBC",MeshHistoryPhasePts);
                printf4MSCRIPT("cgpopsMeshHistoryPhaseSegsBC",MeshHistoryPhaseSegs);
            }
            
            if (saveHamiltonianG==1)
            {
                printf4MSCRIPT("cgpopsHamiltonianBC",HamiltonianG);
            }
            if (saveLTIHG==1)
            {
                if ((PorigG!=PG)&&(MeshIterG==1))
                {
                    for (int p=0; p<PorigG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHBC",LinearTermsHamiltonianG.mat[p]);
                    }
                }
                else
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHBC",LinearTermsHamiltonianG.mat[p]);
                    }
                }
            }
        }
        else if (derivativeSupplierG==2)
        {
            printf("\nderivativeSupplierG = Central Finite Difference");
            
            if (saveMeshRefineFlagG==1)
            {
                printf4MSCRIPT("cgpopsMeshHistoryTimesCD",MeshHistoryTimes);
                printf4MSCRIPT("cgpopsMeshHistoryFracsCD",MeshHistoryFracs);
                printf4MSCRIPT("cgpopsMeshHistoryColPtsCD",MeshHistoryColPts);
                printf4MSCRIPT("cgpopsMeshHistoryMaxErrCD",MeshHistoryMaxErr);
                printf4MSCRIPT("cgpopsMeshHistoryPhasePtsCD",MeshHistoryPhasePts);
                printf4MSCRIPT("cgpopsMeshHistoryPhaseSegsCD",MeshHistoryPhaseSegs);
            }
            
            if (saveHamiltonianG==1)
            {
                printf4MSCRIPT("cgpopsHamiltonianCD",HamiltonianG);
            }
            if (saveLTIHG==1)
            {
                if ((PorigG!=PG)&&(MeshIterG==1))
                {
                    for (int p=0; p<PorigG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHCD",LinearTermsHamiltonianG.mat[p]);
                    }
                }
                else
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHCD",LinearTermsHamiltonianG.mat[p]);
                    }
                }
            }
        }
        else if (derivativeSupplierG==3)
        {
            printf("\nderivativeSupplierG = Central Finite Difference Naive");
            
            if (saveMeshRefineFlagG==1)
            {
                printf4MSCRIPT("cgpopsMeshHistoryTimesCN",MeshHistoryTimes);
                printf4MSCRIPT("cgpopsMeshHistoryFracsCN",MeshHistoryFracs);
                printf4MSCRIPT("cgpopsMeshHistoryColPtsCN",MeshHistoryColPts);
                printf4MSCRIPT("cgpopsMeshHistoryMaxErrCN",MeshHistoryMaxErr);
                printf4MSCRIPT("cgpopsMeshHistoryPhasePtsCN",MeshHistoryPhasePts);
                printf4MSCRIPT("cgpopsMeshHistoryPhaseSegsCN",MeshHistoryPhaseSegs);
            }
            
            if (saveHamiltonianG==1)
            {
                printf4MSCRIPT("cgpopsHamiltonianCN",HamiltonianG);
            }
            if (saveLTIHG==1)
            {
                if ((PorigG!=PG)&&(MeshIterG==1))
                {
                    for (int p=0; p<PorigG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHCN",LinearTermsHamiltonianG.mat[p]);
                    }
                }
                else
                {
                    for (int p=0; p<PG; p++)
                    {
                        printf4MSCRIPT("cgpopsLTIHCN",LinearTermsHamiltonianG.mat[p]);
                    }
                }
            }
        }
    }
    else
    {
        cgpopsResults = getDoubleMat(4);
    }
    
    printf("\n\n\n\n\n\n");
    deleteGlobalVars();
    printf("\n\n\n\n\n\n");
}

//ApplicationReturnStatus CGPOPS_IPOPT_handler(void); // CGPOPS handler for IPOPT application
double CGPOPS_IPOPT_handler(void)
{
    clock_t start,end;
    double cpu_time_used;
    
    start = clock();
    
    ApplicationReturnStatus status;

    // Create a new instance of your nlp
    //  (use a SmartPtr, not raw)
    SmartPtr<TNLP> cgpops_nlp = new CGPOPS_NLP();
    
    // Create a new instance of IpoptApplication
    //  (use a SmartPtr, not raw)
    // We are using the factory, since this allows us to compile this
    // example with an Ipopt Windows DLL
    SmartPtr<IpoptApplication> app = IpoptApplicationFactory();
    app->RethrowNonIpoptException(true);
    
    // Change some options
    // Note: The following choices are only examples, they might not be
    //       suitable for your optimization problem.
    app->Options()->SetNumericValue("tol", NLPtolG);
    app->Options()->SetIntegerValue("max_iter", NLPmaxiterG);
    //app->Options()->SetStringValue("hessian_approximation", "limited-memory");  // test
    //app->Options()->SetStringValue("derivative_test", "second-order");  // doesn't work
    //app->Options()->SetStringValue("derivative_test", "first-order");  // works
    //app->Options()->SetStringValue("linear_solver", "ma27");    // works
//    app->Options()->SetStringValue("linear_solver", "mumps");   // works faster
    app->Options()->SetStringValue("linear_solver", "ma57");    // works fastest
    //app->Options()->SetStringValue("linear_solver", "ma77");    // didn't work
    //app->Options()->SetStringValue("linear_solver", "ma86");    // doesn't work
    //app->Options()->SetStringValue("linear_solver", "ma97");    // doesn't work
    //app->Options()->SetStringValue("linear_solver", "pardiso"); // doesn't work
    //app->Options()->SetStringValue("linear_solver", "wsmp");    // doesn't work
    app->Options()->SetStringValue("mu_strategy", "adaptive");
    app->Options()->SetStringValue("ma57_automatic_scaling", "yes");
    app->Options()->SetStringValue("print_user_options", "yes");
//    app->Options()->SetStringValue("print_options_documentation", "yes");
    if (TimeStatsFlagG==1)
    {
        app->Options()->SetStringValue("print_timing_statistics", "yes");
    }
//    app->Options()->SetStringValue("accept_every_trial_step", "yes");
//    app->Options()->SetStringValue("fast_step_computation", "yes");
    app->Options()->SetStringValue("output_file", "../output/ipoptINFO.txt");
    // The following overwrites the default name (ipopt.opt) of the
    // options file
    app->Options()->SetStringValue("option_file_name", "../input/ipoptOPTIONS.txt");
    
    // Initialize the IpoptApplication and process the options
    // ApplicationReturnStatus status;
    status = app->Initialize();
    if (status != Solve_Succeeded)
    {
        std::cout << std::endl << std::endl << "*** Error during initialization!" << std::endl;
        return status;
    }
    else
    {
        std::cout << std::endl << std::endl << "*** Initialization Successful!" << std::endl;
    }
    
    // Ask Ipopt to solve the problem
    status = app->OptimizeTNLP(cgpops_nlp);
    
    end = clock();
    cpu_time_used = ((double) (end-start))/CLOCKS_PER_SEC;
    printf("\n\nCPU Time Used: %.15f secs\n",cpu_time_used);
    
    if (status == Solve_Succeeded) {
        std::cout << std::endl << std::endl << "*** The problem solved!" << std::endl;
    }
    else {
        std::cout << std::endl << std::endl << "*** The problem FAILED!" << std::endl;
    }
    
    // As the SmartPtrs go out of scope, the reference count
    // will be decremented and the objects will automatically
    // be deleted.
    
//    return status;
    
//    printf("\ncpu_time_used = %.15f",cpu_time_used);
    return cpu_time_used;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------Global Variable functions--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void initGlobalVars(void)   // Allocate memory for global phase array variables using PG size
{
//    printf("\nInitializing Global Variables");
    start_CGPOPS_tG = clock();
    if (PG==0)
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n-----------------------------------ERROR: Number of phases in problem are set to zero---------------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
    else
    {
        initGlobalVarsFlagG = 1;
    }
    PorigG = PG;
    nxG     = new int[PG];
    nuG     = new int[PG];
    nqG     = new int[PG];
    ncG     = new int[PG];
    NtG     = new int[PG];
    nppG    = new int[PG];
    nxorigG = new int[PG];
    nuorigG = new int[PG];
    nqorigG = new int[PG];
    ncorigG = new int[PG];
    npporigG = new int[PG];
    rpmdG   = new RPMD[PG];
    mrdG    = new meshRefineData[PG];
    LavrentievConstraintG = getIntMat(PG);
    LavrentievConstraintCompG = getIntMatMat(PG);
    LavrentievTolG = getDoubleMatMat(PG);
    
    ControlParamSpecsG = getIntMatMatMat(PG);
    for (int phase=0; phase<PG; phase++)
    {
        ControlParamSpecsG.mat[phase] = getIntMatMat(3);
        nxG[phase] = 0;
        nuG[phase] = 0;
        nqG[phase] = 0;
        ncG[phase] = 0;
        nppG[phase] = 0;
        NtG[phase] = 0;
    }
    
    // Set mesh refinement technique (default: hp-PattersonRao)
    // (1: hp-PattersonRao)
    // (2: hp-DarbyRao)
    // (3: hp-LiuRao)
    // (4: hp-LiuRao-Legendre)
    setMeshRefineTech(meshRefineTypeG);
    
    SaveIPOPTSolutionFlagG = saveIPOPTFlagG;
    
    // Get parameterized constructor for NLP Bounds Class
    nlpbG = getNLPB(PG);
    
    // Get parameterized constructor for NLP Guess Class
    nlpgG = getNLPG(PG);
    ContinuityEnforceG = getIntMat(PG-1);
    ContinuityLBG = getDoubleMatMat(PG-1);
    ContinuityUBG = getDoubleMatMat(PG-1);
    PhaseSwitchG = getIntMat(PG);
    for (int p=0; p<PG; p++)
    {
        PhaseSwitchG.val[p] = p;
    }
}

void reinitGlobalVars(void)   // Allocate memory for global phase array variables using PG size
{
    //    printf("\nInitializing Global Variables");
    
    if (PG>0)
    {
        //        printf("\nDeleting Global Variables");
        delete[] nxG;
        delete[] nuG;
        delete[] nqG;
        delete[] ncG;
        delete[] NtG;
        delete[] nppG;
        delete[] nZG;
        delete[] PrIZG;
        delete[] TeIZG;
        delete[] nHG;
        delete[] PrIHG;
        delete[] TeIHG;
        delete[] rpmdG;
        delete[] mrdG;
        
        nxG = nullptr;
        nuG = nullptr;
        nqG = nullptr;
        ncG = nullptr;
        NtG = nullptr;
        nppG = nullptr;
        nZG = nullptr;
        PrIZG = nullptr;
        TeIZG = nullptr;
        nHG = nullptr;
        PrIHG = nullptr;
        TeIHG = nullptr;
        rpmdG = nullptr;
        mrdG = nullptr;
        
        if (PhaseParametersInitFlagG==0)
        {
            delete[] PhaseParameterDependenciesG;
            delete[] StatePhaseDependenciesG;
            delete[] ControlPhaseDependenciesG;
            delete[] StaticPhaseDependenciesG;
            delete[] TimePhaseDependenciesG;
            delete[] DynamicPhaseDependenciesG;
            delete[] PathPhaseDependenciesG;
            delete[] LagrangePhaseDependenciesG;
            delete[] PhaseDynamicTimeDependMapG;
            delete[] PhaseDynamicStateDependMapG;
            delete[] PhaseDynamicControlDependMapG;
            delete[] PhaseDynamicStaticDependMapG;
            delete[] PhasePathTimeDependMapG;
            delete[] PhasePathStateDependMapG;
            delete[] PhasePathControlDependMapG;
            delete[] PhasePathStaticDependMapG;
            delete[] PhaseLagrangeTimeDependMapG;
            delete[] PhaseLagrangeStateDependMapG;
            delete[] PhaseLagrangeControlDependMapG;
            delete[] PhaseLagrangeStaticDependMapG;
            
            PhaseParameterDependenciesG = nullptr;
            StatePhaseDependenciesG = nullptr;
            ControlPhaseDependenciesG = nullptr;
            StaticPhaseDependenciesG = nullptr;
            TimePhaseDependenciesG = nullptr;
            DynamicPhaseDependenciesG = nullptr;
            PathPhaseDependenciesG = nullptr;
            LagrangePhaseDependenciesG = nullptr;
            PhaseDynamicTimeDependMapG = nullptr;
            PhaseDynamicStateDependMapG = nullptr;
            PhaseDynamicControlDependMapG = nullptr;
            PhaseDynamicStaticDependMapG = nullptr;
            PhasePathTimeDependMapG = nullptr;
            PhasePathStateDependMapG = nullptr;
            PhasePathControlDependMapG = nullptr;
            PhasePathStaticDependMapG = nullptr;
            PhaseLagrangeTimeDependMapG = nullptr;
            PhaseLagrangeStateDependMapG = nullptr;
            PhaseLagrangeControlDependMapG = nullptr;
            PhaseLagrangeStaticDependMapG = nullptr;
        }
        if (EndpointParametersInitFlagG==0)
        {
            delete[] InitStateEndpointDependenciesG;
            delete[] FinalStateEndpointDependenciesG;
            delete[] IntegralEndpointDependenciesG;
            delete[] InitTimeEndpointDependenciesG;
            delete[] FinalTimeEndpointDependenciesG;
            delete[] EndpointEventInitStateDependMapG;
            delete[] EndpointEventFinalStateDependMapG;
            delete[] EndpointEventIntegralDependMapG;
            delete[] EndpointEventInitTimeDependMapG;
            delete[] EndpointEventFinalTimeDependMapG;
            
            InitStateEndpointDependenciesG = nullptr;
            FinalStateEndpointDependenciesG = nullptr;
            IntegralEndpointDependenciesG = nullptr;
            InitTimeEndpointDependenciesG = nullptr;
            FinalTimeEndpointDependenciesG = nullptr;
            EndpointEventInitStateDependMapG = nullptr;
            EndpointEventFinalStateDependMapG = nullptr;
            EndpointEventIntegralDependMapG = nullptr;
            EndpointEventInitTimeDependMapG = nullptr;
            EndpointEventFinalTimeDependMapG = nullptr;
        }
        PhaseParametersInitFlagG = 1;
        EndpointParametersInitFlagG = 1;
        ParameterDependenciesFlagG = 0;
        setRPMDGFlagG=0;
        setInfoNLPGFlagG=0;
        setNLPPBGFlagG=0;
        setNLPWBGFlagG=0;
        setNLPPGGFlagG=0;
        setNLPWGGFlagG=0;
        ContinuityFlagG=0;
        neG=0;
    }
    
    if (PG==0)
    {
        printf("\n----------------------------------------------------------------------------------------------------------------------");
        printf("\n-----------------------------------ERROR: Number of phases in problem are set to zero---------------------------------");
        printf("\n----------------------------------------------------------------------------------------------------------------------");
    }
    
    nxG     = new int[PG];
    nuG     = new int[PG];
    nqG     = new int[PG];
    ncG     = new int[PG];
    NtG     = new int[PG];
    nppG    = new int[PG];
    rpmdG   = new RPMD[PG];
    mrdG    = new meshRefineData[PG];
    LavrentievConstraintG = getIntMat(PG);
    LavrentievConstraintCompG = getIntMatMat(PG);
    LavrentievTolG = getDoubleMatMat(PG);
    
    ControlParamSpecsG = getIntMatMatMat(PG);
    for (int phase=0; phase<PG; phase++)
    {
        ControlParamSpecsG.mat[phase] = getIntMatMat(3);
        nxG[phase] = 0;
        nuG[phase] = 0;
        nqG[phase] = 0;
        ncG[phase] = 0;
        nppG[phase] = 0;
        NtG[phase] = 0;
    }
    
    // Get parameterized constructor for NLP Bounds Class
    nlpbG = getNLPB(PG);
    
    // Get parameterized constructor for NLP Guess Class
    nlpgG = getNLPG(PG);
    ContinuityEnforceG = getIntMat(PG-1);
    ContinuityLBG = getDoubleMatMat(PG-1);
    ContinuityUBG = getDoubleMatMat(PG-1);
    PhaseSwitchG = getIntMat(PG);
}

void allocateDerivativeVars(void)   // Allocate memory for structures to hold derivative values
{
    int numEvent;   // Holder for total number of event constraints that are active
    if ((DurationFlagG)&&(ContinuityFlagG))   // If duration and continuity constraints are active
    {
        numEvent = nbG + PG + neG;    // Number of event constraints equals number defined by user plus duration constraints and continuity constraints
    }
    else if (DurationFlagG)   // If duration constraints are active
    {
        numEvent = nbG + PG;    // Number of event constraints equals number defined by user plus duration constraints
    }
    else if (ContinuityFlagG)   // If continuity constraints are active
    {
        numEvent = nbG + neG;    // Number of event constraints equals number defined by user plus continuity constraints
    }
    else
    {
        numEvent = nbG; // Number of event constraints equals number defined by user
    }
    
    ptMatMatDub = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ptMatMatBC  = getBicomplexMatMat(PG);   // Allocate memory for number of phases in problem
    ptMatMatHD  = getHyperDualMatMat(PG);   // Allocate memory for number of phases in problem
    
    DynamicFuncValG     = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    DefectFuncValG      = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    PathFuncValG        = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    LagrangeFuncValG    = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        DynamicFuncValG.mat[phase]     = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        DefectFuncValG.mat[phase]      = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        PathFuncValG.mat[phase]        = getDoubleMatMat(ncG[phase]);  // Allocate memory for number of path constraints in phase
        LagrangeFuncValG.mat[phase]    = getDoubleMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
    }
    
    ObjectiveInitStateFirstDerG     = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveFinalStateFirstDerG    = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveIntegralFirstDerG      = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveInitTimeFirstDerG      = getDoubleMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveFinalTimeFirstDerG     = getDoubleMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveStaticFirstDerG        = getDoubleMatMat(1);  // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        ObjectiveInitStateFirstDerG.mat[phase] = getDoubleMat(nxG[phase]);    // Allocate memory for number of state components in phase
        ObjectiveFinalStateFirstDerG.mat[phase] = getDoubleMat(nxG[phase]);   // Allocate memory for number of state components in phase
        ObjectiveIntegralFirstDerG.mat[phase] = getDoubleMat(nqG[phase]);     // Allocate memory for number of integral components in phase
    }
    ObjectiveStaticFirstDerG.mat[0] = getDoubleMat(nsG);  // Allocate memory for number of static parameters in problem
    
    EventInitStateFirstDerG     = getDoubleMatMatMat(numEvent); // Allocate memory for number of event constraints in problem
    EventFinalStateFirstDerG    = getDoubleMatMatMat(numEvent); // Allocate memory for number of event constraints in problem
    EventIntegralFirstDerG      = getDoubleMatMatMat(numEvent); // Allocate memory for number of event constraints in problem
    EventInitTimeFirstDerG      = getDoubleMatMat(numEvent);    // Allocate memory for number of event constraints in problem
    EventFinalTimeFirstDerG     = getDoubleMatMat(numEvent);    // Allocate memory for number of event constraints in problem
    EventStaticFirstDerG        = getDoubleMatMat(numEvent);    // Allocate memory for number of event constraints in problem
    for (int event=0; event<numEvent; event++)  // For each event constraint in problem
    {
        EventInitStateFirstDerG.mat[event]     = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
        EventFinalStateFirstDerG.mat[event]    = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
        EventIntegralFirstDerG.mat[event]      = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
        EventInitTimeFirstDerG.mat[event]         = getDoubleMat(PG);     // Allocate memory for number of phases in problem
        EventFinalTimeFirstDerG.mat[event]        = getDoubleMat(PG);     // Allocate memory for number of phases in problem
        EventStaticFirstDerG.mat[event]           = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            EventInitStateFirstDerG.mat[event].mat[phase] = getDoubleMat(nxG[phase]);    // Allocate memory for number of state components in phase
            EventFinalStateFirstDerG.mat[event].mat[phase] = getDoubleMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventIntegralFirstDerG.mat[event].mat[phase] = getDoubleMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        }
    }
    
    DynamicStateFirstDerG   = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicControlFirstDerG = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicTimeFirstDerG    = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
    DynamicStaticFirstDerG  = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        DynamicStateFirstDerG.mat[phase]    = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
        DynamicControlFirstDerG.mat[phase]  = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
        DynamicTimeFirstDerG.mat[phase]        = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
        DynamicStaticFirstDerG.mat[phase]   = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            DynamicStateFirstDerG.mat[phase].mat[comp]     = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            DynamicControlFirstDerG.mat[phase].mat[comp]   = getDoubleMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
            DynamicStaticFirstDerG.mat[phase].mat[comp]    = getDoubleMatMat(nsG);         // Allocate memory for number of static parameters in problem
        }
    }
    
    PathStateFirstDerG   = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    PathControlFirstDerG = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    PathTimeFirstDerG    = getDoubleMatMatMat(PG);      // Allocate memory for number of phases in problem
    PathStaticFirstDerG  = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        PathStateFirstDerG.mat[phase]    = getDoubleMatMatMat(ncG[phase]);  // Allocate memory for number of path constraints in phase
        PathControlFirstDerG.mat[phase]  = getDoubleMatMatMat(ncG[phase]);  // Allocate memory for number of path constraints in phase
        PathTimeFirstDerG.mat[phase]        = getDoubleMatMat(ncG[phase]);     // Allocate memory for number of path constraints in phase
        PathStaticFirstDerG.mat[phase]   = getDoubleMatMatMat(ncG[phase]);  // Allocate memory for number of path constraints in phase
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
            PathStateFirstDerG.mat[phase].mat[comp]     = getDoubleMatMat(nxG[phase]); // Allocate memory for number of state components in phase
            PathControlFirstDerG.mat[phase].mat[comp]   = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
            PathStaticFirstDerG.mat[phase].mat[comp]    = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
        }
    }
    
    LagrangeStateFirstDerG   = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    LagrangeControlFirstDerG = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    LagrangeTimeFirstDerG    = getDoubleMatMatMat(PG);      // Allocate memory for number of phases in problem
    LagrangeStaticFirstDerG  = getDoubleMatMatMatMat(PG);   // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        LagrangeStateFirstDerG.mat[phase]    = getDoubleMatMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        LagrangeControlFirstDerG.mat[phase]  = getDoubleMatMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        LagrangeTimeFirstDerG.mat[phase]        = getDoubleMatMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        LagrangeStaticFirstDerG.mat[phase]   = getDoubleMatMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            LagrangeStateFirstDerG.mat[phase].mat[comp]     = getDoubleMatMat(nxG[phase]); // Allocate memory for number of state components in phase
            LagrangeControlFirstDerG.mat[phase].mat[comp]   = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
            LagrangeStaticFirstDerG.mat[phase].mat[comp]    = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
        }
    }
    
    ObjectiveInitStateInitStateSecondDerG   = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveInitStateFinalStateSecondDerG  = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveInitStateIntegralSecondDerG    = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveInitStateInitTimeSecondDerG    = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveInitStateFinalTimeSecondDerG   = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveInitStateStaticSecondDerG      = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveFinalStateFinalStateSecondDerG = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveFinalStateIntegralSecondDerG   = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveFinalStateInitTimeSecondDerG   = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveFinalStateFinalTimeSecondDerG  = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveFinalStateStaticSecondDerG     = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveIntegralIntegralSecondDerG     = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveIntegralInitTimeSecondDerG     = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveIntegralFinalTimeSecondDerG    = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveIntegralStaticSecondDerG       = getDoubleMatMatMat(PG);   // Allocate memory for number of phases in problem
    ObjectiveInitTimeInitTimeSecondDerG     = getDoubleMat(PG);         // Allocate memory for number of phases in problem
    ObjectiveInitTimeFinalTimeSecondDerG    = getDoubleMat(PG);         // Allocate memory for number of phases in problem
    ObjectiveInitTimeStaticSecondDerG       = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveFinalTimeFinalTimeSecondDerG   = getDoubleMat(PG);         // Allocate memory for number of phases in problem
    ObjectiveFinalTimeStaticSecondDerG      = getDoubleMatMat(PG);      // Allocate memory for number of phases in problem
    ObjectiveStaticStaticSecondDerG         = getDoubleMatMatMat(1);   // Allocate memory for number of phases in problem
    
    ObjectiveInitStateInitStateDependG      = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveInitStateFinalStateDependG     = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveInitStateIntegralDependG       = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveInitStateInitTimeDependG       = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveInitStateFinalTimeDependG      = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveInitStateStaticDependG         = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveFinalStateFinalStateDependG    = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveFinalStateIntegralDependG      = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveFinalStateInitTimeDependG      = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveFinalStateFinalTimeDependG     = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveFinalStateStaticDependG        = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveIntegralIntegralDependG        = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveIntegralInitTimeDependG        = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveIntegralFinalTimeDependG       = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveIntegralStaticDependG          = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
    ObjectiveInitTimeInitTimeDependG        = getIntMat(PG);        // Allocate memory for number of phases in problem
    ObjectiveInitTimeFinalTimeDependG       = getIntMat(PG);        // Allocate memory for number of phases in problem
    ObjectiveInitTimeStaticDependG          = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveFinalTimeFinalTimeDependG      = getIntMat(PG);        // Allocate memory for number of phases in problem
    ObjectiveFinalTimeStaticDependG         = getIntMatMat(PG);     // Allocate memory for number of phases in problem
    ObjectiveStaticStaticDependG            = getIntMatMatMat(1);  // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        ObjectiveInitStateInitStateSecondDerG.mat[phase]   = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateFinalStateSecondDerG.mat[phase]  = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateIntegralSecondDerG.mat[phase]    = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateInitTimeSecondDerG.mat[phase]       = getDoubleMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveInitStateFinalTimeSecondDerG.mat[phase]      = getDoubleMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveInitStateStaticSecondDerG.mat[phase]      = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateFinalStateSecondDerG.mat[phase] = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateIntegralSecondDerG.mat[phase]   = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateInitTimeSecondDerG.mat[phase]      = getDoubleMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveFinalStateFinalTimeSecondDerG.mat[phase]     = getDoubleMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveFinalStateStaticSecondDerG.mat[phase]     = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveIntegralIntegralSecondDerG.mat[phase]     = getDoubleMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        ObjectiveIntegralInitTimeSecondDerG.mat[phase]        = getDoubleMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        ObjectiveIntegralFinalTimeSecondDerG.mat[phase]       = getDoubleMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        ObjectiveIntegralStaticSecondDerG.mat[phase]       = getDoubleMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        ObjectiveInitTimeStaticSecondDerG.mat[phase]          = getDoubleMat(nsG);            // Allocate memory for number of static parameters in problem
        ObjectiveFinalTimeStaticSecondDerG.mat[phase]         = getDoubleMat(nsG);            // Allocate memory for number of static parameters in problem
        
        ObjectiveInitStateInitStateDependG.mat[phase]   = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateFinalStateDependG.mat[phase]  = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateIntegralDependG.mat[phase]    = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveInitStateInitTimeDependG.mat[phase]       = getIntMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveInitStateFinalTimeDependG.mat[phase]      = getIntMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveInitStateStaticDependG.mat[phase]      = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateFinalStateDependG.mat[phase] = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateIntegralDependG.mat[phase]   = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveFinalStateInitTimeDependG.mat[phase]      = getIntMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveFinalStateFinalTimeDependG.mat[phase]     = getIntMat(nxG[phase]);     // Allocate memory for number of state components in phase
        ObjectiveFinalStateStaticDependG.mat[phase]     = getIntMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
        ObjectiveIntegralIntegralDependG.mat[phase]     = getIntMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        ObjectiveIntegralInitTimeDependG.mat[phase]        = getIntMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        ObjectiveIntegralFinalTimeDependG.mat[phase]       = getIntMat(nqG[phase]);     // Allocate memory for number of integral components in phase
        ObjectiveIntegralStaticDependG.mat[phase]       = getIntMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
        ObjectiveInitTimeStaticDependG.mat[phase]          = getIntMat(nsG);            // Allocate memory for number of static parameters in problem
        ObjectiveFinalTimeStaticDependG.mat[phase]         = getIntMat(nsG);            // Allocate memory for number of static parameters in problem
        
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            ObjectiveInitStateInitStateSecondDerG.mat[phase].mat[comp]   = getDoubleMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveInitStateFinalStateSecondDerG.mat[phase].mat[comp]  = getDoubleMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveInitStateIntegralSecondDerG.mat[phase].mat[comp]    = getDoubleMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveInitStateStaticSecondDerG.mat[phase].mat[comp]      = getDoubleMat(nsG);        // Allocate memory for number of static parameters in problem
            ObjectiveFinalStateFinalStateSecondDerG.mat[phase].mat[comp] = getDoubleMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveFinalStateIntegralSecondDerG.mat[phase].mat[comp]   = getDoubleMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveFinalStateStaticSecondDerG.mat[phase].mat[comp]     = getDoubleMat(nsG);        // Allocate memory for number of static parameters in problem
            
            ObjectiveInitStateInitStateDependG.mat[phase].mat[comp]   = getIntMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveInitStateFinalStateDependG.mat[phase].mat[comp]  = getIntMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveInitStateIntegralDependG.mat[phase].mat[comp]    = getIntMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveInitStateStaticDependG.mat[phase].mat[comp]      = getIntMat(nsG);        // Allocate memory for number of static parameters in problem
            ObjectiveFinalStateFinalStateDependG.mat[phase].mat[comp] = getIntMat(nxG[phase]); // Allocate memory for number of state components in phase
            ObjectiveFinalStateIntegralDependG.mat[phase].mat[comp]   = getIntMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveFinalStateStaticDependG.mat[phase].mat[comp]     = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
        }
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            ObjectiveIntegralIntegralSecondDerG.mat[phase].mat[comp] = getDoubleMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveIntegralStaticSecondDerG.mat[phase].mat[comp]   = getDoubleMat(nsG);        // Allocate memory for number of static parameters in problem
            
            ObjectiveIntegralIntegralDependG.mat[phase].mat[comp] = getIntMat(nqG[phase]); // Allocate memory for number of integral components in phase
            ObjectiveIntegralStaticDependG.mat[phase].mat[comp]   = getIntMat(nsG);        // Allocate memory for number of static parameters in problem
        }
    }
    
    ObjectiveStaticStaticSecondDerG.mat[0] = getDoubleMatMat(nsG);         // Allocate memory for number of static parameters in problem
    ObjectiveStaticStaticDependG.mat[0] = getIntMatMat(nsG);         // Allocate memory for number of static parameters in problem
    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
    {
        ObjectiveStaticStaticSecondDerG.mat[0].mat[comp] = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
        ObjectiveStaticStaticDependG.mat[0].mat[comp] = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
    }
    
    EventInitStateInitStateSecondDerG   = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateFinalStateSecondDerG  = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateIntegralSecondDerG    = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateInitTimeSecondDerG    = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitStateFinalTimeSecondDerG   = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitStateStaticSecondDerG      = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateFinalStateSecondDerG = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventFinalStateIntegralSecondDerG   = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventFinalStateInitTimeSecondDerG   = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateFinalTimeSecondDerG  = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateStaticSecondDerG     = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralIntegralSecondDerG     = getDoubleMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventIntegralInitTimeSecondDerG     = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralFinalTimeSecondDerG    = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralStaticSecondDerG       = getDoubleMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitTimeInitTimeSecondDerG     = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventInitTimeFinalTimeSecondDerG    = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventInitTimeStaticSecondDerG       = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventFinalTimeFinalTimeSecondDerG   = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventFinalTimeStaticSecondDerG      = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventStaticStaticSecondDerG         = getDoubleMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    
    EventInitStateInitStateDependG   = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateFinalStateDependG  = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateIntegralDependG    = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventInitStateInitTimeDependG    = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitStateFinalTimeDependG   = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitStateStaticDependG      = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateFinalStateDependG = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventFinalStateIntegralDependG   = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventFinalStateInitTimeDependG   = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateFinalTimeDependG  = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventFinalStateStaticDependG     = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralIntegralDependG     = getIntMatMatMatMatMat(numEvent);   // Allocate memory for number of event constraints in problem
    EventIntegralInitTimeDependG     = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralFinalTimeDependG    = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventIntegralStaticDependG       = getIntMatMatMatMat(numEvent);      // Allocate memory for number of event constraints in problem
    EventInitTimeInitTimeDependG     = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventInitTimeFinalTimeDependG    = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventInitTimeStaticDependG       = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventFinalTimeFinalTimeDependG   = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventFinalTimeStaticDependG      = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    EventStaticStaticDependG         = getIntMatMatMat(numEvent);         // Allocate memory for number of event constraints in problem
    for (int event=0; event<numEvent; event++)  // For each event constraint in problem
    {
        EventInitStateInitStateSecondDerG.mat[event]     = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateFinalStateSecondDerG.mat[event]    = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateIntegralSecondDerG.mat[event]      = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateInitTimeSecondDerG.mat[event]         = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitStateFinalTimeSecondDerG.mat[event]        = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitStateStaticSecondDerG.mat[event]           = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateFinalStateSecondDerG.mat[event]   = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventFinalStateIntegralSecondDerG.mat[event]     = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventFinalStateInitTimeSecondDerG.mat[event]        = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateFinalTimeSecondDerG.mat[event]       = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateStaticSecondDerG.mat[event]          = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralIntegralSecondDerG.mat[event]       = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventIntegralInitTimeSecondDerG.mat[event]          = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralFinalTimeSecondDerG.mat[event]         = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralStaticSecondDerG.mat[event]            = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitTimeInitTimeSecondDerG.mat[event]             = getDoubleMatMat(PG);          // Allocate memory for number of phases in problem
        EventInitTimeFinalTimeSecondDerG.mat[event]            = getDoubleMatMat(PG);          // Allocate memory for number of phases in problem
        EventInitTimeStaticSecondDerG.mat[event]               = getDoubleMatMat(PG);          // Allocate memory for number of phases in problem
        EventFinalTimeFinalTimeSecondDerG.mat[event]           = getDoubleMatMat(PG);          // Allocate memory for number of phases in problem
        EventFinalTimeStaticSecondDerG.mat[event]              = getDoubleMatMat(PG);          // Allocate memory for number of phases in problem
        EventStaticStaticSecondDerG.mat[event]                 = getDoubleMatMat(nsG);         // Allocate memory for number of static parameters in problem
        
        EventInitStateInitStateDependG.mat[event]     = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateFinalStateDependG.mat[event]    = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateIntegralDependG.mat[event]      = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventInitStateInitTimeDependG.mat[event]         = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitStateFinalTimeDependG.mat[event]        = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitStateStaticDependG.mat[event]           = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateFinalStateDependG.mat[event]   = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventFinalStateIntegralDependG.mat[event]     = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventFinalStateInitTimeDependG.mat[event]        = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateFinalTimeDependG.mat[event]       = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventFinalStateStaticDependG.mat[event]          = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralIntegralDependG.mat[event]       = getIntMatMatMatMat(PG);    // Allocate memory for number of phases in problem
        EventIntegralInitTimeDependG.mat[event]          = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralFinalTimeDependG.mat[event]         = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventIntegralStaticDependG.mat[event]            = getIntMatMatMat(PG);       // Allocate memory for number of phases in problem
        EventInitTimeInitTimeDependG.mat[event]             = getIntMatMat(PG);          // Allocate memory for number of phases in problem
        EventInitTimeFinalTimeDependG.mat[event]            = getIntMatMat(PG);          // Allocate memory for number of phases in problem
        EventInitTimeStaticDependG.mat[event]               = getIntMatMat(PG);          // Allocate memory for number of phases in problem
        EventFinalTimeFinalTimeDependG.mat[event]           = getIntMatMat(PG);          // Allocate memory for number of phases in problem
        EventFinalTimeStaticDependG.mat[event]              = getIntMatMat(PG);          // Allocate memory for number of phases in problem
        EventStaticStaticDependG.mat[event]                 = getIntMatMat(nsG);         // Allocate memory for number of static parameters in problem
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            EventInitStateInitStateSecondDerG.mat[event].mat[phase]      = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateFinalStateSecondDerG.mat[event].mat[phase]     = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateIntegralSecondDerG.mat[event].mat[phase]       = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateInitTimeSecondDerG.mat[event].mat[phase]             = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventInitStateFinalTimeSecondDerG.mat[event].mat[phase]            = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventInitStateStaticSecondDerG.mat[event].mat[phase]               = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateFinalStateSecondDerG.mat[event].mat[phase]    = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventFinalStateIntegralSecondDerG.mat[event].mat[phase]      = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventFinalStateInitTimeSecondDerG.mat[event].mat[phase]            = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateFinalTimeSecondDerG.mat[event].mat[phase]           = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateStaticSecondDerG.mat[event].mat[phase]              = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            
            EventInitStateInitStateDependG.mat[event].mat[phase]      = getIntMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateFinalStateDependG.mat[event].mat[phase]     = getIntMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateIntegralDependG.mat[event].mat[phase]       = getIntMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventInitStateInitTimeDependG.mat[event].mat[phase]             = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventInitStateFinalTimeDependG.mat[event].mat[phase]            = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventInitStateStaticDependG.mat[event].mat[phase]               = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateFinalStateDependG.mat[event].mat[phase]    = getIntMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventFinalStateIntegralDependG.mat[event].mat[phase]      = getIntMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            EventFinalStateInitTimeDependG.mat[event].mat[phase]            = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateFinalTimeDependG.mat[event].mat[phase]           = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            EventFinalStateStaticDependG.mat[event].mat[phase]              = getIntMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                EventInitStateInitStateSecondDerG.mat[event].mat[phase].mat[comp]   = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                EventInitStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp]  = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                EventInitStateIntegralSecondDerG.mat[event].mat[phase].mat[comp]    = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                EventFinalStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp] = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                EventFinalStateIntegralSecondDerG.mat[event].mat[phase].mat[comp]   = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                
                EventInitStateInitStateDependG.mat[event].mat[phase].mat[comp]   = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                EventInitStateFinalStateDependG.mat[event].mat[phase].mat[comp]  = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                EventInitStateIntegralDependG.mat[event].mat[phase].mat[comp]    = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                EventFinalStateFinalStateDependG.mat[event].mat[phase].mat[comp] = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                EventFinalStateIntegralDependG.mat[event].mat[phase].mat[comp]   = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    EventInitStateInitStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2]     = getDoubleMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventInitStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2]    = getDoubleMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventInitStateIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2]      = getDoubleMat(nqG[phase2]);    // Allocate memory for number of integral components in phase2
                    EventFinalStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2]   = getDoubleMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventFinalStateIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2]     = getDoubleMat(nqG[phase2]);    // Allocate memory for number of integral components in phase2
                    
                    EventInitStateInitStateDependG.mat[event].mat[phase].mat[comp].mat[phase2]     = getIntMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventInitStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2]    = getIntMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventInitStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2]      = getIntMat(nqG[phase2]);    // Allocate memory for number of integral components in phase2
                    EventFinalStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2]   = getIntMat(nxG[phase2]);    // Allocate memory for number of state components in phase2
                    EventFinalStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2]     = getIntMat(nqG[phase2]);    // Allocate memory for number of integral components in phase2
                }
                EventInitStateInitTimeSecondDerG.mat[event].mat[phase].mat[comp]     = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventInitStateFinalTimeSecondDerG.mat[event].mat[phase].mat[comp]    = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventInitStateStaticSecondDerG.mat[event].mat[phase].mat[comp]       = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
                EventFinalStateInitTimeSecondDerG.mat[event].mat[phase].mat[comp]    = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventFinalStateFinalTimeSecondDerG.mat[event].mat[phase].mat[comp]   = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventFinalStateStaticSecondDerG.mat[event].mat[phase].mat[comp]      = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
                
                EventInitStateInitTimeDependG.mat[event].mat[phase].mat[comp]     = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventInitStateFinalTimeDependG.mat[event].mat[phase].mat[comp]    = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventInitStateStaticDependG.mat[event].mat[phase].mat[comp]       = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
                EventFinalStateInitTimeDependG.mat[event].mat[phase].mat[comp]    = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventFinalStateFinalTimeDependG.mat[event].mat[phase].mat[comp]   = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventFinalStateStaticDependG.mat[event].mat[phase].mat[comp]      = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
            }
            EventIntegralIntegralSecondDerG.mat[event].mat[phase]    = getDoubleMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
            EventIntegralInitTimeSecondDerG.mat[event].mat[phase]          = getDoubleMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            EventIntegralFinalTimeSecondDerG.mat[event].mat[phase]         = getDoubleMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            EventIntegralStaticSecondDerG.mat[event].mat[phase]            = getDoubleMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            
            EventIntegralIntegralDependG.mat[event].mat[phase]    = getIntMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
            EventIntegralInitTimeDependG.mat[event].mat[phase]          = getIntMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            EventIntegralFinalTimeDependG.mat[event].mat[phase]         = getIntMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            EventIntegralStaticDependG.mat[event].mat[phase]            = getIntMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                EventIntegralIntegralSecondDerG.mat[event].mat[phase].mat[comp] = getDoubleMatMat(PG);  // Allocate memory for number of phases in problem
                
                EventIntegralIntegralDependG.mat[event].mat[phase].mat[comp] = getIntMatMat(PG);  // Allocate memory for number of phases in problem
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    EventIntegralIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2] = getDoubleMat(nqG[phase2]);  // Allocate memory for number of integral components in phase2
                    
                    EventIntegralIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2] = getIntMat(nqG[phase2]);  // Allocate memory for number of integral components in phase2
                }
                EventIntegralInitTimeSecondDerG.mat[event].mat[phase].mat[comp]          = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventIntegralFinalTimeSecondDerG.mat[event].mat[phase].mat[comp]         = getDoubleMat(PG);     // Allocate memory for number of phases in problem
                EventIntegralStaticSecondDerG.mat[event].mat[phase].mat[comp]            = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
                
                EventIntegralInitTimeDependG.mat[event].mat[phase].mat[comp]          = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventIntegralFinalTimeDependG.mat[event].mat[phase].mat[comp]         = getIntMat(PG);     // Allocate memory for number of phases in problem
                EventIntegralStaticDependG.mat[event].mat[phase].mat[comp]            = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
            }
            EventInitTimeInitTimeSecondDerG.mat[event].mat[phase]                = getDoubleMat(PG);     // Allocate memory for number of phases in problem
            EventInitTimeFinalTimeSecondDerG.mat[event].mat[phase]               = getDoubleMat(PG);     // Allocate memory for number of phases in problem
            EventInitTimeStaticSecondDerG.mat[event].mat[phase]                  = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
            EventFinalTimeFinalTimeSecondDerG.mat[event].mat[phase]              = getDoubleMat(PG);     // Allocate memory for number of phases in problem
            EventFinalTimeStaticSecondDerG.mat[event].mat[phase]                 = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
            
            EventInitTimeInitTimeDependG.mat[event].mat[phase]                = getIntMat(PG);     // Allocate memory for number of phases in problem
            EventInitTimeFinalTimeDependG.mat[event].mat[phase]               = getIntMat(PG);     // Allocate memory for number of phases in problem
            EventInitTimeStaticDependG.mat[event].mat[phase]                  = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
            EventFinalTimeFinalTimeDependG.mat[event].mat[phase]              = getIntMat(PG);     // Allocate memory for number of phases in problem
            EventFinalTimeStaticDependG.mat[event].mat[phase]                 = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
        }
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            EventStaticStaticSecondDerG.mat[event].mat[comp] = getDoubleMat(nsG);    // Allocate memory for number of static parameters in problem
            
            EventStaticStaticDependG.mat[event].mat[comp] = getIntMat(nsG);    // Allocate memory for number of static parameters in problem
        }
    }
    
    DynamicStateStateSecondDerG     = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicStateControlSecondDerG   = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicStateTimeSecondDerG      = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicStateStaticSecondDerG    = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicControlControlSecondDerG = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicControlTimeSecondDerG    = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicControlStaticSecondDerG  = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicTimeTimeSecondDerG       = getDoubleMatMatMat(PG);       // Allocate memory for number of phases in problem
    DynamicTimeStaticSecondDerG     = getDoubleMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicStaticStaticSecondDerG   = getDoubleMatMatMatMatMat(PG); // Allocate memory for number of phases in problem
    
    DynamicStateStateDependG     = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicStateControlDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicStateTimeDependG      = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicStateStaticDependG    = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicControlControlDependG = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicControlTimeDependG    = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicControlStaticDependG  = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    DynamicTimeTimeDependG       = getIntMatMat(PG);       // Allocate memory for number of phases in problem
    DynamicTimeStaticDependG     = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    DynamicStaticStaticDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        DynamicStateStateSecondDerG.mat[phase]       = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicStateControlSecondDerG.mat[phase]     = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicStateTimeSecondDerG.mat[phase]           = getDoubleMatMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicStateStaticSecondDerG.mat[phase]      = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicControlControlSecondDerG.mat[phase]   = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicControlTimeSecondDerG.mat[phase]         = getDoubleMatMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicControlStaticSecondDerG.mat[phase]    = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicTimeTimeSecondDerG.mat[phase]               = getDoubleMatMat(nxG[phase]);          // Allocate memory for number of state components in phase
        DynamicTimeStaticSecondDerG.mat[phase]          = getDoubleMatMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicStaticStaticSecondDerG.mat[phase]     = getDoubleMatMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        
        DynamicStateStateDependG.mat[phase]       = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicStateControlDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicStateTimeDependG.mat[phase]           = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicStateStaticDependG.mat[phase]      = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicControlControlDependG.mat[phase]   = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicControlTimeDependG.mat[phase]         = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicControlStaticDependG.mat[phase]    = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        DynamicTimeTimeDependG.mat[phase]               = getIntMat(nxG[phase]);          // Allocate memory for number of state components in phase
        DynamicTimeStaticDependG.mat[phase]          = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        DynamicStaticStaticDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            DynamicStateStateSecondDerG.mat[phase].mat[comp]     = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            DynamicStateControlSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            DynamicStateTimeSecondDerG.mat[phase].mat[comp]            = getDoubleMatMat(nxG[phase]);      // Allocate memory for number of state components in phase
            DynamicStateStaticSecondDerG.mat[phase].mat[comp]    = getDoubleMatMatMat(nxG[phase]);   // Allocate memory for number of state components in phase

            DynamicStateStateDependG.mat[phase].mat[comp]     = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            DynamicStateControlDependG.mat[phase].mat[comp]   = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            DynamicStateTimeDependG.mat[phase].mat[comp]            = getIntMat(nxG[phase]);      // Allocate memory for number of state components in phase
            DynamicStateStaticDependG.mat[phase].mat[comp]    = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2]     = getDoubleMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
                DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2]   = getDoubleMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
                DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2]    = getDoubleMatMat(nsG);         // Allocate memory for number of static parameters in problem
                
                DynamicStateStateDependG.mat[phase].mat[comp].mat[comp2]     = getIntMat(nxG[phase]);  // Allocate memory for number of state components in phase
                DynamicStateControlDependG.mat[phase].mat[comp].mat[comp2]   = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                DynamicStateStaticDependG.mat[phase].mat[comp].mat[comp2]    = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            DynamicControlControlSecondDerG.mat[phase].mat[comp] = getDoubleMatMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            DynamicControlTimeSecondDerG.mat[phase].mat[comp]          = getDoubleMatMat(nuG[phase]);      // Allocate memory for number of control components in phase
            DynamicControlStaticSecondDerG.mat[phase].mat[comp]  = getDoubleMatMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            
            DynamicControlControlDependG.mat[phase].mat[comp] = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            DynamicControlTimeDependG.mat[phase].mat[comp]          = getIntMat(nuG[phase]);      // Allocate memory for number of control components in phase
            DynamicControlStaticDependG.mat[phase].mat[comp]  = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
                DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2]  = getDoubleMatMat(nsG);         // Allocate memory for number of static parameters in problem
                
                DynamicControlControlDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                DynamicControlStaticDependG.mat[phase].mat[comp].mat[comp2]  = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            DynamicTimeStaticSecondDerG.mat[phase].mat[comp]           = getDoubleMatMat(nsG);     // Allocate memory for number of static parameters in problem
            DynamicStaticStaticSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nsG);  // Allocate memory for number of static parameters in problem
            
            DynamicTimeStaticDependG.mat[phase].mat[comp]           = getIntMat(nsG);     // Allocate memory for number of static parameters in problem
            DynamicStaticStaticDependG.mat[phase].mat[comp]   = getIntMatMat(nsG);  // Allocate memory for number of static parameters in problem
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nsG);   // Allocate memory for number of static parameters in problem
                
                DynamicStaticStaticDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nsG);   // Allocate memory for number of static parameters in problem
            }
        }
    }
    
    PathStateStateSecondDerG     = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathStateControlSecondDerG   = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathStateTimeSecondDerG      = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    PathStateStaticSecondDerG    = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathControlControlSecondDerG = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathControlTimeSecondDerG    = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    PathControlStaticSecondDerG  = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathTimeTimeSecondDerG       = getDoubleMatMatMat(PG);          // Allocate memory for number of phases in problem
    PathTimeStaticSecondDerG     = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    PathStaticStaticSecondDerG   = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    
    PathStateStateDependG     = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    PathStateControlDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    PathStateTimeDependG      = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathStateStaticDependG    = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    PathControlControlDependG = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    PathControlTimeDependG    = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathControlStaticDependG  = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    PathTimeTimeDependG       = getIntMatMat(PG);       // Allocate memory for number of phases in problem
    PathTimeStaticDependG     = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    PathStaticStaticDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        PathStateStateSecondDerG.mat[phase]       = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        PathStateControlSecondDerG.mat[phase]     = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        PathStateTimeSecondDerG.mat[phase]           = getDoubleMatMatMat(ncG[phase]);      // Allocate memory for number of path constraints in phase
        PathStateStaticSecondDerG.mat[phase]      = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        PathControlControlSecondDerG.mat[phase]   = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        PathControlTimeSecondDerG.mat[phase]         = getDoubleMatMatMat(ncG[phase]);      // Allocate memory for number of path constraints in phase
        PathControlStaticSecondDerG.mat[phase]    = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        PathTimeTimeSecondDerG.mat[phase]               = getDoubleMatMat(ncG[phase]);         // Allocate memory for number of path constraints in phase
        PathTimeStaticSecondDerG.mat[phase]          = getDoubleMatMatMat(ncG[phase]);      // Allocate memory for number of path constraints in phase
        PathStaticStaticSecondDerG.mat[phase]     = getDoubleMatMatMatMat(ncG[phase]);   // Allocate memory for number of path constraints in phase
        
        PathStateStateDependG.mat[phase]       = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        PathStateControlDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        PathStateTimeDependG.mat[phase]           = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        PathStateStaticDependG.mat[phase]      = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        PathControlControlDependG.mat[phase]   = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        PathControlTimeDependG.mat[phase]         = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        PathControlStaticDependG.mat[phase]    = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        PathTimeTimeDependG.mat[phase]               = getIntMat(nxG[phase]);          // Allocate memory for number of state components in phase
        PathTimeStaticDependG.mat[phase]          = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        PathStaticStaticDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
            PathStateStateSecondDerG.mat[phase].mat[comp]     = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            PathStateControlSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            PathStateTimeSecondDerG.mat[phase].mat[comp]            = getDoubleMatMat(nxG[phase]);     // Allocate memory for number of state components in phase
            PathStateStaticSecondDerG.mat[phase].mat[comp]    = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            
            PathStateStateDependG.mat[phase].mat[comp]     = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            PathStateControlDependG.mat[phase].mat[comp]   = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            PathStateTimeDependG.mat[phase].mat[comp]            = getIntMat(nxG[phase]);      // Allocate memory for number of state components in phase
            PathStateStaticDependG.mat[phase].mat[comp]    = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2]     = getDoubleMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2]   = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
                PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2]    = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
                
                PathStateStateDependG.mat[phase].mat[comp].mat[comp2]     = getIntMat(nxG[phase]);  // Allocate memory for number of state components in phase
                PathStateControlDependG.mat[phase].mat[comp].mat[comp2]   = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                PathStateStaticDependG.mat[phase].mat[comp].mat[comp2]    = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            PathControlControlSecondDerG.mat[phase].mat[comp] = getDoubleMatMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
            PathControlTimeSecondDerG.mat[phase].mat[comp]          = getDoubleMatMat(nuG[phase]);     // Allocate memory for number of control components in phase
            PathControlStaticSecondDerG.mat[phase].mat[comp]  = getDoubleMatMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
            
            PathControlControlDependG.mat[phase].mat[comp] = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            PathControlTimeDependG.mat[phase].mat[comp]          = getIntMat(nuG[phase]);      // Allocate memory for number of control components in phase
            PathControlStaticDependG.mat[phase].mat[comp]  = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
                PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2]  = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
                
                PathControlControlDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                PathControlStaticDependG.mat[phase].mat[comp].mat[comp2]  = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            PathTimeStaticSecondDerG.mat[phase].mat[comp]           = getDoubleMatMat(nsG);    // Allocate memory for number of static parameters in problem
            PathStaticStaticSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nsG); // Allocate memory for number of static parameters in problem
            
            PathTimeStaticDependG.mat[phase].mat[comp]           = getIntMat(nsG);     // Allocate memory for number of static parameters in problem
            PathStaticStaticDependG.mat[phase].mat[comp]   = getIntMatMat(nsG);  // Allocate memory for number of static parameters in problem
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nsG);  // Allocate memory for number of static parameters in problem
                
                PathStaticStaticDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nsG);   // Allocate memory for number of static parameters in problem
            }
        }
    }
    
    LagrangeStateStateSecondDerG     = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeStateControlSecondDerG   = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeStateTimeSecondDerG      = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    LagrangeStateStaticSecondDerG    = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeControlControlSecondDerG = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeControlTimeSecondDerG    = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    LagrangeControlStaticSecondDerG  = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeTimeTimeSecondDerG       = getDoubleMatMatMat(PG);          // Allocate memory for number of phases in problem
    LagrangeTimeStaticSecondDerG     = getDoubleMatMatMatMat(PG);       // Allocate memory for number of phases in problem
    LagrangeStaticStaticSecondDerG   = getDoubleMatMatMatMatMat(PG);    // Allocate memory for number of phases in problem
    
    LagrangeStateStateDependG     = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    LagrangeStateControlDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    LagrangeStateTimeDependG      = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeStateStaticDependG    = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    LagrangeControlControlDependG = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    LagrangeControlTimeDependG    = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeControlStaticDependG  = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    LagrangeTimeTimeDependG       = getIntMatMat(PG);       // Allocate memory for number of phases in problem
    LagrangeTimeStaticDependG     = getIntMatMatMat(PG);    // Allocate memory for number of phases in problem
    LagrangeStaticStaticDependG   = getIntMatMatMatMat(PG); // Allocate memory for number of phases in problem
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        LagrangeStateStateSecondDerG.mat[phase]       = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        LagrangeStateControlSecondDerG.mat[phase]     = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        LagrangeStateTimeSecondDerG.mat[phase]           = getDoubleMatMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
        LagrangeStateStaticSecondDerG.mat[phase]      = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        LagrangeControlControlSecondDerG.mat[phase]   = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        LagrangeControlTimeSecondDerG.mat[phase]         = getDoubleMatMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
        LagrangeControlStaticSecondDerG.mat[phase]    = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        LagrangeTimeTimeSecondDerG.mat[phase]               = getDoubleMatMat(nqG[phase]);         // Allocate memory for number of integral components in phase
        LagrangeTimeStaticSecondDerG.mat[phase]          = getDoubleMatMatMat(nqG[phase]);      // Allocate memory for number of integral components in phase
        LagrangeStaticStaticSecondDerG.mat[phase]     = getDoubleMatMatMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase
        
        LagrangeStateStateDependG.mat[phase]       = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LagrangeStateControlDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LagrangeStateTimeDependG.mat[phase]           = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        LagrangeStateStaticDependG.mat[phase]      = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LagrangeControlControlDependG.mat[phase]   = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LagrangeControlTimeDependG.mat[phase]         = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        LagrangeControlStaticDependG.mat[phase]    = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        LagrangeTimeTimeDependG.mat[phase]               = getIntMat(nxG[phase]);          // Allocate memory for number of state components in phase
        LagrangeTimeStaticDependG.mat[phase]          = getIntMatMat(nxG[phase]);       // Allocate memory for number of state components in phase
        LagrangeStaticStaticDependG.mat[phase]     = getIntMatMatMat(nxG[phase]);    // Allocate memory for number of state components in phase
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            LagrangeStateStateSecondDerG.mat[phase].mat[comp]     = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            LagrangeStateControlSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            LagrangeStateTimeSecondDerG.mat[phase].mat[comp]            = getDoubleMatMat(nxG[phase]);     // Allocate memory for number of state components in phase
            LagrangeStateStaticSecondDerG.mat[phase].mat[comp]    = getDoubleMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase
            
            LagrangeStateStateDependG.mat[phase].mat[comp]     = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            LagrangeStateControlDependG.mat[phase].mat[comp]   = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            LagrangeStateTimeDependG.mat[phase].mat[comp]            = getIntMat(nxG[phase]);      // Allocate memory for number of state components in phase
            LagrangeStateStaticDependG.mat[phase].mat[comp]    = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2]     = getDoubleMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2]   = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
                LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2]    = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
                
                LagrangeStateStateDependG.mat[phase].mat[comp].mat[comp2]     = getIntMat(nxG[phase]);  // Allocate memory for number of state components in phase
                LagrangeStateControlDependG.mat[phase].mat[comp].mat[comp2]   = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                LagrangeStateStaticDependG.mat[phase].mat[comp].mat[comp2]    = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            LagrangeControlControlSecondDerG.mat[phase].mat[comp] = getDoubleMatMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
            LagrangeControlTimeSecondDerG.mat[phase].mat[comp]          = getDoubleMatMat(nuG[phase]);     // Allocate memory for number of control components in phase
            LagrangeControlStaticSecondDerG.mat[phase].mat[comp]  = getDoubleMatMatMat(nuG[phase]);  // Allocate memory for number of control components in phase
            
            LagrangeControlControlDependG.mat[phase].mat[comp] = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            LagrangeControlTimeDependG.mat[phase].mat[comp]          = getIntMat(nuG[phase]);      // Allocate memory for number of control components in phase
            LagrangeControlStaticDependG.mat[phase].mat[comp]  = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nuG[phase]); // Allocate memory for number of control components in phase
                LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2]  = getDoubleMatMat(nsG);        // Allocate memory for number of static parameters in problem
                
                LagrangeControlControlDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nuG[phase]);  // Allocate memory for number of control components in phase
                LagrangeControlStaticDependG.mat[phase].mat[comp].mat[comp2]  = getIntMat(nsG);         // Allocate memory for number of static parameters in problem
            }
            LagrangeTimeStaticSecondDerG.mat[phase].mat[comp]           = getDoubleMatMat(nsG);    // Allocate memory for number of static parameters in problem
            LagrangeStaticStaticSecondDerG.mat[phase].mat[comp]   = getDoubleMatMatMat(nsG); // Allocate memory for number of static parameters in problem
            
            LagrangeTimeStaticDependG.mat[phase].mat[comp]           = getIntMat(nsG);     // Allocate memory for number of static parameters in problem
            LagrangeStaticStaticDependG.mat[phase].mat[comp]   = getIntMatMat(nsG);  // Allocate memory for number of static parameters in problem
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMatMat(nsG);  // Allocate memory for number of static parameters in problem
                
                LagrangeStaticStaticDependG.mat[phase].mat[comp].mat[comp2] = getIntMat(nsG);   // Allocate memory for number of static parameters in problem
            }
        }
    }
}

void initDerivativeVars(void)   // Allocate memory for structures to hold derivative values at each point in phase
{
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        ptMatMatDub.mat[phase]    = getDoubleMat(NtG[phase]+1);       // Allocate memory for number of discretization points used in phase
        ptMatMatBC.mat[phase]  = getBicomplexMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
        ptMatMatHD.mat[phase]  = getHyperDualMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase

        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                DynamicFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of state components in phase
                DefectFuncValG.mat[phase].mat[comp]  = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of state components in phase
            }
            for (int comp=0; comp<ncG[phase]; comp++)   // For each state component in phase
            {
                PathFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of state components in phase
            }
            for (int comp=0; comp<nqG[phase]; comp++)   // For each state component in phase
            {
                LagrangeFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of state components in phase
            }
        }
    }
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
//            if (DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1)  // If dynamic comp in phase is dependent on time
//            {
                DynamicTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1) // If dynamic comp in phase is dependent on state comp2
//                {
                    DynamicStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (DynamicControlDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If dynamic comp in phase is dependent on control comp2
//                {
                    DynamicControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (DynamicStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If dynamic comp in phase is dependent on static comp2
//                {
                    DynamicStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
//            if (PathTimeDependMapG.mat[phase].mat[comp].val[0]==1) // If path comp in phase is dependent on time
//            {
                PathTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If path comp in phase is dependent on state comp2
//                {
                    PathStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (PathControlDependMapG.mat[phase].mat[comp].val[comp2]==1)  // If path comp in phase is dependent on control comp2
//                {
                    PathControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (PathStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If path comp in phase is dependent on static comp2
//                {
                    PathStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
//            if (LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1) // If lagrange comp in phase is dependent on time
//            {
                LagrangeTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If lagrange comp in phase is dependent on state comp2
//                {
                    LagrangeStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (LagrangeControlDependMapG.mat[phase].mat[comp].val[comp2]==1)  // If lagrange comp in phase is dependent on control comp2
//                {
                    LagrangeControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If lagrange comp in phase is dependent on static comp2
//                {
                    LagrangeStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if ((DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1))  // If dynamic comp in phase is dependent on state comp2 and time
                {
                    DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    
                    DynamicStateTimeDependG.mat[phase].mat[comp].val[comp2] = 1;   // Indicate dynamic function comp is dependent on state comp2 and time in phase
                }
                else
                {
                    DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if ((DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicStateDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If dynamic comp in phase is dependent on state comp2 and state comp3
                    {
                        DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                        
                        DynamicStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate dynamic function comp is dependent on state comp2 and state comp3 in phase
                    }
                    else
                    {
                        DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicControlDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If dynamic comp in phase is dependent on state comp2 and control comp3
                    {
                        DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                        
                        DynamicStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate dynamic function comp is dependent on state comp2 and control comp3 in phase
                    }
                    else
                    {
                        DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))    // If dynamic comp in phase is dependent on state comp2 and static comp3
                    {
                        DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                        
                        DynamicStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1; // Indicate dynamic function comp is dependent on state comp2 and static comp3 in phase
                    }
                    else
                    {
                        DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if ((DynamicControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1))    // If dynamic comp in phase is dependent on control comp2 and time
                {
                    DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    
                    DynamicControlTimeDependG.mat[phase].mat[comp].val[comp2] = 1; // Indicate dynamic function comp is dependent on control comp2 and time in phase
                }
                else
                {
                    DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((DynamicControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicControlDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If dynamic comp in phase is dependent on control comp2 and control comp3
                    {
                        DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                        
                        DynamicControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate dynamic function comp is dependent on control comp2 and control comp3 in phase
                    }
                    else
                    {
                        DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((DynamicControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))  // If dynamic comp in phase is dependent on control comp2 and static comp3
                    {
                        DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                        
                        DynamicControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;   // Indicate dynamic function comp is dependent on control comp2 and static comp3 in phase
                    }
                    else
                    {
                        DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((DynamicStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1)) // If dynamic comp in phase is dependent on static comp2 and time
                {
                    DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    
                    DynamicTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate dynamic function comp is dependent on static comp2 and time in phase
                }
                else
                {
                    DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((DynamicStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(DynamicStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If dynamic comp in phase is dependent on static comp2 and static comp3
                    {
                        DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                        
                        DynamicStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate dynamic function comp is dependent on static comp2 and static comp3 in phase
                    }
                    else
                    {
                        DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1)  // If dynamic comp in phase is dependent on time
            {
                DynamicTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                
                DynamicTimeTimeDependG.mat[phase].val[comp] = 1; // Indicate dynamic function comp is dependent on time and time in phase
            }
            else
            {
                DynamicTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if ((PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathTimeDependMapG.mat[phase].mat[comp].val[0]==1))    // If path comp in phase is dependent on state comp2 and time
                {
                    PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    
                    PathStateTimeDependG.mat[phase].mat[comp].val[comp2] = 1;   // Indicate Path function comp is dependent on state comp2 and time in phase
                }
                else
                {
                    PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if ((PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathStateDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If path comp in phase is dependent on state comp2 and state comp3
                    {
                        PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                        
                        PathStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate Path function comp is dependent on state comp2 and state comp3 in phase
                    }
                    else
                    {
                        PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathControlDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If path comp in phase is dependent on state comp2 and control comp3
                    {
                        PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                        
                        PathStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate Path function comp is dependent on state comp2 and control comp3 in phase
                    }
                    else
                    {
                        PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))  // If path comp in phase is dependent on state comp2 and static comp3
                    {
                        PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                        
                        PathStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1; // Indicate Path function comp is dependent on state comp2 and static comp3 in phase
                    }
                    else
                    {
                        PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if ((PathControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathTimeDependMapG.mat[phase].mat[comp].val[0]==1))  // If path comp in phase is dependent on control comp2 and time
                {
                    PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    
                    PathControlTimeDependG.mat[phase].mat[comp].val[comp2] = 1; // Indicate Path function comp is dependent on control comp2 and time in phase
                }
                else
                {
                    PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((PathControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathControlDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If path comp in phase is dependent on control comp2 and control comp3
                    {
                        PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                        
                        PathControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate Path function comp is dependent on control comp2 and control comp3 in phase
                    }
                    else
                    {
                        PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((PathControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))    // If path comp in phase is dependent on control comp2 and static comp3
                    {
                        PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                        
                        PathControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;   // Indicate Path function comp is dependent on control comp2 and static comp3 in phase
                    }
                    else
                    {
                        PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((PathStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathTimeDependMapG.mat[phase].mat[comp].val[0]==1))   // If path comp in phase is dependent on static comp2 and time
                {
                    PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    
                    PathTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate Path function comp is dependent on static comp2 and time in phase
                }
                else
                {
                    PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((PathStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(PathStaticDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If path comp in phase is dependent on static comp2 and static comp3
                    {
                        PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                        
                        PathStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate Path function comp is dependent on static comp2 and static comp3 in phase
                    }
                    else
                    {
                        PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (PathTimeDependMapG.mat[phase].mat[comp].val[0]==1) // If path comp in phase is dependent on time
            {
                PathTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                
                PathTimeTimeDependG.mat[phase].val[comp] = 1; // Indicate Path function comp is dependent on time and time in phase
            }
            else
            {
                PathTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if ((LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1))    // If lagrange comp in phase is dependent on state comp2 and time
                {
                    LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    
                    LagrangeStateTimeDependG.mat[phase].mat[comp].val[comp2] = 1;   // Indicate Lagrange function comp is dependent on state comp2 and time in phase
                }
                else
                {
                    LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if ((LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeStateDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If lagrange comp in phase is dependent on state comp2 and state comp3
                    {
                        LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                        
                        LagrangeStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate Lagrange function comp is dependent on state comp2 and state comp3 in phase
                    }
                    else
                    {
                        LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeControlDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If lagrange comp in phase is dependent on state comp2 and control comp3
                    {
                        LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                        
                        LagrangeStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate Lagrange function comp is dependent on state comp2 and control comp3 in phase
                    }
                    else
                    {
                        LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))  // If lagrange comp in phase is dependent on state comp2 and static comp3
                    {
                        LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                        
                        LagrangeStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1; // Indicate Lagrange function comp is dependent on state comp2 and static comp3 in phase
                    }
                    else
                    {
                        LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if ((LagrangeControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1))  // If lagrange comp in phase is dependent on control comp2 and time
                {
                    LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    
                    LagrangeControlTimeDependG.mat[phase].mat[comp].val[comp2] = 1; // Indicate Lagrange function comp is dependent on control comp2 and time in phase
                }
                else
                {
                    LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if ((LagrangeControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeControlDependMapG.mat[phase].mat[comp].val[comp3]==1))   // If lagrange comp in phase is dependent on control comp2 and control comp3
                    {
                        LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                        
                        LagrangeControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;  // Indicate Lagrange function comp is dependent on control comp2 and control comp3 in phase
                    }
                    else
                    {
                        LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((LagrangeControlDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp3]==1))    // If lagrange comp in phase is dependent on control comp2 and static comp3
                    {
                        LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                        
                        LagrangeControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;   // Indicate Lagrange function comp is dependent on control comp2 and static comp3 in phase
                    }
                    else
                    {
                        LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1))   // If lagrange comp in phase is dependent on static comp2 and time
                {
                    LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    
                    LagrangeTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate Lagrange function comp is dependent on static comp2 and time in phase
                }
                else
                {
                    LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if ((LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)&&(LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp3]==1)) // If lagrange comp in phase is dependent on static comp2 and static comp3
                    {
                        LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                        
                        LagrangeStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 1;    // Indicate Lagrange function comp is dependent on static comp2 and static comp3 in phase
                    }
                    else
                    {
                        LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1)
            {
                LagrangeTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                
                LagrangeTimeTimeDependG.mat[phase].val[comp] = 1; // Indicate Lagrange function comp is dependent on time and time in phase
            }
            else
            {
                LagrangeTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveInitStateDependMapG.mat[phase].val[comp2]))    // If objective function in phase is dependent on initial state comp and initial state comp2
                {
                    ObjectiveInitStateInitStateDependG.mat[phase].mat[comp].val[comp2] = 1;    // Indicate objective function is dependent on initial state comp and initial state comp2 in phase
                }
                
                if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveFinalStateDependMapG.mat[phase].val[comp2]))   // If objective function in phase is dependent on initial state comp and final state comp2
                {
                    ObjectiveInitStateFinalStateDependG.mat[phase].mat[comp].val[comp2] = 1;   // Indicate objective function is dependent on initial state comp and final state comp2 in phase
                }
            }
            
            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each integral component in phase
            {
                if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveIntegralDependMapG.mat[phase].val[comp2])) // If objective function in phase is dependent on initial state comp and integral comp2
                {
                    ObjectiveInitStateIntegralDependG.mat[phase].mat[comp].val[comp2] = 1; // Indicate objective function is dependent on initial state comp and integral comp2 in phase
                }
            }
            
            if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveInitTimeDependMapG.mat[phase].val[0])) // If objective function in phase is dependent on initial state comp and initial time
            {
                ObjectiveInitStateInitTimeDependG.mat[phase].val[comp] = 1;  // Indicate objective function is dependent on initial state comp and initial time in phase
            }
            
            if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveFinalTimeDependMapG.mat[phase].val[0]))    // If objective function in phase is dependent on initial state comp and final time
            {
                ObjectiveInitStateFinalTimeDependG.mat[phase].val[comp] = 1; // Indicate objective function is dependent on initial state comp and final time in phase
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
            {
                if ((ObjectiveInitStateDependMapG.mat[phase].val[comp])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))   // If objective function in phase is dependent on initial state comp and static comp2
                {
                    ObjectiveInitStateStaticDependG.mat[phase].mat[comp].val[comp2] = 1;   // Indicate objective function is dependent on initial state comp and static comp2 in phase
                }
            }
        }
        
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if ((ObjectiveFinalStateDependMapG.mat[phase].val[comp])&&(ObjectiveFinalStateDependMapG.mat[phase].val[comp2]))  // If objective function in phase is dependent on final state comp and final state comp2
                {
                    ObjectiveFinalStateFinalStateDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate objective function is dependent on final state comp and final state comp2 in phase
                }
            }
            
            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each integral component in phase
            {
                if ((ObjectiveFinalStateDependMapG.mat[phase].val[comp])&&(ObjectiveIntegralDependMapG.mat[phase].val[comp2]))    // If objective function in phase is dependent on final state comp and integral comp2
                {
                    ObjectiveFinalStateIntegralDependG.mat[phase].mat[comp].val[comp2] = 1;    // Indicate objective function is dependent on final state comp and integral comp2 in phase
                }
            }
            
            if ((ObjectiveFinalStateDependMapG.mat[phase].val[comp])&&(ObjectiveInitTimeDependMapG.mat[phase].val[0]))    // If objective function in phase is dependent on final state comp and initial time
            {
                ObjectiveFinalStateInitTimeDependG.mat[phase].val[comp] = 1; // Indicate objective function is dependent on final state comp and initial time in phase
            }
            
            if ((ObjectiveFinalStateDependMapG.mat[phase].val[comp])&&(ObjectiveFinalTimeDependMapG.mat[phase].val[0]))   // If objective function in phase is dependent on final state comp and final time
            {
                ObjectiveFinalStateFinalTimeDependG.mat[phase].val[comp] = 1;    // Indicate objective function is dependent on final state comp and final time in phase
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
            {
                if ((ObjectiveFinalStateDependMapG.mat[phase].val[comp])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))  // If objective function in phase is dependent on final state comp and static comp2
                {
                    ObjectiveFinalStateStaticDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate objective function is dependent on final state comp and static comp2 in phase
                }
            }
        }
        
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each integral component in phase
            {
                if ((ObjectiveIntegralDependMapG.mat[phase].val[comp])&&(ObjectiveIntegralDependMapG.mat[phase].val[comp2]))  // If objective function in phase is dependent on integral comp and integral comp2
                {
                    ObjectiveIntegralIntegralDependG.mat[phase].mat[comp].val[comp2] = 1;  // Indicate objective function is dependent on integral comp and integral comp2 in phase
                }
            }
            
            if ((ObjectiveIntegralDependMapG.mat[phase].val[comp])&&(ObjectiveInitTimeDependMapG.mat[phase].val[0]))  // If objective function in phase is dependent on integral comp and initial time
            {
                ObjectiveIntegralInitTimeDependG.mat[phase].val[comp] = 1;   // Indicate objective function is dependent on integral comp and initial time in phase
            }
            
            if ((ObjectiveIntegralDependMapG.mat[phase].val[comp])&&(ObjectiveFinalTimeDependMapG.mat[phase].val[0])) // If objective function in phase is dependent on integral comp and final time
            {
                ObjectiveIntegralFinalTimeDependG.mat[phase].val[comp] = 1;  // Indicate objective function is dependent on integral comp and final time in phase
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
            {
                if ((ObjectiveIntegralDependMapG.mat[phase].val[comp])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))    // If objective function in phase is dependent on integral comp and static comp2
                {
                    ObjectiveIntegralStaticDependG.mat[phase].mat[comp].val[comp2] = 1;    // Indicate objective function is dependent on integral comp and static comp2 in phase
                }
            }
        }
        
        if (ObjectiveInitTimeDependMapG.mat[phase].val[0])   // If objective function in phase is dependent on initial time
        {
            ObjectiveInitTimeInitTimeDependG.val[phase] = 1;    // Indicate objective function is dependent on initial time in phase
        }
        
        if ((ObjectiveInitTimeDependMapG.mat[phase].val[0])&&(ObjectiveFinalTimeDependMapG.mat[phase].val[0]))    // If objective function in phase is dependent on initial time and final time
        {
            ObjectiveInitTimeFinalTimeDependG.val[phase] = 1;   // Indicate objective function is dependent on integral comp and final time in phase
        }
        
        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
        {
            if ((ObjectiveInitTimeDependMapG.mat[phase].val[0])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))   // If objective function in phase is dependent on initial time and static comp2
            {
                ObjectiveInitTimeStaticDependG.mat[phase].val[comp2] = 1;    // Indicate objective function is dependent on initial time and static comp2 in phase
            }
        }
        
        if (ObjectiveFinalTimeDependMapG.mat[phase].val[0])  // If objective function in phase is dependent on final time
        {
            ObjectiveFinalTimeFinalTimeDependG.val[phase] = 1;  // Indicate objective function is dependent on final time in phase
        }
        
        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
        {
            if ((ObjectiveFinalTimeDependMapG.mat[phase].val[0])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))  // If objective function in phase is dependent on final time and static comp2
            {
                ObjectiveFinalTimeStaticDependG.mat[phase].val[comp2] = 1;   // Indicate objective function is dependent on final time and static comp2 in phase
            }
        }
    }
    
    for (int comp=0; comp<nsG; comp++)  // For each static parameter in phase
    {
        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in phase
        {
            if ((ObjectiveStaticDependMapG.mat[0].val[comp])&&(ObjectiveStaticDependMapG.mat[0].val[comp2]))  // If objective function in phase is dependent on static comp and static comp2
            {
                ObjectiveStaticStaticDependG.mat[0].mat[comp].val[comp2] = 1;  // Indicate objective function is dependent on static comp and static comp2 in phase
            }
        }
    }
    
    int numEvent;   // Holder for total number of event constraints that are active
    if ((DurationFlagG)&&(ContinuityFlagG))   // If duration and continuity constraints are active
    {
        numEvent = nbG + PG + neG;    // Number of event constraints equals number defined by user plus duration constraints and continuity constraints
    }
    else if (DurationFlagG)   // If duration constraints are active
    {
        numEvent = nbG + PG;    // Number of event constraints equals number defined by user plus duration constraints
    }
    else if (ContinuityFlagG)   // If continuity constraints are active
    {
        numEvent = nbG + neG;    // Number of event constraints equals number defined by user plus continuity constraints
    }
    else
    {
        numEvent = nbG; // Number of event constraints equals number defined by user
    }
    for (int event=0; event<numEvent; event++)  // For each event in problem
    {
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    for (int comp2=0; comp2<nxG[phase2]; comp2++)   // For each state component in phase2
                    {
                        if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp]==1)&&(EventInitStateDependMapG.mat[phase2].mat[event].val[comp2]==1))   // If event is dependent on initial state comp in phase and initial state comp2 in phase2
                        {
                            EventInitStateInitStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1;    // Indicate event is dependent on initial state comp in phase and initial state comp2 in phase2
                        }
                        
                        if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp])&&(EventFinalStateDependMapG.mat[phase2].mat[event].val[comp2]))    // If event is dependent on initial state comp in phase and final state comp2 in phase2
                        {
                            EventInitStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1;   // Indicate event is dependent on initial state comp in phase and final state comp2 in phase2
                        }
                    }
                    
                    for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                    {
                        if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp])&&(EventIntegralDependMapG.mat[phase2].mat[event].val[comp2]))  // If event is dependent on initial state comp in phase and integral comp2 in phase2
                        {
                            EventInitStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1; // Indicate event is dependent on initial state comp in phase and integral comp2 in phase2
                        }
                    }
                    
                    if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp])&&(EventInitTimeDependMapG.mat[phase2].mat[event].val[0]))  // If event is dependent on initial state comp in phase and initial time in phase2
                    {
                        EventInitStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1;    // Indicate event is dependent on initial state comp in phase and initial time in phase2
                    }
                    
                    if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp])&&(EventFinalTimeDependMapG.mat[phase2].mat[event].val[0])) // If event is dependent on initial state comp in phase and final time in phase2
                    {
                        EventInitStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1;   // Indicate event is dependent on initial state comp in phase and final time in phase2
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if ((EventInitStateDependMapG.mat[phase].mat[event].val[comp])&&(EventStaticDependMapG.mat[event].val[comp2]))  // If event is dependent on initial state comp in phase and static comp2
                    {
                        EventInitStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 1;   // Indicate event is dependent on initial state comp in phase and static comp2
                    }
                }
            }
            
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    for (int comp2=0; comp2<nxG[phase2]; comp2++)   // For each state component in phase2
                    {
                        if ((EventFinalStateDependMapG.mat[phase].mat[event].val[comp])&&(EventFinalStateDependMapG.mat[phase2].mat[event].val[comp2]))   // If event is dependent on final state comp in phase and final state comp2 in phase2
                        {
                            EventFinalStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1;  // Indicate event is dependent on final state comp in phase and final state comp2 in phase2
                        }
                    }
                    
                    for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                    {
                        if ((EventFinalStateDependMapG.mat[phase].mat[event].val[comp])&&(EventIntegralDependMapG.mat[phase2].mat[event].val[comp2])) // If event is dependent on final state comp in phase and integral comp2 in phase2
                        {
                            EventFinalStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1;    // Indicate event is dependent on final state comp in phase and integral comp2 in phase2
                        }
                    }
                    
                    if ((EventFinalStateDependMapG.mat[phase].mat[event].val[comp])&&(EventInitTimeDependMapG.mat[phase2].mat[event].val[0])) // If event is dependent on final state comp in phase and initial time in phase2
                    {
                        EventFinalStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1;   // Indicate event is dependent on final state comp in phase and initial time in phase2
                    }
                    
                    if ((EventFinalStateDependMapG.mat[phase].mat[event].val[comp])&&(EventFinalTimeDependMapG.mat[phase2].mat[event].val[0]))    // If event is dependent on final state comp in phase and final time in phase2
                    {
                        EventFinalStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1;  // Indicate event is dependent on final state comp in phase and final time in phase2
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if ((EventFinalStateDependMapG.mat[phase].mat[event].val[comp])&&(EventStaticDependMapG.mat[event].val[comp2])) // If event is dependent on final state comp in phase and static comp2
                    {
                        EventFinalStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 1;  // Indicate event is dependent on final state comp in phase and static comp2
                    }
                }
            }
            
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                    {
                        if ((EventIntegralDependMapG.mat[phase].mat[event].val[comp])&&(EventIntegralDependMapG.mat[phase2].mat[event].val[comp2]))   // If event is dependent on integral comp in phase and integral comp2 in phase2
                        {
                            EventIntegralIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 1;  // Indicate event is dependent on integral comp in phase and integral comp2 in phase2
                        }
                    }
                    
                    if ((EventIntegralDependMapG.mat[phase].mat[event].val[comp])&&(EventInitTimeDependMapG.mat[phase2].mat[event].val[0]))   // If event is dependent on integral comp in phase and initial time in phase2
                    {
                        EventIntegralInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1; // Indicate event is dependent on integral comp in phase and initial time in phase2
                    }
                    
                    if ((EventIntegralDependMapG.mat[phase].mat[event].val[comp])&&(EventFinalTimeDependMapG.mat[phase2].mat[event].val[0]))  // If event is dependent on integral comp in phase and final time in phase2
                    {
                        EventIntegralFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 1;    // Indicate event is dependent on integral comp in phase and final time in phase2
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if ((EventIntegralDependMapG.mat[phase].mat[event].val[comp])&&(EventStaticDependMapG.mat[event].val[comp2])) // If event is dependent on integral comp in phase and static comp2
                    {
                        EventIntegralStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 1;    // Indicate event is dependent on integral comp in phase and static comp2
                    }
                }
            }
            
            for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
            {
                if ((EventInitTimeDependMapG.mat[phase].mat[event].val[0])&&(EventInitTimeDependMapG.mat[phase2].mat[event].val[0]))  // If event is dependent on initial time in phase and initial time in phase2
                {
                    EventInitTimeInitTimeDependG.mat[event].mat[phase].val[phase2] = 1;    // Indicate event is dependent on initial time in phase and initial time in phase2
                }
                
                if ((EventInitTimeDependMapG.mat[phase].mat[event].val[0])&&(EventFinalTimeDependMapG.mat[phase2].mat[event].val[0])) // If event is dependent on initial time in phase and final time in phase2
                {
                    EventInitTimeFinalTimeDependG.mat[event].mat[phase].val[phase2] = 1;   // Indicate event is dependent on initial time in phase and final time in phase2
                }
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((EventInitTimeDependMapG.mat[phase].mat[event].val[0])&&(EventStaticDependMapG.mat[event].val[comp2]))  // If event is dependent on initial time in phase and static comp2
                {
                    EventInitTimeStaticDependG.mat[event].mat[phase].val[comp2] = 1;   // Indicate event is dependent on initial time in phase and static comp2
                }
            }
            
            for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
            {
                if ((EventFinalTimeDependMapG.mat[phase].mat[event].val[0])&&(EventFinalTimeDependMapG.mat[phase2].mat[event].val[0]))    // If event is dependent on final time in phase and final time in phase2
                {
                    EventFinalTimeFinalTimeDependG.mat[event].mat[phase].val[phase2] = 1;  // Indicate event is dependent on final time in phase and final time in phase2
                }
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((EventFinalTimeDependMapG.mat[phase].mat[event].val[0])&&(EventStaticDependMapG.mat[event].val[comp2])) // If event is dependent on final time in phase and static comp2
                {
                    EventFinalTimeStaticDependG.mat[event].mat[phase].val[comp2] = 1;  // Indicate event is dependent on final time in phase and static comp2
                }
            }
        }
        
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if ((EventStaticDependMapG.mat[event].val[comp])&&(EventStaticDependMapG.mat[event].val[comp2]))  // If event is dependent on static comp and static comp2
                {
                    EventStaticStaticDependG.mat[event].mat[comp].val[comp2] = 1;  // Indicate event is dependent on static comp and static comp2
                }
            }
        }
    }
}

void reinitDerivativeVars(void) // Reallocate memory for structures to hold derivative values at each point in phase
{
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        ptMatMatDub.mat[phase]    = getDoubleMat(NtG[phase]+1);       // Allocate memory for number of discretization points used in phase
        ptMatMatBC.mat[phase]  = getBicomplexMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
        ptMatMatHD.mat[phase]  = getHyperDualMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase

        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                DynamicFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of state components in phase
                DefectFuncValG.mat[phase].mat[comp]  = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of state components in phase
            }
            for (int comp=0; comp<ncG[phase]; comp++)   // For each state component in phase
            {
                PathFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of state components in phase
            }
            for (int comp=0; comp<nqG[phase]; comp++)   // For each state component in phase
            {
                LagrangeFuncValG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of state components in phase
            }
        }
    }
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
//            if (DynamicTimeDependMapG.mat[phase].mat[comp].val[0]==1)  // If dynamic comp in phase is dependent on time
//            {
                DynamicTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (DynamicStateDependMapG.mat[phase].mat[comp].val[comp2]==1) // If dynamic comp in phase is dependent on state comp2
//                {
                    DynamicStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (DynamicControlDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If dynamic comp in phase is dependent on control comp2
//                {
                    DynamicControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (DynamicStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If dynamic comp in phase is dependent on static comp2
//                {
                    DynamicStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
//            if (PathTimeDependMapG.mat[phase].mat[comp].val[0]==1) // If path comp in phase is dependent on time
//            {
                PathTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (PathStateDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If path comp in phase is dependent on state comp2
//                {
                    PathStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (PathControlDependMapG.mat[phase].mat[comp].val[comp2]==1)  // If path comp in phase is dependent on control comp2
//                {
                    PathControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (PathStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If path comp in phase is dependent on static comp2
//                {
                    PathStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
//            if (LagrangeTimeDependMapG.mat[phase].mat[comp].val[0]==1) // If lagrange comp in phase is dependent on time
//            {
                LagrangeTimeFirstDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//            }
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
//                if (LagrangeStateDependMapG.mat[phase].mat[comp].val[comp2]==1)    // If lagrange comp in phase is dependent on state comp2
//                {
                    LagrangeStateFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
//                if (LagrangeControlDependMapG.mat[phase].mat[comp].val[comp2]==1)  // If lagrange comp in phase is dependent on control comp2
//                {
                    LagrangeControlFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
//                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
//                if (LagrangeStaticDependMapG.mat[phase].mat[comp].val[comp2]==1)   // If lagrange comp in phase is dependent on static comp2
//                {
                    LagrangeStaticFirstDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
//                }
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if (DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)    // If dynamic comp in phase is dependent on state comp2 and time
                {
                    DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if (DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0) // If dynamic comp in phase is dependent on state comp2 and state comp3
                    {
                        DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)   // If dynamic comp in phase is dependent on state comp2 and control comp3
                    {
                        DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)    // If dynamic comp in phase is dependent on state comp2 and static comp3
                    {
                        DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if (DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)  // If dynamic comp in phase is dependent on control comp2 and time
                {
                    DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0) // If dynamic comp in phase is dependent on control comp2 and control comp3
                    {
                        DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)  // If dynamic comp in phase is dependent on control comp2 and static comp3
                    {
                        DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if (DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)   // If dynamic comp in phase is dependent on static comp2 and time
                {
                    DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)   // If dynamic comp in phase is dependent on static comp2 and static comp3
                    {
                        DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (DynamicTimeTimeSecondDerG.mat[phase].mat[comp].Len>0)    // If dynamic comp in phase is dependent on time
            {
                DynamicTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if (PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)   // If path comp in phase is dependent on state comp2 and time
                {
                    PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if (PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)    // If path comp in phase is dependent on state comp2 and state comp3
                    {
                        PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)  // If path comp in phase is dependent on state comp2 and control comp3
                    {
                        PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)   // If path comp in phase is dependent on state comp2 and static comp3
                    {
                        PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if (PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0) // If path comp in phase is dependent on control comp2 and time
                {
                    PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)    // If path comp in phase is dependent on control comp2 and control comp3
                    {
                        PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0) // If path comp in phase is dependent on control comp2 and static comp3
                    {
                        PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if (PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)  // If path comp in phase is dependent on static comp2 and time
                {
                    PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)  // If path comp in phase is dependent on static comp2 and static comp3
                    {
                        PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (PathTimeTimeSecondDerG.mat[phase].mat[comp].Len>0)   // If path comp in phase is dependent on time
            {
                PathTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
            }
        }
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
            {
                if (LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)   // If lagrange comp in phase is dependent on state comp2 and time
                {
                    LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                {
                    if (LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)    // If lagrange comp in phase is dependent on state comp2 and state comp3
                    {
                        LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)  // If lagrange comp in phase is dependent on state comp2 and control comp3
                    {
                        LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)   // If lagrange comp in phase is dependent on state comp2 and static comp3
                    {
                        LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
            {
                if (LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0) // If lagrange comp in phase is dependent on control comp2 and time
                {
                    LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                {
                    if (LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)    // If lagrange comp in phase is dependent on control comp2 and control comp3
                    {
                        LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1); // Allocate memory for number of discretization points used in phase
                    }
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0) // If lagrange comp in phase is dependent on control comp2 and static comp3
                    {
                        LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);  // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if (LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len>0)  // If lagrange comp in phase is dependent on static comp2 and time
                {
                    LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                }
                for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                {
                    if (LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len>0)  // If lagrange comp in phase is dependent on static comp2 and static comp3
                    {
                        LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3] = getDoubleMat(NtG[phase]+1);   // Allocate memory for number of discretization points used in phase
                    }
                }
            }
            if (LagrangeTimeTimeSecondDerG.mat[phase].mat[comp].Len>0)   // If lagrange comp in phase is dependent on time
            {
                LagrangeTimeTimeSecondDerG.mat[phase].mat[comp] = getDoubleMat(NtG[phase]+1);    // Allocate memory for number of discretization points used in phase
            }
        }
    }
}

void CheckSecondDerivatives(int checkSecondDerivativesFlag) // Checks for any unnecessary second-order derivative computations
{
    int nonzeroFlag=0;
    int pt;
    
    if (checkSecondDerivativesFlag==1)  // If check second derivatives flag is active
    {
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each dynamic function in phase
            {
                for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                {
                    if (DynamicStateTimeDependG.mat[phase].mat[comp].val[comp2]==1)    // If dynamic function comp is marked as dependent on state comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (DynamicStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)   // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            DynamicStateTimeDependG.mat[phase].mat[comp].val[comp2] = 0;   // Indicate partial of dynamic function comp wrt state comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                    {
                        if (DynamicStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If dynamic function comp is marked as dependent on state comp2 and state comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of dynamic function comp wrt state comp2 and state comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (DynamicStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If dynamic function comp is marked as dependent on state comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of dynamic function comp wrt state comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (DynamicStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)  // If dynamic function comp is marked as dependent on state comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)   // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0; // Indicate partial of dynamic function comp wrt state comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                {
                    if (DynamicControlTimeDependG.mat[phase].mat[comp].val[comp2]==1)  // If dynamic function comp is marked as dependent on control comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (DynamicControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0) // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            DynamicControlTimeDependG.mat[phase].mat[comp].val[comp2] = 0; // Indicate partial of dynamic function comp wrt control comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (DynamicControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If dynamic function comp is marked as dependent on control comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of dynamic function comp wrt control comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (DynamicControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)    // If dynamic function comp is marked as dependent on control comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0) // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;   // Indicate partial of dynamic function comp wrt control comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                if (DynamicTimeTimeDependG.mat[phase].val[comp]==1)  // If dynamic function comp is marked as dependent on time and time in phase
                {
                    pt = 0;   // Initialize to first point
                    while ((pt<DynamicTimeTimeSecondDerG.mat[phase].mat[comp].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                    {
                        if (DynamicTimeTimeSecondDerG.mat[phase].mat[comp].val[pt]==0)   // Second derivative is zero at pt
                        {
                            pt++;   // Increment to next point
                        }
                        else    // Second derivative is nonzero at pt
                        {
                            nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                        }
                    }
                    if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                    {
                        DynamicTimeTimeDependG.mat[phase].val[comp] = 0; // Indicate partial of dynamic function comp wrt time and time does not need to be taken
                    }
                    else    // Second derivative is nonzero at at least one point
                    {
                        nonzeroFlag = 0;    // Reset nonzero flag
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if (DynamicTimeStaticDependG.mat[phase].mat[comp].val[comp2]==1)   // If dynamic function comp is marked as dependent on static comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (DynamicTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)  // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            DynamicTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of dynamic function comp wrt static comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (DynamicStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If dynamic function comp is marked as dependent on static comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (DynamicStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)  // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                DynamicStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of dynamic function comp wrt static comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
            }
            
            for (int comp=0; comp<ncG[phase]; comp++)   // For each path function in phase
            {
                for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                {
                    if (PathStateTimeDependG.mat[phase].mat[comp].val[comp2]==1)    // If Path function comp is marked as dependent on state comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (PathStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)   // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            PathStateTimeDependG.mat[phase].mat[comp].val[comp2] = 0;   // Indicate partial of Path function comp wrt state comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                    {
                        if (PathStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If Path function comp is marked as dependent on state comp2 and state comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of Path function comp wrt state comp2 and state comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (PathStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If Path function comp is marked as dependent on state comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of Path function comp wrt state comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (PathStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)  // If Path function comp is marked as dependent on state comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)   // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0; // Indicate partial of Path function comp wrt state comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                {
                    if (PathControlTimeDependG.mat[phase].mat[comp].val[comp2]==1)  // If Path function comp is marked as dependent on control comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (PathControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0) // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            PathControlTimeDependG.mat[phase].mat[comp].val[comp2] = 0; // Indicate partial of Path function comp wrt control comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (PathControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If Path function comp is marked as dependent on control comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of Path function comp wrt control comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (PathControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)    // If Path function comp is marked as dependent on control comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0) // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;   // Indicate partial of Path function comp wrt control comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                if (PathTimeTimeDependG.mat[phase].val[comp]==1) // If Path function comp is marked as dependent on time and time in phase
                {
                    pt = 0;   // Initialize to first point
                    while ((pt<PathTimeTimeSecondDerG.mat[phase].mat[comp].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                    {
                        if (PathTimeTimeSecondDerG.mat[phase].mat[comp].val[pt]==0)   // Second derivative is zero at pt
                        {
                            pt++;   // Increment to next point
                        }
                        else    // Second derivative is nonzero at pt
                        {
                            nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                        }
                    }
                    if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                    {
                        PathTimeTimeDependG.mat[phase].val[comp] = 0; // Indicate partial of Path function comp wrt time and time does not need to be taken
                    }
                    else    // Second derivative is nonzero at at least one point
                    {
                        nonzeroFlag = 0;    // Reset nonzero flag
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if (PathTimeStaticDependG.mat[phase].mat[comp].val[comp2]==1)   // If Path function comp is marked as dependent on static comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (PathTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)  // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            PathTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of Path function comp wrt static comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (PathStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If Path function comp is marked as dependent on static comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (PathStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)  // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                PathStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of Path function comp wrt static comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
            }
            
            for (int comp=0; comp<nqG[phase]; comp++)   // For each lagrange function in phase
            {
                for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                {
                    if (LagrangeStateTimeDependG.mat[phase].mat[comp].val[comp2]==1)    // If Lagrange function comp is marked as dependent on state comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (LagrangeStateTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)   // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            LagrangeStateTimeDependG.mat[phase].mat[comp].val[comp2] = 0;   // Indicate partial of Lagrange function comp wrt state comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nxG[phase]; comp3++)    // For each state component in phase
                    {
                        if (LagrangeStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If Lagrange function comp is marked as dependent on state comp2 and state comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeStateStateSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeStateStateDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of Lagrange function comp wrt state comp2 and state comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (LagrangeStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If Lagrange function comp is marked as dependent on state comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeStateControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeStateControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of Lagrange function comp wrt state comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (LagrangeStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)  // If Lagrange function comp is marked as dependent on state comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeStateStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)   // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeStateStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0; // Indicate partial of Lagrange function comp wrt state comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                // START HERE 9/14 with control
                
                for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                {
                    if (LagrangeControlTimeDependG.mat[phase].mat[comp].val[comp2]==1)  // If Lagrange function comp is marked as dependent on control comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (LagrangeControlTimeSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0) // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            LagrangeControlTimeDependG.mat[phase].mat[comp].val[comp2] = 0; // Indicate partial of Lagrange function comp wrt control comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nuG[phase]; comp3++)    // For each control component in phase
                    {
                        if (LagrangeControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)   // If Lagrange function comp is marked as dependent on control comp2 and control comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0)) // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeControlControlSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)    // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeControlControlDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;  // Indicate partial of Lagrange function comp wrt control comp2 and control comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (LagrangeControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1)    // If Lagrange function comp is marked as dependent on control comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))  // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeControlStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0) // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeControlStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;   // Indicate partial of Lagrange function comp wrt control comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
                
                if (LagrangeTimeTimeDependG.mat[phase].val[comp]==1) // If Lagrange function comp is marked as dependent on time and time in phase
                {
                    pt = 0;   // Initialize to first point
                    while ((pt<LagrangeTimeTimeSecondDerG.mat[phase].mat[comp].Len)&&(nonzeroFlag==0))    // While point is less then number of discretization points and the nonzero flag is still inactive
                    {
                        if (LagrangeTimeTimeSecondDerG.mat[phase].mat[comp].val[pt]==0)   // Second derivative is zero at pt
                        {
                            pt++;   // Increment to next point
                        }
                        else    // Second derivative is nonzero at pt
                        {
                            nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                        }
                    }
                    if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                    {
                        LagrangeTimeTimeDependG.mat[phase].val[comp] = 0; // Indicate partial of Lagrange function comp wrt time and time does not need to be taken
                    }
                    else    // Second derivative is nonzero at at least one point
                    {
                        nonzeroFlag = 0;    // Reset nonzero flag
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                {
                    if (LagrangeTimeStaticDependG.mat[phase].mat[comp].val[comp2]==1)   // If Lagrange function comp is marked as dependent on static comp2 and time in phase
                    {
                        pt = 0;   // Initialize to first point
                        while ((pt<LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                        {
                            if (LagrangeTimeStaticSecondDerG.mat[phase].mat[comp].mat[comp2].val[pt]==0)  // Second derivative is zero at pt
                            {
                                pt++;   // Increment to next point
                            }
                            else    // Second derivative is nonzero at pt
                            {
                                nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                            }
                        }
                        if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                        {
                            LagrangeTimeStaticDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of Lagrange function comp wrt static comp2 and time does not need to be taken
                        }
                        else    // Second derivative is nonzero at at least one point
                        {
                            nonzeroFlag = 0;    // Reset nonzero flag
                        }
                    }
                    
                    for (int comp3=0; comp3<nsG; comp3++)   // For each static parameter in problem
                    {
                        if (LagrangeStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3]==1) // If Lagrange function comp is marked as dependent on static comp2 and static comp3 in phase
                        {
                            pt=0;   // Initialize to first point
                            while ((pt<LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].Len)&&(nonzeroFlag==0))   // While point is less then number of discretization points and the nonzero flag is still inactive
                            {
                                if (LagrangeStaticStaticSecondDerG.mat[phase].mat[comp].mat[comp2].mat[comp3].val[pt]==0)  // Second derivative is zero at pt
                                {
                                    pt++;   // Increment to next point
                                }
                                else    // Second derivative is nonzero at pt
                                {
                                    nonzeroFlag = 1;    // Indicate that a nonzero value has been found
                                }
                            }
                            if (nonzeroFlag==0) // Second derivative is zero at all discretization points
                            {
                                LagrangeStaticStaticDependG.mat[phase].mat[comp].mat[comp2].val[comp3] = 0;    // Indicate partial of Lagrange function comp wrt static comp2 and static comp3 does not need to be taken
                            }
                            else    // Second derivative is nonzero at at least one point
                            {
                                nonzeroFlag = 0;    // Reset nonzero flag
                            }
                        }
                    }
                }
            }
        }
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int comp2=0; comp<nxG[phase]; comp++)  // For each state component in phase
                {
                    if (ObjectiveInitStateInitStateDependG.mat[phase].mat[comp].val[comp2]==1) // If objective function in phase is marked as dependent on initial state comp and initial state comp2 in phase
                    {
                        if (ObjectiveInitStateInitStateSecondDerG.mat[phase].mat[comp].val[comp2]==0)    // Second derivative is zero
                        {
                            ObjectiveInitStateInitStateDependG.mat[phase].mat[comp].val[comp2] = 0;    // Indicate partial of objective function in phase wrt initial state comp and initial state comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int comp2=0; comp<nxG[phase]; comp++)  // For each state component in phase
                {
                    if (ObjectiveInitStateFinalStateDependG.mat[phase].mat[comp].val[comp2]==1)    // If objective function in phase is marked as dependent on initial state comp and final state comp2 in phase
                    {
                        if (ObjectiveInitStateFinalStateSecondDerG.mat[phase].mat[comp].val[comp2]==0)   // Second derivative is zero
                        {
                            ObjectiveInitStateFinalStateDependG.mat[phase].mat[comp].val[comp2] = 0;    // Indicate partial of objective function in phase wrt initial state comp and final state comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int comp2=0; comp<nqG[phase]; comp++)  // For each integral component in phase
                {
                    if (ObjectiveInitStateIntegralDependG.mat[phase].mat[comp].val[comp2]==1)  // If objective function in phase is marked as dependent on initial state comp and integral comp2 in phase
                    {
                        if (ObjectiveInitStateIntegralSecondDerG.mat[phase].mat[comp].val[comp2]==0) // Second derivative is zero
                        {
                            ObjectiveInitStateIntegralDependG.mat[phase].mat[comp].val[comp2] = 0; // Indicate partial of objective function in phase wrt initial state comp and integral comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                if (ObjectiveInitStateInitTimeDependG.mat[phase].val[comp]==1)   // If objective function in phase is marked as dependent on initial state comp and initial time in phase
                {
                    if (ObjectiveInitStateInitTimeSecondDerG.mat[phase].val[comp]==0) // Second derivative is zero
                    {
                        ObjectiveInitStateInitTimeDependG.mat[phase].val[comp] = 0;  // Indicate partial of objective function in phase wrt initial state comp and initial time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                if (ObjectiveInitStateFinalTimeDependG.mat[phase].val[comp]==1)  // If objective function in phase is marked as dependent on initial state comp and final time in phase
                {
                    if (ObjectiveInitStateFinalTimeSecondDerG.mat[phase].val[comp]==0) // Second derivative is zero
                    {
                        ObjectiveInitStateFinalTimeDependG.mat[phase].val[comp] = 0; // Indicate partial of objective function in phase wrt initial state comp and final time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                for (int comp2=0; comp<nsG; comp++) // For each static parameter in problem
                {
                    if (ObjectiveInitStateStaticDependG.mat[phase].mat[comp].val[comp2]==1)    // If objective function in phase is marked as dependent on initial state comp and static comp2 in phase
                    {
                        if (ObjectiveInitStateStaticSecondDerG.mat[phase].mat[comp].val[comp2]==0) // Second derivative is zero
                        {
                            ObjectiveInitStateStaticDependG.mat[phase].mat[comp].val[comp2] = 0;   // Indicate partial of objective function in phase wrt initial state comp and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
            }
            
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int comp2=0; comp<nxG[phase]; comp++)  // For each state component in phase
                {
                    if (ObjectiveFinalStateFinalStateDependG.mat[phase].mat[comp].val[comp2]==1)   // If objective function in phase is marked as dependent on final state comp and final state comp2 in phase
                    {
                        if (ObjectiveFinalStateFinalStateSecondDerG.mat[phase].mat[comp].val[comp2]==0)  // Second derivative is zero
                        {
                            ObjectiveFinalStateFinalStateDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of objective function in phase wrt final state comp and final state comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int comp2=0; comp<nqG[phase]; comp++)  // For each integral component in phase
                {
                    if (ObjectiveFinalStateIntegralDependG.mat[phase].mat[comp].val[comp2]==1) // If objective function in phase is marked as dependent on final state comp and integral comp2 in phase
                    {
                        if (ObjectiveFinalStateIntegralSecondDerG.mat[phase].mat[comp].val[comp2]==0)    // Second derivative is zero
                        {
                            ObjectiveFinalStateIntegralDependG.mat[phase].mat[comp].val[comp2] = 0;    // Indicate partial of objective function in phase wrt final state comp and integral comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                if (ObjectiveFinalStateInitTimeDependG.mat[phase].val[comp]==1)  // If objective function in phase is marked as dependent on final state comp and initial time in phase
                {
                    if (ObjectiveFinalStateInitTimeSecondDerG.mat[phase].val[comp]==0)    // Second derivative is zero
                    {
                        ObjectiveFinalStateInitTimeDependG.mat[phase].val[comp] = 0; // Indicate partial of objective function in phase wrt final state comp and initial time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                if (ObjectiveFinalStateFinalTimeDependG.mat[phase].val[comp]==1) // If objective function in phase is marked as dependent on final state comp and final time in phase
                {
                    if (ObjectiveFinalStateFinalTimeSecondDerG.mat[phase].val[comp]==0)   // Second derivative is zero
                    {
                        ObjectiveFinalStateFinalTimeDependG.mat[phase].val[comp] = 0;    // Indicate partial of objective function in phase wrt final state comp and final time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                for (int comp2=0; comp<nsG; comp++) // For each static parameter in problem
                {
                    if (ObjectiveFinalStateStaticDependG.mat[phase].mat[comp].val[comp2]==1)   // If objective function in phase is marked as dependent on final state comp and static comp2 in phase
                    {
                        if (ObjectiveFinalStateStaticSecondDerG.mat[phase].mat[comp].val[comp2]==0)  // Second derivative is zero
                        {
                            ObjectiveFinalStateStaticDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of objective function in phase wrt final state comp and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
            }
            
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                for (int comp2=0; comp<nqG[phase]; comp++)  // For each integral component in phase
                {
                    if (ObjectiveIntegralIntegralDependG.mat[phase].mat[comp].val[comp2]==1)   // If objective function in phase is marked as dependent on integral comp and integral comp2 in phase
                    {
                        if (ObjectiveIntegralIntegralSecondDerG.mat[phase].mat[comp].val[comp2]==0)  // Second derivative is zero
                        {
                            ObjectiveIntegralIntegralDependG.mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of objective function in phase wrt integral comp and integral comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                if (ObjectiveIntegralInitTimeDependG.mat[phase].val[comp]==1)    // If objective function in phase is marked as dependent on integral comp and initial time in phase
                {
                    if (ObjectiveIntegralInitTimeSecondDerG.mat[phase].val[comp]==0)  // Second derivative is zero
                    {
                        ObjectiveIntegralInitTimeDependG.mat[phase].val[comp] = 0;   // Indicate partial of objective function in phase wrt integral comp and initial time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                if (ObjectiveIntegralFinalTimeDependG.mat[phase].val[comp]==1)   // If objective function in phase is marked as dependent on integral comp and final time in phase
                {
                    if (ObjectiveIntegralFinalTimeSecondDerG.mat[phase].val[comp]==0) // Second derivative is zero
                    {
                        ObjectiveIntegralFinalTimeDependG.mat[phase].val[comp] = 0;  // Indicate partial of objective function in phase wrt integral comp and final time does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
                
                for (int comp2=0; comp<nsG; comp++) // For each static parameter in problem
                {
                    if (ObjectiveIntegralStaticDependG.mat[phase].mat[comp].val[comp2]==1) // If objective function in phase is marked as dependent on integral comp and static comp2 in phase
                    {
                        if (ObjectiveIntegralStaticSecondDerG.mat[phase].mat[comp].val[comp2]==0)    // Second derivative is zero
                        {
                            ObjectiveIntegralStaticDependG.mat[phase].mat[comp].val[comp2] = 0;    // Indicate partial of objective function in phase wrt integral comp and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
            }
            
            if (ObjectiveInitTimeInitTimeDependG.val[phase]==1) // If objective function in phase is marked as dependent on initial time and initial time in phase
            {
                if (ObjectiveInitTimeInitTimeSecondDerG.val[phase]==0)  // Second derivative is zero
                {
                    ObjectiveInitTimeInitTimeDependG.val[phase] = 0;    // Indicate partial of objective function in phase wrt initial time and initial time does not need to be taken
                }
                else    // Second derivative is nonzero
                {
                    // Do nothing
                }
            }
            
            if (ObjectiveInitTimeFinalTimeDependG.val[phase]==1)    // If objective function in phase is marked as dependent on initial time and final time in phase
            {
                if (ObjectiveInitTimeFinalTimeSecondDerG.val[phase]==0) // Second derivative is zero
                {
                    ObjectiveInitTimeFinalTimeDependG.val[phase] = 0;   // Indicate partial of objective function in phase wrt initial time and final time does not need to be taken
                }
                else    // Second derivative is nonzero
                {
                    // Do nothing
                }
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if (ObjectiveInitTimeStaticDependG.mat[phase].val[comp2]==1) // If objective function in phase is marked as dependent on initial time and static comp2 in phase
                {
                    if (ObjectiveInitTimeStaticSecondDerG.mat[phase].val[comp2]==0)   // Second derivative is zero
                    {
                        ObjectiveInitTimeStaticDependG.mat[phase].val[comp2] = 0;    // Indicate partial of objective function in phase wrt initial time and static comp2 does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
            }
            
            if (ObjectiveFinalTimeFinalTimeDependG.val[phase]==1)   // If objective function in phase is marked as dependent on final time and final time in phase
            {
                if (ObjectiveFinalTimeFinalTimeSecondDerG.val[phase]==0)    // Second derivative is zero
                {
                    ObjectiveFinalTimeFinalTimeDependG.val[phase] = 0;  // Indicate partial of objective function in phase wrt final time and final time does not need to be taken
                }
                else    // Second derivative is nonzero
                {
                    // Do nothing
                }
            }
            
            for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
            {
                if (ObjectiveFinalTimeStaticDependG.mat[phase].val[comp2]==1)    // If objective function in phase is marked as dependent on final time and static comp2 in phase
                {
                    if (ObjectiveFinalTimeStaticSecondDerG.mat[phase].val[comp2]==0)  // Second derivative is zero
                    {
                        ObjectiveFinalTimeStaticDependG.mat[phase].val[comp2] = 0;   // Indicate partial of objective function in phase wrt final time and static comp2 does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
            }
            
        }
        
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            for (int comp2=0; comp<nsG; comp++) // For each static parameter in problem
            {
                if (ObjectiveStaticStaticDependG.mat[0].mat[comp].val[comp2]==1)   // If objective function in phase is marked as dependent on static comp and static comp2 in phase
                {
                    if (ObjectiveStaticStaticSecondDerG.mat[0].mat[comp].val[comp2]==0)  // Second derivative is zero
                    {
                        ObjectiveStaticStaticDependG.mat[0].mat[comp].val[comp2] = 0;  // Indicate partial of objective function in phase wrt static comp and static comp2 does not need to be taken
                    }
                    else    // Second derivative is nonzero
                    {
                        // Do nothing
                    }
                }
            }
        }
        
        int numEvent;   // Holder for number of events
        
        if ((DurationFlagG)&&(ContinuityFlagG))   // If duration and continuity constraints are active
        {
            numEvent = nbG + PG + neG;    // Number of event constraints equals number defined by user plus duration constraints and continuity constraints
        }
        else if (DurationFlagG)   // If duration constraints are active
        {
            numEvent = nbG + PG;    // Number of event constraints equals number defined by user plus duration constraints
        }
        else if (ContinuityFlagG)   // If continuity constraints are active
        {
            numEvent = nbG + neG;    // Number of event constraints equals number defined by user plus continuity constraints
        }
        else
        {
            numEvent = nbG; // Set number of event used to nbG
        }
        
        for (int event=0; event<numEvent; event++)  // For each event in problem
        {
            for (int phase=0; phase<PG; phase++)    // For each phase in problem
            {
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                    {
                        for (int comp2=0; comp2<nxG[phase2]; comp2++)   // For each state component in phase2
                        {
                            if (EventInitStateInitStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1) // If event function is marked as dependent on initial state comp in phase and initial state comp2 in phase2
                            {
                                if (EventInitStateInitStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0)  // Second derivative is zero
                                {
                                    EventInitStateInitStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0;    // Indicate partial of event function wrt initial state comp in phase and initial state comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        for (int comp2=0; comp2<nxG[phase2]; comp2++)   // For each state component in phase2
                        {
                            if (EventInitStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1)    // If event function is marked as dependent on initial state comp in phase and final state comp2 in phase2
                            {
                                if (EventInitStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0) // Second derivative is zero
                                {
                                    EventInitStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0;   // Indicate partial of event function wrt initial state comp in phase and final state comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                        {
                            if (EventInitStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1)  // If event function is marked as dependent on initial state comp in phase and integral comp2 in phase2
                            {
                                if (EventInitStateIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0)   // Second derivative is zero
                                {
                                    EventInitStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0; // Indicate partial of event function wrt initial state comp in phase and integral comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        if (EventInitStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1) // If event function is marked as dependent on initial state comp in phase and initial time in phase2
                        {
                            if (EventInitStateInitTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0) // Second derivative is zero
                            {
                                EventInitStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0;    // Indicate partial of event function wrt initial state comp in phase and initial time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                        
                        if (EventInitStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1)    // If event function is marked as dependent on initial state comp in phase and final time in phase2
                        {
                            if (EventInitStateFinalTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0)    // Second derivative is zero
                            {
                                EventInitStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0;   // Indicate partial of event function wrt initial state comp in phase and final time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                    
                    for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                    {
                        if (EventInitStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2]==1)    // If event function is marked as dependent on initial state comp in phase and static comp2
                        {
                            if (EventInitStateStaticSecondDerG.mat[event].mat[phase].mat[comp].val[comp2]==0)    // Second derivative is zero
                            {
                                EventInitStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 0;   // Indicate partial of event function wrt initial state comp in phase and static comp2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                }
                
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                    {
                        for (int comp2=0; comp2<nxG[phase2]; comp2++)   // For each state component in phase2
                        {
                            if (EventFinalStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1)   // If event function is marked as dependent on final state comp in phase and final state comp2 in phase2
                            {
                                if (EventFinalStateFinalStateSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0)    // Second derivative is zero
                                {
                                    EventFinalStateFinalStateDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0;  // Indicate partial of event function wrt final state comp in phase and final state comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                        {
                            if (EventFinalStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1) // If event function is marked as dependent on final state comp in phase and integral comp2 in phase2
                            {
                                if (EventFinalStateIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0)  // Second derivative is zero
                                {
                                    EventFinalStateIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0;    // Indicate partial of event function wrt final state comp in phase and integral comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        if (EventFinalStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1)    // If event function is marked as dependent on final state comp in phase and initial time in phase2
                        {
                            if (EventFinalStateInitTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0)    // Second derivative is zero
                            {
                                EventFinalStateInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0;   // Indicate partial of event function wrt final state comp in phase and initial time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                        
                        if (EventFinalStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1)   // If event function is marked as dependent on final state comp in phase and final time in phase2
                        {
                            if (EventFinalStateFinalTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0)   // Second derivative is zero
                            {
                                EventFinalStateFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0;  // Indicate partial of event function wrt final state comp in phase and final time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                    
                    for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter
                    {
                        if (EventFinalStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2]==1)   // If event function is marked as dependent on final state comp in phase and static comp2
                        {
                            if (EventFinalStateStaticSecondDerG.mat[event].mat[phase].mat[comp].val[comp2]==0)   // Second derivative is zero
                            {
                                EventFinalStateStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 0;  // Indicate partial of event function wrt final state comp in phase and static comp2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                }
                
                for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                {
                    for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                    {
                        for (int comp2=0; comp2<nqG[phase2]; comp2++)   // For each integral component in phase2
                        {
                            if (EventIntegralIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==1)   // If event function is marked as dependent on integral comp in phase and integral comp2 in phase2
                            {
                                if (EventIntegralIntegralSecondDerG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2]==0)    // Second derivative is zero
                                {
                                    EventIntegralIntegralDependG.mat[event].mat[phase].mat[comp].mat[phase2].val[comp2] = 0;  // Indicate partial of event function wrt integral comp in phase and integral comp2 in phase2 does not need to be taken
                                }
                                else    // Second derivative is nonzero
                                {
                                    // Do nothing
                                }
                            }
                        }
                        
                        if (EventIntegralInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1)  // If event function is marked as dependent on integral comp in phase and initial time in phase2
                        {
                            if (EventIntegralInitTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0)  // Second derivative is zero
                            {
                                EventIntegralInitTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0; // Indicate partial of event function wrt integral comp in phase and initial time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                        
                        if (EventIntegralFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2]==1) // If event function is marked as dependent on integral comp in phase and final time in phase2
                        {
                            if (EventIntegralFinalTimeSecondDerG.mat[event].mat[phase].mat[comp].val[phase2]==0) // Second derivative is zero
                            {
                                EventIntegralFinalTimeDependG.mat[event].mat[phase].mat[comp].val[phase2] = 0;    // Indicate partial of event function wrt integral comp in phase and final time in phase2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                    
                    for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter
                    {
                        if (EventIntegralStaticDependG.mat[event].mat[phase].mat[comp].val[comp2]==1) // If event function is marked as dependent on integral comp in phase and static comp2
                        {
                            if (EventIntegralStaticSecondDerG.mat[event].mat[phase].mat[comp].val[comp2]==0) // Second derivative is zero
                            {
                                EventIntegralStaticDependG.mat[event].mat[phase].mat[comp].val[comp2] = 0;    // Indicate partial of event function wrt integral comp in phase and static comp2 does not need to be taken
                            }
                            else    // Second derivative is nonzero
                            {
                                // Do nothing
                            }
                        }
                    }
                }
                
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    if (EventInitTimeInitTimeDependG.mat[event].mat[phase].val[phase2]==1) // If event function is marked as dependent on initial time in phase and initial time in phase2
                    {
                        if (EventInitTimeInitTimeSecondDerG.mat[event].mat[phase].val[phase2]==0)    // Second derivative is zero
                        {
                            EventInitTimeInitTimeDependG.mat[event].mat[phase].val[phase2] = 0;    // Indicate partial of event function wrt initial time in phase and initial time in phase2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                    
                    if (EventInitTimeFinalTimeDependG.mat[event].mat[phase].val[phase2]==1)    // If event function is marked as dependent on initial time in phase and final time in phase2
                    {
                        if (EventInitTimeFinalTimeSecondDerG.mat[event].mat[phase].val[phase2]==0)   // Second derivative is zero
                        {
                            EventInitTimeFinalTimeDependG.mat[event].mat[phase].val[phase2] = 0;   // Indicate partial of event function wrt initial time in phase and final time in phase2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter
                {
                    if (EventInitTimeStaticDependG.mat[event].mat[phase].val[comp2]==1)    // If event function is marked as dependent on initial time in phase and static comp2
                    {
                        if (EventInitTimeStaticSecondDerG.mat[event].mat[phase].val[comp2]==0)   // Second derivative is zero
                        {
                            EventInitTimeStaticDependG.mat[event].mat[phase].val[comp2] = 0;   // Indicate partial of event function wrt initial time in phase and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int phase2=0; phase2<PG; phase2++) // For each phase in problem
                {
                    if (EventFinalTimeFinalTimeDependG.mat[event].mat[phase].val[phase2]==1)   // If event function is marked as dependent on final time in phase and final time in phase2
                    {
                        if (EventFinalTimeFinalTimeSecondDerG.mat[event].mat[phase].val[phase2]==0)  // Second derivative is zero
                        {
                            EventFinalTimeFinalTimeDependG.mat[event].mat[phase].val[phase2] = 0;  // Indicate partial of event function wrt final time in phase and final time in phase2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
                
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter
                {
                    if (EventFinalTimeStaticDependG.mat[event].mat[phase].val[comp2]==1)   // If event function is marked as dependent on final time in phase and static comp2
                    {
                        if (EventFinalTimeStaticSecondDerG.mat[event].mat[phase].val[comp2]==0)  // Second derivative is zero
                        {
                            EventFinalTimeStaticDependG.mat[event].mat[phase].val[comp2] = 0;  // Indicate partial of event function wrt final time in phase and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
            }
            
            for (int comp=0; comp<nsG; comp++)  // For each static parameter
            {
                for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter
                {
                    if (EventStaticStaticDependG.mat[event].mat[comp].val[comp2]==1)   // If event function is marked as dependent on static comp and static comp2
                    {
                        if (EventStaticStaticSecondDerG.mat[event].mat[comp].val[comp2]==0)  // Second derivative is zero
                        {
                            EventStaticStaticDependG.mat[event].mat[comp].val[comp2] = 0;  // Indicate partial of event function wrt static comp and static comp2 does not need to be taken
                        }
                        else    // Second derivative is nonzero
                        {
                            // Do nothing
                        }
                    }
                }
            }
        }
    }
}

void deleteGlobalVars(void)   // Delete global variables in executable
{
    if (PG>0)
    {
//        printf("\nDeleting Global Variables");
        delete[] nxG;
        delete[] nuG;
        delete[] nqG;
        delete[] ncG;
        delete[] NtG;
        delete[] nppG;
        delete[] nxorigG;
        delete[] nuorigG;
        delete[] nqorigG;
        delete[] ncorigG;
        delete[] npporigG;
        delete[] nZG;
        delete[] PrIZG;
        delete[] TeIZG;
        delete[] nHG;
        delete[] PrIHG;
        delete[] TeIHG;
        delete[] rpmdG;
        delete[] mrdG;
        delete[] meshRefineTechG;
        
        nxG = nullptr;
        nuG = nullptr;
        nqG = nullptr;
        ncG = nullptr;
        NtG = nullptr;
        nppG = nullptr;
        nxorigG = nullptr;
        nuorigG = nullptr;
        nqorigG = nullptr;
        ncorigG = nullptr;
        npporigG = nullptr;
        nZG = nullptr;
        PrIZG = nullptr;
        TeIZG = nullptr;
        nHG = nullptr;
        PrIHG = nullptr;
        TeIHG = nullptr;
        rpmdG = nullptr;
        mrdG = nullptr;
        meshRefineTechG = nullptr;
        
        
        if (PhaseParametersInitFlagG==0)
        {
            delete[] PhaseParameterDependenciesG;
            delete[] StatePhaseDependenciesG;
            delete[] ControlPhaseDependenciesG;
            delete[] StaticPhaseDependenciesG;
            delete[] TimePhaseDependenciesG;
            delete[] DynamicPhaseDependenciesG;
            delete[] PathPhaseDependenciesG;
            delete[] LagrangePhaseDependenciesG;
            delete[] PhaseDynamicTimeDependMapG;
            delete[] PhaseDynamicStateDependMapG;
            delete[] PhaseDynamicControlDependMapG;
            delete[] PhaseDynamicStaticDependMapG;
            delete[] PhasePathTimeDependMapG;
            delete[] PhasePathStateDependMapG;
            delete[] PhasePathControlDependMapG;
            delete[] PhasePathStaticDependMapG;
            delete[] PhaseLagrangeTimeDependMapG;
            delete[] PhaseLagrangeStateDependMapG;
            delete[] PhaseLagrangeControlDependMapG;
            delete[] PhaseLagrangeStaticDependMapG;
            
            PhaseParameterDependenciesG = nullptr;
            StatePhaseDependenciesG = nullptr;
            ControlPhaseDependenciesG = nullptr;
            StaticPhaseDependenciesG = nullptr;
            TimePhaseDependenciesG = nullptr;
            DynamicPhaseDependenciesG = nullptr;
            PathPhaseDependenciesG = nullptr;
            LagrangePhaseDependenciesG = nullptr;
            PhaseDynamicTimeDependMapG = nullptr;
            PhaseDynamicStateDependMapG = nullptr;
            PhaseDynamicControlDependMapG = nullptr;
            PhaseDynamicStaticDependMapG = nullptr;
            PhasePathTimeDependMapG = nullptr;
            PhasePathStateDependMapG = nullptr;
            PhasePathControlDependMapG = nullptr;
            PhasePathStaticDependMapG = nullptr;
            PhaseLagrangeTimeDependMapG = nullptr;
            PhaseLagrangeStateDependMapG = nullptr;
            PhaseLagrangeControlDependMapG = nullptr;
            PhaseLagrangeStaticDependMapG = nullptr;
        }
        if (EndpointParametersInitFlagG==0)
        {
            delete[] InitStateEndpointDependenciesG;
            delete[] FinalStateEndpointDependenciesG;
            delete[] IntegralEndpointDependenciesG;
            delete[] InitTimeEndpointDependenciesG;
            delete[] FinalTimeEndpointDependenciesG;
            delete[] EndpointEventInitStateDependMapG;
            delete[] EndpointEventFinalStateDependMapG;
            delete[] EndpointEventIntegralDependMapG;
            delete[] EndpointEventInitTimeDependMapG;
            delete[] EndpointEventFinalTimeDependMapG;
            
            InitStateEndpointDependenciesG = nullptr;
            FinalStateEndpointDependenciesG = nullptr;
            IntegralEndpointDependenciesG = nullptr;
            InitTimeEndpointDependenciesG = nullptr;
            FinalTimeEndpointDependenciesG = nullptr;
            EndpointEventInitStateDependMapG = nullptr;
            EndpointEventFinalStateDependMapG = nullptr;
            EndpointEventIntegralDependMapG = nullptr;
            EndpointEventInitTimeDependMapG = nullptr;
            EndpointEventFinalTimeDependMapG = nullptr;
        }
        PhaseParametersInitFlagG = 1;
        EndpointParametersInitFlagG = 1;
        ParameterDependenciesFlagG = 0;
        MeshIterG = 0;
        LavrentievConstraintFlagG = 0;
        TimeStatsFlagG=0;
        LinearControlInHamFlagG=0;
        userScalarsG = 0;
        initialTimeVariationG=1;
        finalTimeVariationG=1;
        timeVariationG=0;
        paramPartialG=-1;
        controlCompG=-1;
        useLTIHDDG=0;
        useSOIAdjustFlagG=0;
        setRPMDGFlagG=0;
        setInfoNLPGFlagG=0;
        setNLPPBGFlagG=0;
        setNLPWBGFlagG=0;
        setNLPPGGFlagG=0;
        setNLPWGGFlagG=0;
        ContinuityFlagG=0;
        neG=0;
    }
}

void printGlobalVars(void)
{
    printf("\nPG = %d",PG);
    printf("\nnsG = %d",nsG);
    printf("\nnbG = %d",nbG);
    printf("\nnepG = %d",nepG);
    for (int i=0; i<PG; i++)
    {
        printf("\nnxG[%d] = %d",i,nxG[i]);
    }
    for (int i=0; i<PG; i++)
    {
        printf("\nnuG[%d] = %d",i,nuG[i]);
    }
    for (int i=0; i<PG; i++)
    {
        printf("\nnqG[%d] = %d",i,nqG[i]);
    }
    for (int i=0; i<PG; i++)
    {
        printf("\nncG[%d] = %d",i,ncG[i]);
    }
    for (int i=0; i<PG; i++)
    {
        printf("\nNtG[%d] = %d",i,NtG[i]);
    }
    for (int i=0; i<PG; i++)
    {
        printf("\nnppG[%d] = %d",i,nppG[i]);
    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nrpmdG[%d] = ",i);
//        printf(rpmdG[i]);
//    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nnZG[%d] = %d",i,nZG[i]);
//    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nPrIZG[%d] = %d",i,PrIZG[i]);
//    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nTeIZG[%d] = %d",i,TeIZG[i]);
//    }
//    printf("\nLenZG = %d",LenZG);
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nnHG[%d] = %d",i,nHG[i]);
//    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nPrIHG[%d] = %d",i,PrIHG[i]);
//    }
//    for (int i=0; i<PG; i++)
//    {
//        printf("\nTeIHG[%d] = %d",i,TeIHG[i]);
//    }
//    printf("\nLenHG = %d",LenHG);
//    printf(infonlpG);
//    printf(nlpbG);
//    printf(nlpgG);
//    printf(nlpigG);
//    printf(nlpsG);
//    printf(nlpigG,nlpsG);
}

void setNLPDV(const Number* Z, int Scaled)
{
    if (Scaled==1)
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpdvG.ScaledZ[i]      = Z[i];
            nlpdvG.UnscaledZ[i]    = (nlpdvG.ScaledZ[i]-nlpsG.ShiftZ[i])/nlpsG.ScaleZ[i];
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpdvG.ScaledZ[i]      = nlpsG.ScaleZ[i]*Z[i]+nlpsG.ShiftZ[i];
            nlpdvG.UnscaledZ[i]    = Z[i];
        }
    }
    else
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpdvG.ScaledZ[i]      = 0;
            nlpdvG.UnscaledZ[i]    = Z[i];
        }
    }
}

void setNLPOG(const Number* G, int Scaled)
{
    if (Scaled==1)
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpogG.ScaledGrad[i]   = G[i];
            nlpogG.UnscaledGrad[i] = nlpsG.ScaleZ[i]*G[i];
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpogG.ScaledGrad[i]   = G[i]/nlpsG.ScaleZ[i];
            nlpogG.UnscaledGrad[i] = G[i];
        }
    }
    else
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpogG.ScaledGrad[i]   = 0;
            nlpogG.UnscaledGrad[i] = G[i];
        }
    }
}

void setNLPLM(const Number* M, int Scaled)
{
    for (int i=0; i<LenZG; i++)
    {
        nlplmG.Costate[i] = 0;
    }
    
    if (Scaled==1)
    {
        for (int i=0; i<LenHG; i++)
        {
            nlplmG.ScaledL[i]      = M[i];
            nlplmG.UnscaledL[i]    = nlplmG.ScaledL[i]*nlpsG.ScaleH[i];
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<LenHG; i++)
        {
            nlplmG.ScaledL[i]      = M[i]/nlpsG.ScaleH[i];
            nlplmG.UnscaledL[i]    = M[i];
        }
    }
    else
    {
        for (int i=0; i<LenHG; i++)
        {
            nlplmG.ScaledL[i]      = 0;
            nlplmG.UnscaledL[i]    = M[i];
        }
    }
}

void setNLPCV(const Number* H, int Scaled)
{
    if (Scaled==1)
    {
        for (int i=0; i<LenHG; i++)
        {
            nlpcvG.ScaledH[i]   = H[i];
            nlpcvG.UnscaledH[i] = (nlpcvG.ScaledH[i]-nlpsG.ShiftH[i])/nlpsG.ScaleH[i];
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<LenHG; i++)
        {
            nlpcvG.ScaledH[i]   = nlpsG.ScaleH[i]*H[i]+nlpsG.ShiftH[i];
            nlpcvG.UnscaledH[i] = H[i];
        }
    }
    else
    {
        for (int i=0; i<LenHG; i++)
        {
            nlpcvG.ScaledH[i]   = 0;
            nlpcvG.UnscaledH[i] = H[i];
        }
    }
}

void setNLPCJ(const Number* J, int Scaled)
{
    if (Scaled==1)
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
            nlpcjG.ScaledJac[i]      = J[i];
            nlpcjG.UnscaledJac[i]    = nlpsG.ScaleZ[infonlpG.NLPJac.Col[i]]*J[i]/nlpsG.ScaleH[infonlpG.NLPJac.Row[i]];
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
            nlpcjG.ScaledJac[i]      = nlpsG.ScaleH[infonlpG.NLPJac.Row[i]]*J[i]/nlpsG.ScaleZ[infonlpG.NLPJac.Col[i]];
            nlpcjG.UnscaledJac[i]    = J[i];
        }
    }
    else
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
            nlpcjG.ScaledJac[i]    = 0;
            nlpcjG.UnscaledJac[i]  = J[i];
        }
    }
}

void setNLPLH(const Number* H, int Scaled)
{
    if (Scaled==1)
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
            nlplhG.ScaledHess[i]   = H[i];
            nlplhG.UnscaledHess[i] = H[i]*(nlpsG.ScaleZ[infonlpG.NLPHess.Row[i]]*nlpsG.ScaleZ[infonlpG.NLPHess.Col[i]]);
        }
    }
    else if (Scaled==2)
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
            nlplhG.ScaledHess[i]   = H[i]/(nlpsG.ScaleZ[infonlpG.NLPHess.Row[i]]*nlpsG.ScaleZ[infonlpG.NLPHess.Col[i]]);
            nlplhG.UnscaledHess[i] = H[i];
        }
    }
    else
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
            nlplhG.ScaledHess[i]   = 0;
            nlplhG.UnscaledHess[i] = H[i];
        }
    }
}

void setNLPDV(int Scaled)
{
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<LenZG; i++)
        {
//            nlpdvG.ScaledZ[i]      = Z[i];
            nlpdvG.UnscaledZ[i]    = (nlpdvG.ScaledZ[i]-nlpsG.ShiftZ[i])/nlpsG.ScaleZ[i];
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpdvG.ScaledZ[i]      = nlpsG.ScaleZ[i]*nlpdvG.UnscaledZ[i]+nlpsG.ShiftZ[i];
//            nlpdvG.UnscaledZ[i]    = Z[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpdvG.ScaledZ[i]      = 0;
            nlpdvG.UnscaledZ[i]    = 0;
        }
    }
}

void setNLPOG(int Scaled)
{
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<LenZG; i++)
        {
//            nlpogG.ScaledGrad[i]   = G[i];
            nlpogG.UnscaledGrad[i] = nlpsG.ScaleZ[i]*nlpogG.ScaledGrad[i];
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpogG.ScaledGrad[i]   = nlpogG.UnscaledGrad[i]/nlpsG.ScaleZ[i];
//            nlpogG.UnscaledGrad[i] = G[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<LenZG; i++)
        {
            nlpogG.ScaledGrad[i]   = 0;
            nlpogG.UnscaledGrad[i] = 0;
        }
    }
}

void setNLPLM(int Scaled)
{
//    for (int i=0; i<LenZG; i++)
//    {
//        nlplmG.Costate[i] = 0;
//    }
    
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<LenHG; i++)
        {
//            nlplmG.ScaledL[i]      = M[i];
            nlplmG.UnscaledL[i]    = nlplmG.ScaledL[i]*nlpsG.ScaleH[i];
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<LenHG; i++)
        {
            nlplmG.ScaledL[i]      = nlplmG.UnscaledL[i]/nlpsG.ScaleH[i];
//            nlplmG.UnscaledL[i]    = M[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<LenHG; i++)
        {
            nlplmG.ScaledL[i]      = 0;
            nlplmG.UnscaledL[i]    = 0;
        }
    }
}

void setNLPCV(int Scaled)
{
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<LenHG; i++)
        {
//            nlpcvG.ScaledH[i]   = H[i];
            nlpcvG.UnscaledH[i] = (nlpcvG.ScaledH[i]-nlpsG.ShiftH[i])/nlpsG.ScaleH[i];
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<LenHG; i++)
        {
            nlpcvG.ScaledH[i]   = nlpsG.ScaleH[i]*nlpcvG.UnscaledH[i]+nlpsG.ShiftH[i];
//            nlpcvG.UnscaledH[i] = H[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<LenHG; i++)
        {
            nlpcvG.ScaledH[i]   = 0;
            nlpcvG.UnscaledH[i] = 0;
        }
    }
}

void setNLPCJ(int Scaled)
{
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
//            nlpcjG.ScaledJac[i]      = J[i];
            nlpcjG.UnscaledJac[i]    = nlpsG.ScaleZ[infonlpG.NLPJac.Col[i]]*nlpcjG.ScaledJac[i]/nlpsG.ScaleH[infonlpG.NLPJac.Row[i]];
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
            nlpcjG.ScaledJac[i]      = nlpsG.ScaleH[infonlpG.NLPJac.Row[i]]*nlpcjG.UnscaledJac[i]/nlpsG.ScaleZ[infonlpG.NLPJac.Col[i]];
//            nlpcjG.UnscaledJac[i]    = J[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<infonlpG.NLPJac.Len; i++)
        {
            nlpcjG.ScaledJac[i]    = 0;
            nlpcjG.UnscaledJac[i]  = 0;
        }
    }
}

void setNLPLH(int Scaled)
{
    if (Scaled==1)  // Set unscaled values using scaled values
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
//            nlplhG.ScaledHess[i]   = H[i];
            nlplhG.UnscaledHess[i] = nlplhG.ScaledHess[i]*(nlpsG.ScaleZ[infonlpG.NLPHess.Row[i]]*nlpsG.ScaleZ[infonlpG.NLPHess.Col[i]]);
        }
    }
    else if (Scaled==2) // Set scaled values using unscaled values
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
            nlplhG.ScaledHess[i]   = nlplhG.UnscaledHess[i]/(nlpsG.ScaleZ[infonlpG.NLPHess.Row[i]]*nlpsG.ScaleZ[infonlpG.NLPHess.Col[i]]);
//            nlplhG.UnscaledHess[i] = H[i];
        }
    }
    else    // Set values to zero
    {
        for (int i=0; i<infonlpG.NLPHess.Len; i++)
        {
            nlplhG.ScaledHess[i]   = 0;
            nlplhG.UnscaledHess[i] = 0;
        }
    }
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------NLP Constraints functions-------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void defect_func(const int& phase, const int& component, phaseInfo& phaseinfo, doubleMat& defectMat)  // Defect function of NLP, inputs are the current phase (ccode index), the current component (ccode index), phaseInfo structure for current phase, doubleMat structure ptMat for each point in phase
{
    double DXsum;   // variable for holding differentiation matrix row times state vector
    int point;
    
    for (point=0; point<NtG[phase]; point++)    // For each collocation point in problem
    {
        DXsum = 0;
        for (int ind=0; ind<rpmdG[phase].DOffCnt; ind++)    // for each off-diagonal element in differentiation matrix in phase
        {
            // off-diagonal element row index
            if (rpmdG[phase].DOffDiagIO[ind] == point)    // If row index corresponds to current point
            {
                // off-diagonal element value
                // off-diagonal element column index
                DXsum = DXsum + rpmdG[phase].DOffDiagValO[ind]*phaseinfo.ptInfo[rpmdG[phase].DOffDiagJO[ind]].x[component]; // product of off-diagonal value with state value of corresponding point added to DXsum
            }
        }
        // diagonal element value corresponding to current point
        DXsum = DXsum + rpmdG[phase].DDiagValO[point]*phaseinfo.ptInfo[point].x[component]; // product of diagonal value with state value of corresponding point added to DXsum
        
        // Compute defect constraint at point
        defectMat.val[point] = DXsum - 0.5*(phaseinfo.tf-phaseinfo.t0)*DynamicFuncValG.mat[phase].mat[component].val[point];
    }
    if (LavrentievConstraintFlagG)
    {
        point = NtG[phase];
        DXsum = 0;
        for (int ind=0; ind<(rpmdG[phase].ColPoints[rpmdG[phase].NumInterval-1]+1); ind++)  // for discretization point in last interval of phase
        {
            DXsum = DXsum + rpmdG[phase].LavRowO.val[ind]*phaseinfo.ptInfo[rpmdG[phase].sumColPoints-rpmdG[phase].ColPoints[rpmdG[phase].NumInterval-1]+ind].x[component];  // product of differentiation matrix values for Lavrentiev constraints with state value of corresponding point added to DXsum
        }
        
        // Compute defect constraint at point
        defectMat.val[point] = DXsum - 0.5*(phaseinfo.tf-phaseinfo.t0)*DynamicFuncValG.mat[phase].mat[component].val[point];
    }
}

void approx_func(const int& phase, const int& component, phaseInfo& phaseinfo, double& approximationValue)    // Approximation function of NLP, inputs are the current phase (ccode index), the current component (ccode index), phaseInfo structure for current phase, and double address to store value
{
    double WGsum=0;   // variable for holding value of weights vector times lagrange functions at each point
    
    for (int point=0; point<NtG[phase]; point++)    // For each collocation point in phase
    {
        // Compute lagrange cost of component at point in phase
        WGsum = WGsum + rpmdG[phase].weightO[point]*LagrangeFuncValG.mat[phase].mat[component].val[point];   // Add integrand values times LGR weight at point to sum
    }
    
    approximationValue = phaseinfo.q[component] - 0.5*(phaseinfo.tf-phaseinfo.t0)*WGsum;  // Compute approximation constraint
}



////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------Central Finite Difference functions--------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

/*-----------------------------------Gradient Functions-----------------------------------*/

void obj_func_Grad_CD(const int& phase, const int& varA, const int& comA, systemInfo& systeminfosol, doubleMat& endpointsparametersMatSol, systemInfo& systeminfo, doubleMat& endpointsparametersMat, double& objectiveGradValue, double& stepSize0)  // First-order derivative approximation using central finite differences for objective functions of original optimal control problem, inputs are the current phase (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient for desired partial, unscaled step size for central finite differences
{
    double stepSizeA;
    double perturbEvalPos, perturbEvalNeg;
    int component=-1;
    
    int funcType = 1;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step size using variable magnitude
    GetSystemEndpointVariableStepSize(phase,varA,comA,systeminfosol,stepSize0,stepSizeA);
    
    /*--------------- Central Finite Difference Positive Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phase,varA,comA,systeminfo,stepSizeA);
    
    // Perturb dependent endpoint parameters using positive step
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA);
    
    // Compute objective function in phase with perturbed system using positive step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPos);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);

    /*--------------- Central Finite Difference Negative Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phase,varA,comA,systeminfo,stepSizeA);
    
    // Perturb dependent endpoint parameters using negative step
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA);
    
    // Compute objective function in phase with perturbed system using negative step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNeg);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);

    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate first-derivative
    objectiveGradValue = (perturbEvalPos-perturbEvalNeg)/(2*stepSizeA);
}

void dyn_func_Grad_CD(const int& phase, const int& component, const int& varA, const int& comA, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& dynamicGradMat, double& stepSize0) // First-order derivative approximation using central finite differences for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(dynamicGradMat.Len);   // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPos(dynamicGradMat.Len), perturbEvalsNeg(dynamicGradMat.Len); // Allocate memory for number of discretization points in phase
    
    int funcType = 2;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    
    /*--------------- Central Finite Difference Positive Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using positive step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute dynamic function at discretization points in phase with perturbed system using positive step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*--------------- Central Finite Difference Negative Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using negative step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute dynamic function at discretization points in phase with perturbed system using negative step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate first-derivative
    for (int pt=0; pt<dynamicGradMat.Len; pt++)
    {
        dynamicGradMat.val[pt] = (perturbEvalsPos.val[pt]-perturbEvalsNeg.val[pt])/(2*stepSizesA.val[pt]);
    }
}

void path_func_Grad_CD(const int& phase, const int& component, const int& varA, const int& comA, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& pathGradMat, double& stepSize0)   // First-order derivative approximation using central finite differences for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(pathGradMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPos(pathGradMat.Len), perturbEvalsNeg(pathGradMat.Len);   // Allocate memory for number of discretization points in phase
    
    int funcType = 3;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    
    /*--------------- Central Finite Difference Positive Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using positive step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system using positive step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*--------------- Central Finite Difference Negative Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using negative step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system using negative step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate first-derivative
    for (int pt=0; pt<pathGradMat.Len; pt++) // For each
    {
        pathGradMat.val[pt] = (perturbEvalsPos.val[pt]-perturbEvalsNeg.val[pt])/(2*stepSizesA.val[pt]); // Compute derivative approximation at point
    }
}

void lag_func_Grad_CD(const int& phase, const int& component, const int& varA, const int& comA, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& lagrangeGradMat, double& stepSize0)    // First-order derivative approximation using central finite differences for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(lagrangeGradMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPos(lagrangeGradMat.Len), perturbEvalsNeg(lagrangeGradMat.Len);   // Allocate memory for number of discretization points in phase
    
    int funcType = 4;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    
    /*--------------- Central Finite Difference Positive Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using positive step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute lagrange function at discretization points in phase with perturbed system using positive step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*--------------- Central Finite Difference Negative Perturbations --------------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    
    // Perturb dependent phase parameters using negative step
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute lagrange function at discretization points in phase with perturbed system using negative step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate first-derivative
    for (int pt=0; pt<lagrangeGradMat.Len; pt++) // For each
    {
        lagrangeGradMat.val[pt] = (perturbEvalsPos.val[pt]-perturbEvalsNeg.val[pt])/(2*stepSizesA.val[pt]); // Compute derivative approximation at point
    }
}

void eve_func_Grad_CD(const int& component, const int& phaA, const int& varA, const int& comA, systemInfo& systeminfosol, doubleMat& endpointsparametersMatSol, systemInfo& systeminfo, doubleMat& endpointsparametersMat, double& eventGradValue, double& stepSize0) // First-order derivative approximation using central finite differences for event functions of original optimal control problem, inputs are the current event (ccode index), phase of variable (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for current phase, solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient for desired partial, unscaled step size for central finite differences
{
    double stepSizeA;
    double perturbEvalPos, perturbEvalNeg;
    int phase=-1;
    
    int funcType = 5;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step size using variable magnitude
    GetSystemEndpointVariableStepSize(phaA,varA,comA,systeminfosol,stepSize0,stepSizeA);
    
    /*--------------- Central Finite Difference Positive Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phaA,varA,comA,systeminfo,stepSizeA);
    
    // Perturb dependent endpoint parameters using positive step
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA);
    
    // Compute event function component with perturbed system using positive step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPos);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    
    /*--------------- Central Finite Difference Negative Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phaA,varA,comA,systeminfo,stepSizeA);
    
    // Perturb dependent endpoint parameters using negative step
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA);
    
    // Compute event function component with perturbed system using negative step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNeg);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate first-derivative
    eventGradValue = (perturbEvalPos-perturbEvalNeg)/(2*stepSizeA);
}

/*-----------------------------------Hessian  Functions-----------------------------------*/

void obj_func_Hess_CD(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, systemInfo& systeminfosol, doubleMat& endpointsparametersMatSol, systemInfo& systeminfo, doubleMat& endpointsparametersMat, double& objectiveHessValue, double& stepSize0)    // Second-order derivative approximation using central finite differences for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution system information structure for problem, solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective hessian for desired partial, unscaled step size for central finite differences
{
    double stepSizeA,stepSizeB;
    double perturbEvalPosPos, perturbEvalPosNeg, perturbEvalNegPos, perturbEvalNegNeg;
    int component=-1;
    
    int funcType = 1;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step size using variable magnitude
    GetSystemEndpointVariableStepSize(phase,varA,comA,systeminfosol,stepSize0,stepSizeA);
    GetSystemEndpointVariableStepSize(phase,varB,comB,systeminfosol,stepSize0,stepSizeB);
    
    /*---------- Central Finite Difference Positive/Positive Perturbations ----------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phase,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeB
    PerturbSystemEndpointVariablePlus(phase,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using positive/positive step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system using positive/positive step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPosPos);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phase,varB,comB,systeminfosol,systeminfo);
    }
    
    /*---------- Central Finite Difference Positive/Negative Perturbations ----------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phase,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeB
    PerturbSystemEndpointVariableMinus(phase,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using positive/negative step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system using positive/negative step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPosNeg);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phase,varB,comB,systeminfosol,systeminfo);
    }
    
    /*---------- Central Finite Difference Negative/Positive Perturbations ----------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phase,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeB
    PerturbSystemEndpointVariablePlus(phase,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using negative/positive step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system using negative/positive step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNegPos);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phase,varB,comB,systeminfosol,systeminfo);
    }
    
    /*---------- Central Finite Difference Negative/Negative Perturbations ----------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phase,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeB
    PerturbSystemEndpointVariableMinus(phase,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using negative/negative step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system using negative/negative step
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNegNeg);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phase,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phase,varB,comB,systeminfosol,systeminfo);
    }
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate second-derivative
    objectiveHessValue = (perturbEvalPosPos-perturbEvalPosNeg-perturbEvalNegPos+perturbEvalNegNeg)/(4*stepSizeA*stepSizeB);
}

void dyn_func_Hess_CD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& dynamicHessMat, double& stepSize0)   // Second-order derivative approximation using central finite differences for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic hessian for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(dynamicHessMat.Len),stepSizesB(dynamicHessMat.Len);    // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPosPos(dynamicHessMat.Len), perturbEvalsPosNeg(dynamicHessMat.Len), perturbEvalsNegPos(dynamicHessMat.Len), perturbEvalsNegNeg(dynamicHessMat.Len);   // Allocate memory for number of discretization points in phase
    
    int funcType = 2;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    GetSystemPhaseVariablesStepSizes(phase,varB,comB,systeminfosol,stepSize0,stepSizesB);
    
    /*----------- Central Finite Difference Positive/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system using positive/positive step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Positive/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system using positive/negative step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system using negative/positive step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system using negative/negative step
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++) // For each discretization point in phase
    {
        dynamicHessMat.val[pt] = (perturbEvalsPosPos.val[pt]-perturbEvalsPosNeg.val[pt]-perturbEvalsNegPos.val[pt]+perturbEvalsNegNeg.val[pt])/(4*stepSizesA.val[pt]*stepSizesB.val[pt]);   // Compute derivative approximation at point
    }
}

void path_func_Hess_CD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& pathHessMat, double& stepSize0) // Second-order derivative approximation using central finite differences for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path hessian for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(pathHessMat.Len),stepSizesB(pathHessMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPosPos(pathHessMat.Len), perturbEvalsPosNeg(pathHessMat.Len), perturbEvalsNegPos(pathHessMat.Len), perturbEvalsNegNeg(pathHessMat.Len);   // Allocate memory for number of discretization points in phase
    
    int funcType = 3;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    GetSystemPhaseVariablesStepSizes(phase,varB,comB,systeminfosol,stepSize0,stepSizesB);
    
    /*----------- Central Finite Difference Positive/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system using positive/positive step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Positive/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system using positive/negative step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system using negative/positive step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system using negative/negative step
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)    // For each discretization point in phase
    {
        pathHessMat.val[pt] = (perturbEvalsPosPos.val[pt]-perturbEvalsPosNeg.val[pt]-perturbEvalsNegPos.val[pt]+perturbEvalsNegNeg.val[pt])/(4*stepSizesA.val[pt]*stepSizesB.val[pt]);   // Compute derivative approximation at point
    }
}

void lag_func_Hess_CD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, systemInfo& systeminfosol, ParametersStruct& phaseparametersStructSol, systemInfo& systeminfo, ParametersStruct& phaseparametersStruct, doubleMat& lagrangeHessMat, double& stepSize0)  // Second-order derivative approximation using central finite differences for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution system information structure for problem, solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange hessian for desired partial at each point, unscaled step size for central finite differences
{
    doubleMat stepSizesA(lagrangeHessMat.Len),stepSizesB(lagrangeHessMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat perturbEvalsPosPos(lagrangeHessMat.Len), perturbEvalsPosNeg(lagrangeHessMat.Len), perturbEvalsNegPos(lagrangeHessMat.Len), perturbEvalsNegNeg(lagrangeHessMat.Len);   // Allocate memory for number of discretization points in phase
    
    int funcType = 4;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step sizes using variable magnitudes at each point
    GetSystemPhaseVariablesStepSizes(phase,varA,comA,systeminfosol,stepSize0,stepSizesA);
    GetSystemPhaseVariablesStepSizes(phase,varB,comB,systeminfosol,stepSize0,stepSizesB);
    
    /*----------- Central Finite Difference Positive/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed system using positive/positive step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Positive/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesA
    PerturbSystemPhaseVariablesPlus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using positive/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed system using positive/negative step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsPosNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Positive Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using positive steps stepSizesB
    PerturbSystemPhaseVariablesPlus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/positive step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed system using negative/positive step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegPos);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*----------- Central Finite Difference Negative/Negative Perturbations ---------*/
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesA
    PerturbSystemPhaseVariablesMinus(phase,varA,comA,systeminfo,stepSizesA);
    // Perturb appropriate phase variables for derivative approximation using negative steps stepSizesB
    PerturbSystemPhaseVariablesMinus(phase,varB,comB,systeminfo,stepSizesB);
    
    // Perturb dependent phase parameters using negative/negative step
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed system using negative/negative step
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvalsNegNeg);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation
    UnperturbSystemPhaseVariables(phase,varA,comA,systeminfosol,systeminfo,stepSizesA);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        UnperturbSystemPhaseVariables(phase,varB,comB,systeminfosol,systeminfo,stepSizesB);
    }
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)    // For each discretization point in phase
    {
        lagrangeHessMat.val[pt] = (perturbEvalsPosPos.val[pt]-perturbEvalsPosNeg.val[pt]-perturbEvalsNegPos.val[pt]+perturbEvalsNegNeg.val[pt])/(4*stepSizesA.val[pt]*stepSizesB.val[pt]);  // Compute derivative approximation at point
    }
}

void eve_func_Hess_CD(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, systemInfo& systeminfosol, doubleMat& endpointsparametersMatSol, systemInfo& systeminfo, doubleMat& endpointsparametersMat, double& eventHessValue, double& stepSize0)  // Second-order derivative approximation using central finite differences for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution system information structure for current phase, solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event hessian for desired partial, unscaled step size for central finite differences
{
    double stepSizeA,stepSizeB;
    double perturbEvalPosPos, perturbEvalPosNeg, perturbEvalNegPos, perturbEvalNegNeg;
    int phase=-1;
    
    int funcType = 5;
    
    /*----------------- Central Finite Difference Step Size Scaling -----------------*/
    // Compute appropriate step size using variable magnitude
    GetSystemEndpointVariableStepSize(phaA,varA,comA,systeminfosol,stepSize0,stepSizeA);
    GetSystemEndpointVariableStepSize(phaB,varB,comB,systeminfosol,stepSize0,stepSizeB);
    
    /*--------------- Central Finite Difference Positive/Positive Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phaA,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeB
    PerturbSystemEndpointVariablePlus(phaB,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using positive/positive step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute event function component with perturbed system using positive/positive step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPosPos);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phaB,varB,comB,systeminfosol,systeminfo);
    }
    
    /*--------------- Central Finite Difference Positive/Negative Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeA
    PerturbSystemEndpointVariablePlus(phaA,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeB
    PerturbSystemEndpointVariableMinus(phaB,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using positive/negative step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute event function component with perturbed system using positive/negative step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalPosNeg);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phaB,varB,comB,systeminfosol,systeminfo);
    }
    
    /*--------------- Central Finite Difference Positive/Positive Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phaA,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using positive step size stepSizeB
    PerturbSystemEndpointVariablePlus(phaB,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using negative/positive step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute event function component with perturbed system using negative/positive step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNegPos);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phaB,varB,comB,systeminfosol,systeminfo);
    }
    
    /*--------------- Central Finite Difference Positive/Positive Perturbations --------------*/
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeA
    PerturbSystemEndpointVariableMinus(phaA,varA,comA,systeminfo,stepSizeA);
    // Perturb appropriate endpoint variable for derivative approximation using negative step size stepSizeB
    PerturbSystemEndpointVariableMinus(phaB,varB,comB,systeminfo,stepSizeB);
    
    // Perturb dependent endpoint parameters using negative/negative step
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute event function component with perturbed system using negative/negative step
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEvalNegNeg);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation
    UnperturbSystemEndpointVariable(phaA,varA,comA,systeminfosol,systeminfo);
    if ((varA!=varB)||(comA!=comB)) // If mixed partial
    {
        // Unperturb appropriate endpoint variable for derivative approximation
        UnperturbSystemEndpointVariable(phaB,varB,comB,systeminfosol,systeminfo);
    }
    
    /*-------------- Central Finite Difference Derivative Approximation -------------*/
    // Use central finite difference to estimate second-derivative
    eventHessValue = (perturbEvalPosPos-perturbEvalPosNeg-perturbEvalNegPos+perturbEvalNegNeg)/(4*stepSizeA*stepSizeB);
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------Bicomplex-step functions--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

/*-----------------------------------Gradient Functions-----------------------------------*/

void obj_func_Grad_BC(const int& phase, const int& varA, const int& comA, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& objectiveGradValue, double& stepSize0) // First-order derivative approximation using bicomplex-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phase,varA,comA,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA);
    
    // Compute objective function in phase with perturbed system in I1 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phase,varA,comA,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative
    objectiveGradValue = perturbEval.I1/stepSize0;
}

void dyn_func_Grad_BC(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& dynamicGradMat, double& stepSize0)  // First-order derivative approximation using bicomplex-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(dynamicGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute dynamic function at discretization points in phase with perturbed system in I1 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative
    for (int pt=0; pt<dynamicGradMat.Len; pt++)
    {
        dynamicGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
}

void path_func_Grad_BC(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& pathGradMat, double& stepSize0)    // First-order derivative approximation using bicomplex-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(pathGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    
    int funcType = 3;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system in I1 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative
    for (int pt=0; pt<pathGradMat.Len; pt++)
    {
        pathGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
}

void lag_func_Grad_BC(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& lagrangeGradMat, double& stepSize0) // First-order derivative approximation using bicomplex-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(lagrangeGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system in I1 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative
    for (int pt=0; pt<lagrangeGradMat.Len; pt++)
    {
        lagrangeGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
}
void eve_func_Grad_BC(const int& component, const int& phaA, const int& varA, const int& comA, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& eventGradValue, double& stepSize0) // First-order derivative approximation using bicomplex-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of variable (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int phase=-1;
//    printf(perturbEval);
    
    int funcType = 5;
//    printf(systeminfo);
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo,stepSize0);
//    printf(systeminfo);
    
//    printf(endpointsparametersMat);
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA);
//    printf(endpointsparametersMat);
    
    // Compute objective function in phase with perturbed system in I1 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo);
    
//    printf(perturbEval);
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative
    eventGradValue = perturbEval.I1/stepSize0;
}

/*-----------------------------------Hessian  Functions-----------------------------------*/

void obj_func_Hess_BC(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& objectiveHessValue, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phase,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate second-derivative
    objectiveHessValue = perturbEval.I1I2/(stepSize0*stepSize0);
}

void dyn_func_Hess_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& dynamicHessMat, double& stepSize0)    // Second-order derivative approximation using bicomplex-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(dynamicHessMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicHessMat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in I1 & I2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void path_func_Hess_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& pathHessMat, double& stepSize0)  // Second-order derivative approximation using bicomplex-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(pathHessMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathHessMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in I1 & I2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void lag_func_Hess_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& lagrangeHessMat, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(lagrangeHessMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeHessMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in I1 & I2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void eve_func_Hess_BC(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& eventHessValue, double& stepSize0)  // Second-order derivative approximation using bicomplex-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate second-derivative
    eventHessValue = perturbEval.I1I2/(stepSize0*stepSize0);
}

/*-------------------------------Gradient Hessian  Functions------------------------------*/

void obj_func_GH_BC(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& objectiveGradValue, double& objectiveHessValue, double& stepSize0)  // Second-order derivative approximation using bicomplex-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient for desired partial, double for holding value of objective hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);
    
    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phase,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    objectiveGradValue = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate second-derivative
    objectiveHessValue  = perturbEval.I1I2/(stepSize0*stepSize0);
}

void dyn_func_GH_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& dynamicGradMat, doubleMat& dynamicHessMat, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(dynamicGradMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGradMat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in I1 & I2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGradMat.Len; pt++)
    {
        dynamicGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void path_func_GH_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& pathGradMat, doubleMat& pathHessMat, double& stepSize0)    // Second-order derivative approximation using bicomplex-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient for desired partial at each point, doubleMat for holding values of path hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(pathGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGradMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in I1 & I2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGradMat.Len; pt++)
    {
        pathGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void lag_func_GH_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& lagrangeGradMat, doubleMat& lagrangeHessMat, double& stepSize0) // Second-order derivative approximation using bicomplex-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient for desired partial at each point, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(lagrangeGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGradMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in I1 & I2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGradMat.Len; pt++)
    {
        lagrangeGradMat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void eve_func_GH_BC(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& eventGradValue, double& eventHessValue, double& stepSize0)    // Second-order derivative approximation using bicomplex-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient for desired partial, double for holding value of event hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    eventGradValue = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate second-derivative
    eventHessValue = perturbEval.I1I2/(stepSize0*stepSize0);
}

/*-------------------------------Mixed Gradient Functions------------------------------*/

void obj_func_GG_BC(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& objectiveGrad1Value, double& objectiveGrad2Value, double& stepSize0)    // First-order derivative approximation using bicomplex-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient 1 for desired partial, double for holding value of objective gradient 2 for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phase,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    objectiveGrad1Value = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate first-derivative wrt second variable
    objectiveGrad2Value = perturbEval.I2/stepSize0;
}

void dyn_func_GG_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& dynamicGrad1Mat, doubleMat& dynamicGrad2Mat, double& stepSize0) // First-order derivative approximation using bicomplex-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, doubleMat for holding values of dynamic gradient for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(dynamicGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in I1 & I2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGrad1Mat.Len; pt++)
    {
        dynamicGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<dynamicGrad2Mat.Len; pt++)
    {
        dynamicGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
}

void path_func_GG_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& pathGrad1Mat, doubleMat& pathGrad2Mat, double& stepSize0)  // First-order derivative approximation using bicomplex-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient 1 for desired partial at each point, doubleMat for holding values of path gradient 2 for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(pathGrad1Mat.Len);    // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGrad1Mat.Len);          // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in I1 & I2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGrad1Mat.Len; pt++)
    {
        pathGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<pathGrad2Mat.Len; pt++)
    {
        pathGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
}

void lag_func_GG_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& lagrangeGrad1Mat, doubleMat& lagrangeGrad2Mat, double& stepSize0)   // First-order derivative approximation using bicomplex-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient 1 for desired partial at each point, doubleMat for holding values of lagrange gradient 2 for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(lagrangeGrad1Mat.Len);    // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGrad1Mat.Len);          // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in I1 & I2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGrad1Mat.Len; pt++)
    {
        lagrangeGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<lagrangeGrad2Mat.Len; pt++)
    {
        lagrangeGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
}

void eve_func_GG_BC(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& eventGrad1Value, double& eventGrad2Value, double& stepSize0)  // First-order derivative approximation using bicomplex-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient 1 for desired partial, double for holding value of event gradient 2 for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    eventGrad1Value = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate first-derivative wrt first variable
    eventGrad2Value = perturbEval.I2/stepSize0;
}

/*--------------------------------Mixed Hessian  Functions---------------------------------*/

void obj_func_Mixed_BC(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& objectiveGrad1Value, double& objectiveGrad2Value, double& objectiveHessValue, double& stepSize0) // Second-order derivative approximation using bicomplex-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient 1 for desired partial, double for holding value of objective gradient 2 for desired partial, double for holding value of objective hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phase,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    objectiveGrad1Value = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate first-derivative wrt second variable
    objectiveGrad2Value = perturbEval.I2/stepSize0;
    // Use bicomplex-step to estimate second-derivative
    objectiveHessValue  = perturbEval.I1I2/(stepSize0*stepSize0);
}

void dyn_func_Mixed_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& dynamicGrad1Mat, doubleMat& dynamicGrad2Mat, doubleMat& dynamicHessMat, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient 1 for desired partial at each point, doubleMat for holding values of dynamic gradient 2 for desired partial at each point, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(dynamicGrad1Mat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGrad1Mat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in I1 & I2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGrad1Mat.Len; pt++)
    {
        dynamicGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<dynamicGrad2Mat.Len; pt++)
    {
        dynamicGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void path_func_Mixed_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& pathGrad1Mat, doubleMat& pathGrad2Mat, doubleMat& pathHessMat, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient 1 for desired partial at each point, doubleMat for holding values of path gradient 2 for desired partial at each point, doubleMat for holding values of path hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(pathGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in I1 & I2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGrad1Mat.Len; pt++)
    {
        pathGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<pathGrad2Mat.Len; pt++)
    {
        pathGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void lag_func_Mixed_BC(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoBC& systeminfo, ParametersStructBC& phaseparametersStruct, doubleMat& lagrangeGrad1Mat, doubleMat& lagrangeGrad2Mat, doubleMat& lagrangeHessMat, double& stepSize0)    // Second-order derivative approximation using bicomplex-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient 1 for desired partial at each point, doubleMat for holding values of lagrange gradient 2 for desired partial at each point, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for bicomplex-step
{
    BicomplexMat perturbEvals(lagrangeGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in I1 direction by stepSizes0
    PerturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in I2 direction by stepSizes0
    PerturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in I1 & I2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in I1 direction
    UnperturbSystemPhaseVariablesI2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGrad1Mat.Len; pt++)
    {
        lagrangeGrad1Mat.val[pt] = perturbEvals.val[pt].I1/stepSize0;
    }
    // Use bicomplex-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<lagrangeGrad2Mat.Len; pt++)
    {
        lagrangeGrad2Mat.val[pt] = perturbEvals.val[pt].I2/stepSize0;
    }
    // Use bicomplex-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].I1I2/(stepSize0*stepSize0);
    }
}

void eve_func_Mixed_BC(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoBC& systeminfo, BicomplexMat& endpointsparametersMat, double& eventGrad1Value, double& eventGrad2Value, double& eventHessValue, double& stepSize0)   // Second-order derivative approximation using bicomplex-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient 1 for desired partial, double for holding value of event gradient 2 for desired partial, double for holding value of event hessian for desired partial, step size for bicomplex-step
{
    Bicomplex perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- Bicomplex-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in I1 direction by step size stepSize0
    PerturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in I2 direction by step size stepSize0
    PerturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in I1 & I2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in I1 direction
    UnperturbSystemEndpointVariableI1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in I2 direction
    UnperturbSystemEndpointVariableI2(phaB,varB,comB,systeminfo);
    
    /*------------------- Bicomplex-step Derivative Approximation -------------------*/
    // Use bicomplex-step to estimate first-derivative wrt first variable
    eventGrad1Value = perturbEval.I1/stepSize0;
    // Use bicomplex-step to estimate first-derivative wrt second variable
    eventGrad2Value = perturbEval.I2/stepSize0;
    // Use bicomplex-step to estimate second-derivative
    eventHessValue = perturbEval.I1I2/(stepSize0*stepSize0);
}


////////////////////////////////////////////////////////////////////////////////////////////////
//------------------------------------HyperDual-step functions--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

/*-----------------------------------Gradient Functions-----------------------------------*/

void obj_func_Grad_HD(const int& phase, const int& varA, const int& comA, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& objectiveGradValue, double& stepSize0) // First-order derivative approximation using HyperDual-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution system information structure for problem, solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phase,varA,comA,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA);
    
    // Compute objective function in phase with perturbed system in E1 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phase,varA,comA,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative
    objectiveGradValue = perturbEval.E1/stepSize0;
}

void dyn_func_Grad_HD(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& dynamicGradMat, double& stepSize0)  // First-order derivative approximation using HyperDual-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(dynamicGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute dynamic function at discretization points in phase with perturbed system in E1 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative
    for (int pt=0; pt<dynamicGradMat.Len; pt++)
    {
        dynamicGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
}

void path_func_Grad_HD(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& pathGradMat, double& stepSize0)    // First-order derivative approximation using HyperDual-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(pathGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    
    int funcType = 3;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system in E1 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative
    for (int pt=0; pt<pathGradMat.Len; pt++)
    {
        pathGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
}

void lag_func_Grad_HD(const int& phase, const int& component, const int& varA, const int& comA, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& lagrangeGradMat, double& stepSize0) // First-order derivative approximation using HyperDual-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(lagrangeGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGradMat.Len);    // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersA(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA);
    
    // Compute path function at discretization points in phase with perturbed system in E1 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersA(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative
    for (int pt=0; pt<lagrangeGradMat.Len; pt++)
    {
        lagrangeGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
}
void eve_func_Grad_HD(const int& component, const int& phaA, const int& varA, const int& comA, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& eventGradValue, double& stepSize0) // First-order derivative approximation using HyperDual-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of variable (ccode index), variable type to be perturbed, component of variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int phase=-1;
    //    printf(perturbEval);
    
    int funcType = 5;
    //    printf(systeminfo);
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo,stepSize0);
    //    printf(systeminfo);
    
    //    printf(endpointsparametersMat);
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersA(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA);
    //    printf(endpointsparametersMat);
    
    // Compute objective function in phase with perturbed system in E1 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersA(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo);
    
    //    printf(perturbEval);
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative
    eventGradValue = perturbEval.E1/stepSize0;
}

/*-----------------------------------Hessian  Functions-----------------------------------*/

void obj_func_Hess_HD(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& objectiveHessValue, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phase,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate second-derivative
    objectiveHessValue = perturbEval.E1E2/(stepSize0*stepSize0);
}

void dyn_func_Hess_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& dynamicHessMat, double& stepSize0)    // Second-order derivative approximation using HyperDual-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(dynamicHessMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicHessMat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in E1 & E2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void path_func_Hess_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& pathHessMat, double& stepSize0)  // Second-order derivative approximation using HyperDual-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(pathHessMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathHessMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in E1 & E2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void lag_func_Hess_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& lagrangeHessMat, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(lagrangeHessMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeHessMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in E1 & E2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void eve_func_Hess_HD(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& eventHessValue, double& stepSize0)  // Second-order derivative approximation using HyperDual-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate second-derivative
    eventHessValue = perturbEval.E1E2/(stepSize0*stepSize0);
}

/*-------------------------------Gradient Hessian  Functions------------------------------*/

void obj_func_GH_HD(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& objectiveGradValue, double& objectiveHessValue, double& stepSize0)  // Second-order derivative approximation using HyperDual-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient for desired partial, double for holding value of objective hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phase,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    objectiveGradValue = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate second-derivative
    objectiveHessValue  = perturbEval.E1E2/(stepSize0*stepSize0);
}

void dyn_func_GH_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& dynamicGradMat, doubleMat& dynamicHessMat, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(dynamicGradMat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGradMat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in E1 & E2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGradMat.Len; pt++)
    {
        dynamicGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void path_func_GH_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& pathGradMat, doubleMat& pathHessMat, double& stepSize0)    // Second-order derivative approximation using HyperDual-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient for desired partial at each point, doubleMat for holding values of path hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(pathGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGradMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in E1 & E2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGradMat.Len; pt++)
    {
        pathGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void lag_func_GH_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& lagrangeGradMat, doubleMat& lagrangeHessMat, double& stepSize0) // Second-order derivative approximation using HyperDual-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient for desired partial at each point, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(lagrangeGradMat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGradMat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in E1 & E2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGradMat.Len; pt++)
    {
        lagrangeGradMat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void eve_func_GH_HD(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& eventGradValue, double& eventHessValue, double& stepSize0)    // Second-order derivative approximation using HyperDual-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient for desired partial, double for holding value of event hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    eventGradValue = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate second-derivative
    eventHessValue = perturbEval.E1E2/(stepSize0*stepSize0);
}

/*-------------------------------Mixed Gradient Functions------------------------------*/

void obj_func_GG_HD(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& objectiveGrad1Value, double& objectiveGrad2Value, double& stepSize0)    // First-order derivative approximation using HyperDual-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient 1 for desired partial, double for holding value of objective gradient 2 for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phase,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    objectiveGrad1Value = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate first-derivative wrt second variable
    objectiveGrad2Value = perturbEval.E2/stepSize0;
}

void dyn_func_GG_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& dynamicGrad1Mat, doubleMat& dynamicGrad2Mat, double& stepSize0) // First-order derivative approximation using HyperDual-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient for desired partial at each point, doubleMat for holding values of dynamic gradient for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(dynamicGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in E1 & E2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGrad1Mat.Len; pt++)
    {
        dynamicGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<dynamicGrad2Mat.Len; pt++)
    {
        dynamicGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
}

void path_func_GG_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& pathGrad1Mat, doubleMat& pathGrad2Mat, double& stepSize0)  // First-order derivative approximation using HyperDual-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient 1 for desired partial at each point, doubleMat for holding values of path gradient 2 for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(pathGrad1Mat.Len);    // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGrad1Mat.Len);          // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in E1 & E2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGrad1Mat.Len; pt++)
    {
        pathGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<pathGrad2Mat.Len; pt++)
    {
        pathGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
}

void lag_func_GG_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& lagrangeGrad1Mat, doubleMat& lagrangeGrad2Mat, double& stepSize0)   // First-order derivative approximation using HyperDual-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient 1 for desired partial at each point, doubleMat for holding values of lagrange gradient 2 for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(lagrangeGrad1Mat.Len);    // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGrad1Mat.Len);          // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in E1 & E2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGrad1Mat.Len; pt++)
    {
        lagrangeGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<lagrangeGrad2Mat.Len; pt++)
    {
        lagrangeGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
}

void eve_func_GG_HD(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& eventGrad1Value, double& eventGrad2Value, double& stepSize0)  // First-order derivative approximation using HyperDual-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient 1 for desired partial, double for holding value of event gradient 2 for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    eventGrad1Value = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate first-derivative wrt first variable
    eventGrad2Value = perturbEval.E2/stepSize0;
}

/*--------------------------------Mixed Hessian  Functions---------------------------------*/

void obj_func_Mixed_HD(const int& phase, const int& varA, const int& comA, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& objectiveGrad1Value, double& objectiveGrad2Value, double& objectiveHessValue, double& stepSize0) // Second-order derivative approximation using HyperDual-step for objective functions of original optimal control problem, inputs are the current phase (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for problem, endpoints parameters for problem, double for holding value of objective gradient 1 for desired partial, double for holding value of objective gradient 2 for desired partial, double for holding value of objective hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int component=-1;
    
    int funcType = 1;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phase,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phase,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    obj_func(systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phase,varA,comA,phase,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phase,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phase,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    objectiveGrad1Value = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate first-derivative wrt second variable
    objectiveGrad2Value = perturbEval.E2/stepSize0;
    // Use HyperDual-step to estimate second-derivative
    objectiveHessValue  = perturbEval.E1E2/(stepSize0*stepSize0);
}

void dyn_func_Mixed_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& dynamicGrad1Mat, doubleMat& dynamicGrad2Mat, doubleMat& dynamicHessMat, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for dynamic functions of original optimal control problem, inputs are the current phase (ccode index), dynamic component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of dynamic gradient 1 for desired partial at each point, doubleMat for holding values of dynamic gradient 2 for desired partial at each point, doubleMat for holding values of dynamic hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(dynamicGrad1Mat.Len);  // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(dynamicGrad1Mat.Len);        // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 2;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute dynamic function at discretization points in phase with perturbed system in E1 & E2 direction
    dyn_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<dynamicGrad1Mat.Len; pt++)
    {
        dynamicGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<dynamicGrad2Mat.Len; pt++)
    {
        dynamicGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<dynamicHessMat.Len; pt++)
    {
        dynamicHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void path_func_Mixed_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& pathGrad1Mat, doubleMat& pathGrad2Mat, doubleMat& pathHessMat, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for path functions of original optimal control problem, inputs are the current phase (ccode index), path component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of path gradient 1 for desired partial at each point, doubleMat for holding values of path gradient 2 for desired partial at each point, doubleMat for holding values of path hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(pathGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(pathGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 3;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute path function at discretization points in phase with perturbed system in E1 & E2 direction
    path_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<pathGrad1Mat.Len; pt++)
    {
        pathGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<pathGrad2Mat.Len; pt++)
    {
        pathGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<pathHessMat.Len; pt++)
    {
        pathHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void lag_func_Mixed_HD(const int& phase, const int& component, const int& varA, const int& comA, const int& varB, const int& comB, ParametersStruct& phaseparametersStructSol, systemInfoHD& systeminfo, ParametersStructHD& phaseparametersStruct, doubleMat& lagrangeGrad1Mat, doubleMat& lagrangeGrad2Mat, doubleMat& lagrangeHessMat, double& stepSize0)    // Second-order derivative approximation using HyperDual-step for lagrange functions of original optimal control problem, inputs are the current phase (ccode index), lagrange component (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution phase parameters for current phase, system information structure for problem, phase parameters for current phase, doubleMat for holding values of lagrange gradient 1 for desired partial at each point, doubleMat for holding values of lagrange gradient 2 for desired partial at each point, doubleMat for holding values of lagrange hessian for desired partial at each point, step size for HyperDual-step
{
    HyperDualMat perturbEvals(lagrangeGrad1Mat.Len); // Allocate memory for number of discretization points in phase
    doubleMat stepSizes(lagrangeGrad1Mat.Len);       // Allocate memory for number of discretization points in phase
    
    for (int pt=0; pt<stepSizes.Len; pt++)
    {
        stepSizes.val[pt] = stepSize0;
    }
    
    int funcType = 4;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate phase variables for derivative approximation in E1 direction by stepSizes0
    PerturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Perturb appropriate phase variables for derivative approximation in E2 direction by stepSizes0
    PerturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    // Perturb dependent phase parameters
    PerturbPhaseParametersAB(phase,component,funcType,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,varA,comA,varB,comB);
    
    // Compute lagrange function at discretization points in phase with perturbed systemin in E1 & E2 direction
    lag_func(PhaseSwitchG.val[phase],component,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStruct,perturbEvals);
    
    // Unperturb dependent phase parameters
    UnperturbPhaseParametersAB(phase,component,funcType,phaseparametersStructSol,phaseparametersStruct,varA,comA,varB,comB);
    
    // Unperturb appropriate phase variables for derivative approximation in E1 direction
    UnperturbSystemPhaseVariablesE1(phase,varA,comA,systeminfo,stepSizes);
    // Unperturb appropriate phase variables for derivative approximation in E2 direction
    UnperturbSystemPhaseVariablesE2(phase,varB,comB,systeminfo,stepSizes);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    for (int pt=0; pt<lagrangeGrad1Mat.Len; pt++)
    {
        lagrangeGrad1Mat.val[pt] = perturbEvals.val[pt].E1/stepSize0;
    }
    // Use HyperDual-step to estimate first-derivative wrt second variable
    for (int pt=0; pt<lagrangeGrad2Mat.Len; pt++)
    {
        lagrangeGrad2Mat.val[pt] = perturbEvals.val[pt].E2/stepSize0;
    }
    // Use HyperDual-step to estimate second-derivative
    for (int pt=0; pt<lagrangeHessMat.Len; pt++)
    {
        lagrangeHessMat.val[pt] = perturbEvals.val[pt].E1E2/(stepSize0*stepSize0);
    }
}

void eve_func_Mixed_HD(const int& component, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB, doubleMat& endpointsparametersMatSol, systemInfoHD& systeminfo, HyperDualMat& endpointsparametersMat, double& eventGrad1Value, double& eventGrad2Value, double& eventHessValue, double& stepSize0)   // Second-order derivative approximation using HyperDual-step for event functions of original optimal control problem, inputs are the current event (ccode index), phase of first variable (ccode index), first variable type to be perturbed, component of first variable to be perturbed (ccode index), phase of second variable (ccode index), second variable type to be perturbed, component of second variable to be perturbed (ccode index), solution endpoints parameters for problem, system information structure for current phase, endpoints parameters for problem, double for holding value of event gradient 1 for desired partial, double for holding value of event gradient 2 for desired partial, double for holding value of event hessian for desired partial, step size for HyperDual-step
{
    HyperDual perturbEval;
    int phase=-1;
    
    int funcType = 5;
    
    /*-------------------------- HyperDual-step Perturbations -----------------------*/
    // Perturb appropriate endpoint variable for derivative approximation in E1 direction by step size stepSize0
    PerturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo,stepSize0);
    // Perturb appropriate endpoint variable for derivative approximation in E2 direction by step size stepSize0
    PerturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo,stepSize0);
    
    // Perturb dependent endpoint parameters
    PerturbEndpointParametersAB(phase,component,funcType,systeminfo,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Compute objective function in phase with perturbed system in E1 & E2 direction
    eve_func(component,systeminfo.phaseinfo,systeminfo.s,endpointsparametersMat.val,perturbEval);

    // Unperturb dependent endpoint parameters
    UnperturbEndpointParametersAB(phase,component,funcType,endpointsparametersMatSol,endpointsparametersMat,phaA,varA,comA,phaB,varB,comB);
    
    // Unperturb appropriate endpoint variable for derivative approximation in E1 direction
    UnperturbSystemEndpointVariableE1(phaA,varA,comA,systeminfo);
    // Unperturb appropriate endpoint variable for derivative approximation in E2 direction
    UnperturbSystemEndpointVariableE2(phaB,varB,comB,systeminfo);
    
    /*------------------- HyperDual-step Derivative Approximation -------------------*/
    // Use HyperDual-step to estimate first-derivative wrt first variable
    eventGrad1Value = perturbEval.E1/stepSize0;
    // Use HyperDual-step to estimate first-derivative wrt second variable
    eventGrad2Value = perturbEval.E2/stepSize0;
    // Use HyperDual-step to estimate second-derivative
    eventHessValue = perturbEval.E1E2/(stepSize0*stepSize0);
}


////////////////////////////////////////////////////////////////////////////////////////////////
//-------------------------------------Interpolation functions--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

doubleMat CubicPolation(int SolPts, const doubleMat& SolPtLocs, const doubleMat& SolVals, int PolPts, const doubleMat& PolPtLocs)   // Cubic interpolation function using "natural" condition (returns linear interpolation for SolPoints<4)
{
//    printf("\nSolPtLocs = ");
//    printf(SolPtLocs);
//    printf("\nPolPtLocs = ");
//    printf(PolPtLocs);
    
//    for (int pt=0; pt<SolPtLocs.Len; pt++)
//    {
//        printf("\nx_i(%d) = %.15f;",pt+1,SolPtLocs.val[pt]);
//    }
    
    int N = SolPts-1;           // Number of intervals for cubic interpolation
    doubleMat PolVals(PolPts);  // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    double h_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];              // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[N-1];            // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[N-1];      // Allocate memory for number of intervals minus one
    int P[N];                   // Allocate memory for number of intervals
    double Tol = 1e-8;          // Set tolerance for LUPDecompose function
    int stat;                   // Holder for LUPDecompose function output
    double y_i[N-1];            // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    int CurrInt;                // Current interval of solution points used for interpolation
    
    if (SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        // Linear interpolation formula: f(x) = (y2-y1)/(x2-x1)*(x-x1)+y1
        if (SolPts==3)  // If three solution points to interpolate through
        {
            for (int pt=0; pt<PolPts; pt++) // For each interpolation point
            {
                if (PolPtLocs.val[pt]<SolPtLocs.val[1]) // If interpolation point is less than second solution point location
                {
                    PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[0],SolPtLocs.val[1], SolVals.val[0],SolVals.val[1]); // Compute linear interpolation using first and second solution point
                }
                else    // Interpolation point greater than or equal to second solution point location
                {
                    PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[1],SolPtLocs.val[2], SolVals.val[1],SolVals.val[2]); // Compute linear interpolation using second and third solution point
                }
            }
        }
        else if (SolPts==2) // If two solution points to interpolate through
        {
            for (int pt=0; pt<PolPts; pt++) // For each interpolation point
            {
                PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[0],SolPtLocs.val[1], SolVals.val[0],SolVals.val[1]); // Compute linear interpolation using first and second solution point
            }
        }
        else if (SolPts<2)  // If less than two solution points to interpolate through
        {
            printf("\nERROR:Need at least 2 solution points to interpolate, SolPts = %d",SolPts);
        }
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs.val[coef+1] - SolPtLocs.val[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals.val[coef+1] - SolVals.val[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }

        for (int coef=0; coef<N-1; coef++)  // For each interval minus one
        {
            LUDMat[coef] = getDoubleMat(N-1);   // Allocate memory for number of unknowns coefficients minus one
            if (coef==0)    // If first row in cubic spline system
            {
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
                LUDMat[coef].val[coef+1] = c_i[coef+1];
            }
            else if (coef==(N-2))   // If final row in cubic spline system
            {
                LUDMat[coef].val[coef-1] = c_i[coef];
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
            }
            else if (coef<(N-2))    // Interior row in cubic spline system
            {
                LUDMat[coef].val[coef-1] = c_i[coef];
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
                LUDMat[coef].val[coef+1] = c_i[coef+1];
            }
            y_i[coef] = -g_i[coef] + g_i[coef+1];   // y_i = -g_i + g_{i+1}
        }

//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nLUDMat[%d] = ",row);
//            printf(LUDMat[row]);
//        }
        
        stat = LUPDecompose(LUDMat,N-1,Tol,P); // Perform LU Decomposition

        LUPSolve(LUDMat,P,y_i,N-1,m_i);         // Solve LUDMat*m_i = y_i for m_i
        
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nLUDMat[%d] = ",row);
//            printf(LUDMat[row]);
//        }
        
//        printf("\nm_i(%d) = %.15f;",1,0.0);
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nm_i(%d) = %.15f;",row+2,m_i[row]);
//        }
//        printf("\nm_i(%d) = %.15f;",N+1,0.0);
        
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\ny_i[%d] = %.15f",row,y_i[row]);
//        }


        for (int coef=0; coef<N; coef++)    // For each interval
        {
            if (coef==0)    // If first interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] - c_i[coef]*(m_i[coef]);
                b_i[coef] = SolVals.val[coef];
            }
            else if (coef==(N-1))   // If final interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] + c_i[coef]*(m_i[coef-1]);
                b_i[coef] = SolVals.val[coef] - m_i[coef-1]*h_i[coef]*c_i[coef];
            }
            else    // If interior interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] - c_i[coef]*(m_i[coef]-m_i[coef-1]);
                b_i[coef] = SolVals.val[coef] - m_i[coef-1]*h_i[coef]*c_i[coef];
            }
        }
        
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nh_i(%d) = %.15f;",coef+1,h_i[coef]);
//        }
//
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\na_i(%d) = %.15f;",coef+1,a_i[coef]);
//        }
//
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nb_i(%d) = %.15f;",coef+1,b_i[coef]);
//        }

        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=SolPtLocs.val[1]) // First solution interval used for interpolation
            {
                PolVals.val[pt] = m_i[0]*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])/(6*h_i[0]) + a_i[0]*(PolPtLocs.val[pt]-SolPtLocs.val[0]) + b_i[0];
            }
            else if (PolPtLocs.val[pt]>=SolPtLocs.val[N])   // Final solution interval used for interpolation
            {
                PolVals.val[pt] = m_i[N-2]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(6*h_i[N-1]) + a_i[N-1]*(PolPtLocs.val[pt]-SolPtLocs.val[N-1]) + b_i[N-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<N)&&(PolPtLocs.val[pt]>SolPtLocs.val[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                if (CurrInt==N-1)
                {
                    PolVals.val[pt] = m_i[N-2]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(6*h_i[N-1]) + a_i[N-1]*(PolPtLocs.val[pt]-SolPtLocs.val[N-1]) + b_i[N-1];
                }
                else
                {
                    PolVals.val[pt] = m_i[CurrInt-1]*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])/(6*h_i[CurrInt]) + m_i[CurrInt]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])/(6*h_i[CurrInt]) + a_i[CurrInt]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt]) + b_i[CurrInt];
                }
//                printf("\nCurrInt = %d",CurrInt);
//                printf("\nPolPtLocs.val[%d] = %.15f  |  SolPtLocs.val[%d] = %.15f",pt,PolPtLocs.val[pt],CurrInt+1,SolPtLocs.val[CurrInt+1]);
            }
        }

    }
    
//    for (int pt=0; pt<SolVals.Len; pt++)
//    {
//        printf("\nf_i(%d) = %.15f;",pt+1,SolVals.val[pt]);
//    }
//    printf("\nSolVals = ");
//    printf(SolVals);
//    printf("\nPolVals = ");
//    printf(PolVals);
    
    return PolVals;
}

doubleMat CubicPolationDerivative(int SolPts, const doubleMat& SolPtLocs, const doubleMat& SolVals, int PolPts, const doubleMat& PolPtLocs) // Derivative of cubic interpolation function using "natural" condition (SolPoints>=4)
{
//    printf("\nSolPtLocs = ");
//    printf(SolPtLocs);

    int N = SolPts-1;           // Number of intervals for cubic interpolation
    doubleMat PolValDerivs(PolPts);  // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    double h_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];              // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[N-1];            // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[N-1];      // Allocate memory for number of intervals minus one
    int P[N];                   // Allocate memory for number of intervals
    double Tol = 1e-8;          // Set tolerance for LUPDecompose function
    int stat;                   // Holder for LUPDecompose function output
    double y_i[N-1];            // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    int CurrInt;                // Current interval of solution points used for interpolation
    
    if (SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to get interpolate derivative, SolPts = %d",SolPts);
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs.val[coef+1] - SolPtLocs.val[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals.val[coef+1] - SolVals.val[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }
        
        for (int coef=0; coef<N-1; coef++)  // For each interval minus one
        {
            LUDMat[coef] = getDoubleMat(N-1);   // Allocate memory for number of unknowns coefficients minus one
            if (coef==0)    // If first row in cubic spline system
            {
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
                LUDMat[coef].val[coef+1] = c_i[coef+1];
            }
            else if (coef==(N-2))   // If final row in cubic spline system
            {
                LUDMat[coef].val[coef-1] = c_i[coef];
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
            }
            else if (coef<(N-2))    // Interior row in cubic spline system
            {
                LUDMat[coef].val[coef-1] = c_i[coef];
                LUDMat[coef].val[coef] = 2*(c_i[coef]+c_i[coef+1]);
                LUDMat[coef].val[coef+1] = c_i[coef+1];
            }
            y_i[coef] = -g_i[coef] + g_i[coef+1];   // y_i = -g_i + g_{i+1}
        }
        
        stat = LUPDecompose(LUDMat,N-1,Tol,P); // Perform LU Decomposition
        
        LUPSolve(LUDMat,P,y_i,N-1,m_i);         // Solve LUDMat*m_i = y_i for m_i
        
//        printf("\nm_i(%d) = %.15f;",1,0.0);
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nm_i(%d) = %.15f;",row+2,m_i[row]);
//        }
//        printf("\nm_i(%d) = %.15f;",N+1,0.0);
        
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            if (coef==0)    // If first interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] - c_i[coef]*(m_i[coef]);
                b_i[coef] = SolVals.val[coef];
            }
            else if (coef==(N-1))   // If final interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] + c_i[coef]*(m_i[coef-1]);
                b_i[coef] = SolVals.val[coef] - m_i[coef-1]*h_i[coef]*c_i[coef];
            }
            else    // If interior interval
            {
                a_i[coef] = k_i[coef]/h_i[coef] - c_i[coef]*(m_i[coef]-m_i[coef-1]);
                b_i[coef] = SolVals.val[coef] - m_i[coef-1]*h_i[coef]*c_i[coef];
            }
        }
        
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nh_i(%d) = %.15f;",coef+1,h_i[coef]);
//        }
//        
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\na_i(%d) = %.15f;",coef+1,a_i[coef]);
//        }
//        
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nb_i(%d) = %.15f;",coef+1,b_i[coef]);
//        }

        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=SolPtLocs.val[1]) // First solution interval used for interpolation derivative
            {
                PolValDerivs.val[pt] = m_i[0]*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])/(2*h_i[0]) + a_i[0];
            }
            else if (PolPtLocs.val[pt]>=SolPtLocs.val[N])   // Final solution interval used for interpolation derivative
            {
                PolValDerivs.val[pt] = -m_i[N-2]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(2*h_i[N-1]) + a_i[N-1];
            }
            else    // Interior solution interval used for interpolation derivative
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<N)&&(PolPtLocs.val[pt]>SolPtLocs.val[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                if (CurrInt==N-1)
                {
                    PolValDerivs.val[pt] = -m_i[N-2]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(2*h_i[N-1]) + a_i[N-1];
                }
                else
                {
                    PolValDerivs.val[pt] = -m_i[CurrInt-1]*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])/(2*h_i[CurrInt]) + m_i[CurrInt]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])/(2*h_i[CurrInt]) + a_i[CurrInt];
                }
            }
        }
        
    }
    
    return PolValDerivs;
}

doubleMatMat TabularDataXPartial(const doubleMat& xData, const doubleMatMat& tabData)   // Compute approximation of derivative of function representing tabular data wrt x values using "natural" condition
{
    doubleMatMat tabDataX(tabData.Len);
    int SolPts,PolPts;
    doubleMat SolPtLocs,PolPtLocs;
    doubleMat SolPtVals;
    doubleMat PolPtDerivs;

    SolPts = xData.Len;
    PolPts = SolPts;
    SolPtLocs = xData;
    PolPtLocs = xData;
    
    for (int row=0; row<tabData.Len; row++)
    {
        tabDataX.mat[row] = getDoubleMat(tabData.mat[0].Len);
    }
    
    for (int col=0; col<tabData.mat[0].Len; col++)
    {
        SolPtVals = getDoubleMatMatColumn(tabData,col);
        PolPtDerivs = CubicPolationDerivative(SolPts,SolPtLocs,SolPtVals,PolPts,PolPtLocs);
        setDoubleMatMatColumn(col,PolPtDerivs,tabDataX);
    }
    
    return tabDataX;
}

doubleMatMat TabularDataYPartial(const doubleMat& yData, const doubleMatMat& tabData)   // Compute approximation of derivative of function representing tabular data wrt y values using "natural" condition
{
    doubleMatMat tabDataY(tabData.Len);
    int SolPts,PolPts;
    doubleMat SolPtLocs,PolPtLocs;
    doubleMat SolPtVals;
    doubleMat PolPtDerivs;
    
    SolPts = yData.Len;
    PolPts = SolPts;
    SolPtLocs = yData;
    PolPtLocs = yData;
    
    for (int row=0; row<tabData.Len; row++)
    {
        SolPtVals = tabData.mat[row];
        PolPtDerivs = CubicPolationDerivative(SolPts,SolPtLocs,SolPtVals,PolPts,PolPtLocs);
        tabDataY.mat[row] = PolPtDerivs;
    }
    
    return tabDataY;
}

double BicubicInterpolation(double x, double xA, double xB, double y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat) // Bicubic interpolation for double input/output; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    double interpVal;
    doubleMat FXbarMat(4);  // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);  // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4); // Values of function derivatives wrt xbar and ybar in [0,1]
    double xbar, ybar;      // Values of point of interest in [0,1]
    double xdiff, ydiff;    // Difference of cell intervals in x and y
    double a00,a01,a02,a03; // Coefficients for bicubic interpolation
    double a10,a11,a12,a13; // Coefficients for bicubic interpolation
    double a20,a21,a22,a23; // Coefficients for bicubic interpolation
    double a30,a31,a32,a33; // Coefficients for bicubic interpolation
    double b00,b01,b02,b03; // Coefficients for bicubic interpolation
    double b10,b11,b12,b13; // Coefficients for bicubic interpolation
    double b20,b21,b22,b23; // Coefficients for bicubic interpolation
    double b30,b31,b32,b33; // Coefficients for bicubic interpolation
    double c00,c10,c20,c30; // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
//    printf("\nx = %.15e",x);
//    printf("\ny = %.15e",y);
//
//    printf("\nxA = %.15e",xA);
//    printf("\nxB = %.15e",xB);
//    printf("\nyA = %.15e",yA);
//    printf("\nyB = %.15e",yB);
//    printf("\nxdiff = %.15e",xdiff);
//    printf("\nydiff = %.15e",ydiff);
//
//    printf("\nxbar = %.15e",xbar);
//    printf("\nybar = %.15e",ybar);
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]    = FXMat.val[pt]*xdiff;          // Compute partial wrt xbar
        FYbarMat.val[pt]    = FYMat.val[pt]*ydiff;          // Compute partial wrt ybar
        FXYbarMat.val[pt]   = FXYMat.val[pt]*xdiff*ydiff;   // Compute partial wrt xbar and ybar
    }
    
//    printf4MATLAB("FXbarMat",FXbarMat);
//    printf4MATLAB("FYbarMat",FYbarMat);
//    printf4MATLAB("FXYbarMat",FXYbarMat);
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
//
//    printf("\na00 = %.15e",a00);
//    printf("\na01 = %.15e",a01);
//    printf("\na02 = %.15e",a02);
//    printf("\na03 = %.15e",a03);
//    printf("\na10 = %.15e",a10);
//    printf("\na11 = %.15e",a11);
//    printf("\na12 = %.15e",a12);
//    printf("\na13 = %.15e",a13);
//    printf("\na20 = %.15e",a20);
//    printf("\na21 = %.15e",a21);
//    printf("\na22 = %.15e",a22);
//    printf("\na23 = %.15e",a23);
//    printf("\na30 = %.15e",a30);
//    printf("\na31 = %.15e",a31);
//    printf("\na32 = %.15e",a32);
//    printf("\na33 = %.15e",a33);
//
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
//    printf("\nc00 = %.15e",c00);
//    printf("\nc10 = %.15e",c10);
//    printf("\nc20 = %.15e",c20);
//    printf("\nc30 = %.15e",c30);
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

Bicomplex BicubicInterpolation(Bicomplex& x, double xA, double xB, Bicomplex& y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat)    // Bicubic interpolation for bicomplex input/output; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    Bicomplex interpVal;
    doubleMat FXbarMat(4);      // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of function derivatives wrt xbar and ybar in [0,1]
    Bicomplex xbar, ybar;       // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    Bicomplex c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
//    printf("x",x);
//    printf("y",y);
//
//    printf("\nxA = %.15e",xA);
//    printf("\nxB = %.15e",xB);
//    printf("\nyA = %.15e",yA);
//    printf("\nyB = %.15e",yB);
//    printf("\nxdiff = %.15e",xdiff);
//    printf("\nydiff = %.15e",ydiff);
//
//    printf("xbar",xbar);
//    printf("ybar",ybar);
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]    = FXMat.val[pt]*xdiff;          // Compute partial wrt xbar
        FYbarMat.val[pt]    = FYMat.val[pt]*ydiff;          // Compute partial wrt ybar
        FXYbarMat.val[pt]   = FXYMat.val[pt]*xdiff*ydiff;   // Compute partial wrt xbar and ybar
    }
    
//    printf4MATLAB("FXbarMat",FXbarMat);
//    printf4MATLAB("FYbarMat",FYbarMat);
//    printf4MATLAB("FXYbarMat",FXYbarMat);
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
//
//    printf("\na00 = %.15e",a00);
//    printf("\na01 = %.15e",a01);
//    printf("\na02 = %.15e",a02);
//    printf("\na03 = %.15e",a03);
//    printf("\na10 = %.15e",a10);
//    printf("\na11 = %.15e",a11);
//    printf("\na12 = %.15e",a12);
//    printf("\na13 = %.15e",a13);
//    printf("\na20 = %.15e",a20);
//    printf("\na21 = %.15e",a21);
//    printf("\na22 = %.15e",a22);
//    printf("\na23 = %.15e",a23);
//    printf("\na30 = %.15e",a30);
//    printf("\na31 = %.15e",a31);
//    printf("\na32 = %.15e",a32);
//    printf("\na33 = %.15e",a33);
//
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
//    printf("c00",c00);
//    printf("c10",c10);
//    printf("c20",c20);
//    printf("c30",c30);
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

HyperDual BicubicInterpolation(HyperDual& x, double xA, double xB, HyperDual& y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat)    // Bicubic interpolation for HyperDual input/output; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    HyperDual interpVal;
    doubleMat FXbarMat(4);      // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of function derivatives wrt xbar and ybar in [0,1]
    HyperDual xbar, ybar;       // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    HyperDual c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    //    printf("x",x);
    //    printf("y",y);
    //
    //    printf("\nxA = %.15e",xA);
    //    printf("\nxB = %.15e",xB);
    //    printf("\nyA = %.15e",yA);
    //    printf("\nyB = %.15e",yB);
    //    printf("\nxdiff = %.15e",xdiff);
    //    printf("\nydiff = %.15e",ydiff);
    //
    //    printf("xbar",xbar);
    //    printf("ybar",ybar);
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]    = FXMat.val[pt]*xdiff;          // Compute partial wrt xbar
        FYbarMat.val[pt]    = FYMat.val[pt]*ydiff;          // Compute partial wrt ybar
        FXYbarMat.val[pt]   = FXYMat.val[pt]*xdiff*ydiff;   // Compute partial wrt xbar and ybar
    }
    
    //    printf4MATLAB("FXbarMat",FXbarMat);
    //    printf4MATLAB("FYbarMat",FYbarMat);
    //    printf4MATLAB("FXYbarMat",FXYbarMat);
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    //
    //    printf("\na00 = %.15e",a00);
    //    printf("\na01 = %.15e",a01);
    //    printf("\na02 = %.15e",a02);
    //    printf("\na03 = %.15e",a03);
    //    printf("\na10 = %.15e",a10);
    //    printf("\na11 = %.15e",a11);
    //    printf("\na12 = %.15e",a12);
    //    printf("\na13 = %.15e",a13);
    //    printf("\na20 = %.15e",a20);
    //    printf("\na21 = %.15e",a21);
    //    printf("\na22 = %.15e",a22);
    //    printf("\na23 = %.15e",a23);
    //    printf("\na30 = %.15e",a30);
    //    printf("\na31 = %.15e",a31);
    //    printf("\na32 = %.15e",a32);
    //    printf("\na33 = %.15e",a33);
    //
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    //    printf("c00",c00);
    //    printf("c10",c10);
    //    printf("c20",c20);
    //    printf("c30",c30);
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}


doubleMat CubicPolationNAK(int SolPts, const doubleMat& SolPtLocs, const doubleMat& SolVals, int PolPts, const doubleMat& PolPtLocs)   // Cubic interpolation function using "not-a-knot" condition (returns linear interpolation for SolPoints<4)
{
//    printf("\nSolPtLocs = ");
//    printf(SolPtLocs);
//    printf("\nPolPtLocs = ");
//    printf(PolPtLocs);

//    for (int pt=0; pt<SolPtLocs.Len; pt++)
//    {
//        printf("\nx_i(%d) = %.15f;",pt+1,SolPtLocs.val[pt]);
//    }
    
    int N = SolPts-1;           // Number of intervals for cubic interpolation
    doubleMat PolVals(PolPts);  // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    double h_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];              // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[SolPts];            // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[SolPts];   // Allocate memory for number of intervals minus one
    int P[SolPts+1];            // Allocate memory for number of intervals
    double Tol = 1e-8;          // Set tolerance for LUPDecompose function
    int stat;                   // Holder for LUPDecompose function output
    double y_i[SolPts];         // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    int CurrInt;                // Current interval of solution points used for interpolation
    
    if (SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        // Linear interpolation formula: f(x) = (y2-y1)/(x2-x1)*(x-x1)+y1
        if (SolPts==3)  // If three solution points to interpolate through
        {
            for (int pt=0; pt<PolPts; pt++) // For each interpolation point
            {
                if (PolPtLocs.val[pt]<SolPtLocs.val[1]) // If interpolation point is less than second solution point location
                {
                    PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[0],SolPtLocs.val[1], SolVals.val[0],SolVals.val[1]); // Compute linear interpolation using first and second solution point
                }
                else    // Interpolation point greater than or equal to second solution point location
                {
                    PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[1],SolPtLocs.val[2], SolVals.val[1],SolVals.val[2]); // Compute linear interpolation using second and third solution point
                }
            }
        }
        else if (SolPts==2) // If two solution points to interpolate through
        {
            for (int pt=0; pt<PolPts; pt++) // For each interpolation point
            {
                PolVals.val[pt] = LinearInterp(PolPtLocs.val[pt],SolPtLocs.val[0],SolPtLocs.val[1], SolVals.val[0],SolVals.val[1]); // Compute linear interpolation using first and second solution point
            }
        }
        else if (SolPts<2)  // If less than two solution points to interpolate through
        {
            printf("\nERROR:Need at least 2 solution points to interpolate, SolPts = %d",SolPts);
        }
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs.val[coef+1] - SolPtLocs.val[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals.val[coef+1] - SolVals.val[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }
        
        for (int row=0; row<SolPts; row++)  // For each solution point
        {
            LUDMat[row] = getDoubleMat(SolPts); // Allocate memory for number of solution points
            if (row==0) // If first row in cubic spline system
            {
                LUDMat[0].val[0]    = -h_i[1];
                LUDMat[0].val[1]    = h_i[0]+h_i[1];
                LUDMat[0].val[2]    = -h_i[0];
                y_i[0]              = 0; // y_(1) = 0
            }
            else if (row==N)    // If final row in cubic spline system
            {
                LUDMat[N].val[N-2]  = -h_i[N-1];
                LUDMat[N].val[N-1]  = h_i[N-2]+h_i[N-1];
                LUDMat[N].val[N]    = -h_i[N-2];
                y_i[N]              = 0; // y_(SolPts) = 0
            }
            else    // Interior row in cubic spline system
            {
                LUDMat[row].val[row-1]  = c_i[row-1];
                LUDMat[row].val[row]    = 2*(c_i[row-1]+c_i[row]);
                LUDMat[row].val[row+1]  = c_i[row];
                y_i[row]                = -g_i[row-1] + g_i[row];  // y_i = -g_i + g_{i+1}
            }
        }
        
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nLUDMat[%d] = ",row);
//            printf(LUDMat[row]);
//        }
        
        stat = LUPDecompose(LUDMat,SolPts,Tol,P);   // Perform LU Decomposition
        
        LUPSolve(LUDMat,P,y_i,SolPts,m_i);  // Solve LUDMat*m_i = y_i for m_i
        
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nLUDMat[%d] = ",row);
//            printf(LUDMat[row]);
//        }

//        printf("\nm_i(%d) = %.15f;",1,0.0);
//        for (int row=0; row<N-1; row++)
//        {
//            printf("\nm_i(%d) = %.15f;",row+2,m_i[row]);
//        }
//        printf("\nm_i(%d) = %.15f;",N+1,0.0);

//        for (int row=0; row<N-1; row++)
//        {
//            printf("\ny_i[%d] = %.15f",row,y_i[row]);
//        }
        
        
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            a_i[coef] = g_i[coef] - c_i[coef]*(m_i[coef+1]-m_i[coef]);
            b_i[coef] = SolVals.val[coef] - m_i[coef]*h_i[coef]*c_i[coef];
        }
        
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nh_i(%d) = %.15f;",coef+1,h_i[coef]);
//        }
//
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\na_i(%d) = %.15f;",coef+1,a_i[coef]);
//        }
//
//        for (int coef=0; coef<N; coef++)    // For each interval
//        {
//            printf("\nb_i(%d) = %.15f;",coef+1,b_i[coef]);
//        }
        
        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=SolPtLocs.val[1]) // First solution interval used for interpolation
            {
                PolVals.val[pt] = m_i[0]*(SolPtLocs.val[1]-PolPtLocs.val[pt])*(SolPtLocs.val[1]-PolPtLocs.val[pt])*(SolPtLocs.val[1]-PolPtLocs.val[pt])/(6*h_i[0]) + m_i[1]*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])/(6*h_i[0]) + a_i[0]*(PolPtLocs.val[pt]-SolPtLocs.val[0]) + b_i[0];
            }
            else if (PolPtLocs.val[pt]>=SolPtLocs.val[N])   // Final solution interval used for interpolation
            {
                PolVals.val[pt] = m_i[N-1]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(6*h_i[N-1]) + m_i[N]*(PolPtLocs.val[pt]-SolPtLocs.val[N-1])*(PolPtLocs.val[pt]-SolPtLocs.val[N-1])*(PolPtLocs.val[pt]-SolPtLocs.val[N-1])/(6*h_i[N-1]) + a_i[N-1]*(PolPtLocs.val[pt]-SolPtLocs.val[N-1]) + b_i[N-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<N)&&(PolPtLocs.val[pt]>SolPtLocs.val[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                
                PolVals.val[pt] = m_i[CurrInt]*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])/(6*h_i[CurrInt]) + m_i[CurrInt+1]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])/(6*h_i[CurrInt]) + a_i[CurrInt]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt]) + b_i[CurrInt];
                
//                printf("\nCurrInt = %d",CurrInt);
//                printf("\nPolPtLocs.val[%d] = %.15f  |  SolPtLocs.val[%d] = %.15f",pt,PolPtLocs.val[pt],CurrInt+1,SolPtLocs.val[CurrInt+1]);
            }
        }
        
    }
    
//    for (int pt=0; pt<SolVals.Len; pt++)
//    {
//        printf("\nf_i(%d) = %.15f;",pt+1,SolVals.val[pt]);
//    }
//    printf("\nSolVals = ");
//    printf(SolVals);
//    printf("\nPolVals = ");
//    printf(PolVals);
    
    return PolVals;
}

doubleMat CubicPolationDerivativeNAK(int SolPts, const doubleMat& SolPtLocs, const doubleMat& SolVals, int PolPts, const doubleMat& PolPtLocs)  // Cubic interpolation function using "not-a-knot" condition (returns linear interpolation for SolPoints<4)
{
    //    printf("\nSolPtLocs = ");
    //    printf(SolPtLocs);
    //    printf("\nPolPtLocs = ");
    //    printf(PolPtLocs);
    
    //    for (int pt=0; pt<SolPtLocs.Len; pt++)
    //    {
    //        printf("\nx_i(%d) = %.15f;",pt+1,SolPtLocs.val[pt]);
    //    }
    
    int N = SolPts-1;               // Number of intervals for cubic interpolation
    doubleMat PolValDerivs(PolPts); // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    double h_i[N];                  // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];                  // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];                  // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[SolPts];             // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];                  // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[SolPts];       // Allocate memory for number of intervals minus one
    int P[SolPts+1];                // Allocate memory for number of intervals
    double Tol = 1e-8;              // Set tolerance for LUPDecompose function
    int stat;                       // Holder for LUPDecompose function output
    double y_i[SolPts];             // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];                  // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];                  // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    int CurrInt;                    // Current interval of solution points used for interpolation
    
    if (SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",SolPts);
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs.val[coef+1] - SolPtLocs.val[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals.val[coef+1] - SolVals.val[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }
        
        for (int row=0; row<SolPts; row++)  // For each solution point
        {
            LUDMat[row] = getDoubleMat(SolPts); // Allocate memory for number of solution points
            if (row==0) // If first row in cubic spline system
            {
                LUDMat[0].val[0]    = -h_i[1];
                LUDMat[0].val[1]    = h_i[0]+h_i[1];
                LUDMat[0].val[2]    = -h_i[0];
                y_i[0]              = 0; // y_(1) = 0
            }
            else if (row==N)    // If final row in cubic spline system
            {
                LUDMat[N].val[N-2]  = -h_i[N-1];
                LUDMat[N].val[N-1]  = h_i[N-2]+h_i[N-1];
                LUDMat[N].val[N]    = -h_i[N-2];
                y_i[N]              = 0; // y_(SolPts) = 0
            }
            else    // Interior row in cubic spline system
            {
                LUDMat[row].val[row-1]  = c_i[row-1];
                LUDMat[row].val[row]    = 2*(c_i[row-1]+c_i[row]);
                LUDMat[row].val[row+1]  = c_i[row];
                y_i[row]                = -g_i[row-1] + g_i[row];  // y_i = -g_i + g_{i+1}
            }
        }
        
        stat = LUPDecompose(LUDMat,SolPts,Tol,P);   // Perform LU Decomposition
        
        LUPSolve(LUDMat,P,y_i,SolPts,m_i);  // Solve LUDMat*m_i = y_i for m_i
        
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            a_i[coef] = g_i[coef] - c_i[coef]*(m_i[coef+1]-m_i[coef]);
            b_i[coef] = SolVals.val[coef] - m_i[coef]*h_i[coef]*c_i[coef];
        }
        
        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=SolPtLocs.val[1]) // First solution interval used for interpolation
            {
                PolValDerivs.val[pt] = -m_i[0]*(SolPtLocs.val[1]-PolPtLocs.val[pt])*(SolPtLocs.val[1]-PolPtLocs.val[pt])/(2*h_i[0]) + m_i[1]*(PolPtLocs.val[pt]-SolPtLocs.val[0])*(PolPtLocs.val[pt]-SolPtLocs.val[0])/(2*h_i[0]) + a_i[0];
            }
            else if (PolPtLocs.val[pt]>=SolPtLocs.val[N])   // Final solution interval used for interpolation
            {
                PolValDerivs.val[pt] = -m_i[N-1]*(SolPtLocs.val[N]-PolPtLocs.val[pt])*(SolPtLocs.val[N]-PolPtLocs.val[pt])/(2*h_i[N-1]) + m_i[N]*(PolPtLocs.val[pt]-SolPtLocs.val[N-1])*(PolPtLocs.val[pt]-SolPtLocs.val[N-1])/(2*h_i[N-1]) + a_i[N-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<N)&&(PolPtLocs.val[pt]>SolPtLocs.val[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                
                PolValDerivs.val[pt] = -m_i[CurrInt]*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])*(SolPtLocs.val[CurrInt+1]-PolPtLocs.val[pt])/(2*h_i[CurrInt]) + m_i[CurrInt+1]*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])*(PolPtLocs.val[pt]-SolPtLocs.val[CurrInt])/(2*h_i[CurrInt]) + a_i[CurrInt];
            }
        }
    }
    
    return PolValDerivs;
}

doubleMatMat TabularDataXPartialNAK(const doubleMat& xData, const doubleMatMat& tabData)    // Compute approximation of derivative of function representing tabular data wrt x values using "not-a-knot" condition
{
    doubleMatMat tabDataX(tabData.Len);
    int SolPts,PolPts;
    doubleMat SolPtLocs,PolPtLocs;
    doubleMat SolPtVals;
    doubleMat PolPtDerivs;
    
    SolPts = xData.Len;
    PolPts = SolPts;
    SolPtLocs = xData;
    PolPtLocs = xData;
    
    for (int row=0; row<tabData.Len; row++)
    {
        tabDataX.mat[row] = getDoubleMat(tabData.mat[0].Len);
    }
    
    for (int col=0; col<tabData.mat[0].Len; col++)
    {
        SolPtVals = getDoubleMatMatColumn(tabData,col);
        PolPtDerivs = CubicPolationDerivativeNAK(SolPts,SolPtLocs,SolPtVals,PolPts,PolPtLocs);
        setDoubleMatMatColumn(col,PolPtDerivs,tabDataX);
    }
    
    return tabDataX;
}

doubleMatMat TabularDataYPartialNAK(const doubleMat& yData, const doubleMatMat& tabData)    // Compute approximation of derivative of function representing tabular data wrt y values using "not-a-knot" condition
{
    doubleMatMat tabDataY(tabData.Len);
    int SolPts,PolPts;
    doubleMat SolPtLocs,PolPtLocs;
    doubleMat SolPtVals;
    doubleMat PolPtDerivs;
    
    SolPts = yData.Len;
    PolPts = SolPts;
    SolPtLocs = yData;
    PolPtLocs = yData;
    
    for (int row=0; row<tabData.Len; row++)
    {
        SolPtVals = tabData.mat[row];
        PolPtDerivs = CubicPolationDerivativeNAK(SolPts,SolPtLocs,SolPtVals,PolPts,PolPtLocs);
        tabDataY.mat[row] = PolPtDerivs;
    }
    
    return tabDataY;
}

double BicubicInterpolationLinearApprox(double x, double xA, double xB, double y, double yA, double yB, const doubleMat& FMat)  // Bicubic interpolation for double input/output using linear approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB). Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices
{
    double interpVal;       // Value of interpolated data at (x,y)
    doubleMat FXbarMat(4);  // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);  // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4); // Values of function derivatives wrt xbar and ybar in [0,1]
    double xbar, ybar;      // Values of point of interest in [0,1]
    double xdiff, ydiff;    // Difference of cell intervals in x and y
    double a00,a01,a02,a03; // Coefficients for bicubic interpolation
    double a10,a11,a12,a13; // Coefficients for bicubic interpolation
    double a20,a21,a22,a23; // Coefficients for bicubic interpolation
    double a30,a31,a32,a33; // Coefficients for bicubic interpolation
    double b00,b01,b02,b03; // Coefficients for bicubic interpolation
    double b10,b11,b12,b13; // Coefficients for bicubic interpolation
    double b20,b21,b22,b23; // Coefficients for bicubic interpolation
    double b30,b31,b32,b33; // Coefficients for bicubic interpolation
    double c00,c10,c20,c30; // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    FXbarMat.val[0]     = FMat.val[2] - FMat.val[0];    // Compute partial wrt xbar
    FXbarMat.val[1]     = FMat.val[3] - FMat.val[1];    // Compute partial wrt xbar
    FXbarMat.val[2]     = FXbarMat.val[0];
    FXbarMat.val[3]     = FXbarMat.val[1];
    FYbarMat.val[0]     = FMat.val[1] - FMat.val[0];    // Compute partial wrt ybar
    FYbarMat.val[1]     = FYbarMat.val[0];
    FYbarMat.val[2]     = FMat.val[3] - FMat.val[2];    // Compute partial wrt ybar
    FYbarMat.val[3]     = FYbarMat.val[2];
    FXYbarMat.val[0]    = FYbarMat.val[2] - FYbarMat.val[0];    // Compute partial wrt xbar and ybar
    FXYbarMat.val[1]    = FXYbarMat.val[0];
    FXYbarMat.val[2]    = FXYbarMat.val[0];
    FXYbarMat.val[3]    = FXYbarMat.val[0];
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

Bicomplex BicubicInterpolationLinearApprox(Bicomplex& x, double xA, double xB, Bicomplex& y, double yA, double yB, const doubleMat& FMat) // Bicubic interpolation for Bicomplex input/output using linear approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB). Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices
{
    Bicomplex interpVal;        // Value of interpolated data at (x,y)
    doubleMat FXbarMat(4);      // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of function derivatives wrt xbar and ybar in [0,1]
    Bicomplex xbar, ybar;       // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    Bicomplex c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    FXbarMat.val[0]     = FMat.val[2] - FMat.val[0];    // Compute partial wrt xbar
    FXbarMat.val[1]     = FMat.val[3] - FMat.val[1];    // Compute partial wrt xbar
    FXbarMat.val[2]     = FXbarMat.val[0];
    FXbarMat.val[3]     = FXbarMat.val[1];
    FYbarMat.val[0]     = FMat.val[1] - FMat.val[0];    // Compute partial wrt ybar
    FYbarMat.val[1]     = FYbarMat.val[0];
    FYbarMat.val[2]     = FMat.val[3] - FMat.val[2];    // Compute partial wrt ybar
    FYbarMat.val[3]     = FYbarMat.val[2];
    FXYbarMat.val[0]    = FYbarMat.val[2] - FYbarMat.val[0];    // Compute partial wrt xbar and ybar
    FXYbarMat.val[1]    = FXYbarMat.val[0];
    FXYbarMat.val[2]    = FXYbarMat.val[0];
    FXYbarMat.val[3]    = FXYbarMat.val[0];
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

HyperDual BicubicInterpolationLinearApprox(HyperDual& x, double xA, double xB, HyperDual& y, double yA, double yB, const doubleMat& FMat) // Bicubic interpolation for HyperDual input/output using linear approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB). Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices
{
    HyperDual interpVal;        // Value of interpolated data at (x,y)
    doubleMat FXbarMat(4);      // Values of function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of function derivatives wrt xbar and ybar in [0,1]
    HyperDual xbar, ybar;       // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    HyperDual c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    FXbarMat.val[0]     = FMat.val[2] - FMat.val[0];    // Compute partial wrt xbar
    FXbarMat.val[1]     = FMat.val[3] - FMat.val[1];    // Compute partial wrt xbar
    FXbarMat.val[2]     = FXbarMat.val[0];
    FXbarMat.val[3]     = FXbarMat.val[1];
    FYbarMat.val[0]     = FMat.val[1] - FMat.val[0];    // Compute partial wrt ybar
    FYbarMat.val[1]     = FYbarMat.val[0];
    FYbarMat.val[2]     = FMat.val[3] - FMat.val[2];    // Compute partial wrt ybar
    FYbarMat.val[3]     = FYbarMat.val[2];
    FXYbarMat.val[0]    = FYbarMat.val[2] - FYbarMat.val[0];    // Compute partial wrt xbar and ybar
    FXYbarMat.val[1]    = FXYbarMat.val[0];
    FXYbarMat.val[2]    = FXYbarMat.val[0];
    FXYbarMat.val[3]    = FXYbarMat.val[0];
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

double BicubicInterpolationHybridApprox(double x, double xA, double xB, double y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat) // Bicubic interpolation for double input/output using hybrid approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    double interpVal;           // Value of interpolated data at (x,y)
    doubleMat FXbarMatC(4);     // Values of cubic function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatC(4);     // Values of cubic function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatC(4);    // Values of cubic function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMatL(4);     // Values of linear function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatL(4);     // Values of linear function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatL(4);    // Values of linear function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMat(4);      // Values of hybrid function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of hybrid function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of hybrid function derivatives wrt xbar and ybar in [0,1]
    double xbar, ybar;          // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    double c00,c10,c20,c30;     // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMatC.val[pt]   = FXMat.val[pt]*xdiff;          // Compute cubic partial wrt xbar
        FYbarMatC.val[pt]   = FYMat.val[pt]*ydiff;          // Compute cubic partial wrt ybar
        FXYbarMatC.val[pt]  = FXYMat.val[pt]*xdiff*ydiff;   // Compute cubic partial wrt xbar and ybar
    }
    
    FXbarMatL.val[0]    = FMat.val[2] - FMat.val[0];    // Compute linear partial wrt xbar
    FXbarMatL.val[1]    = FMat.val[3] - FMat.val[1];    // Compute linear partial wrt xbar
    FXbarMatL.val[2]    = FXbarMatL.val[0];
    FXbarMatL.val[3]    = FXbarMatL.val[1];
    FYbarMatL.val[0]    = FMat.val[1] - FMat.val[0];    // Compute linear partial wrt ybar
    FYbarMatL.val[1]    = FYbarMatL.val[0];
    FYbarMatL.val[2]    = FMat.val[3] - FMat.val[2];    // Compute linear partial wrt ybar
    FYbarMatL.val[3]    = FYbarMatL.val[2];
    FXYbarMatL.val[0]   = FYbarMatL.val[2] - FYbarMatL.val[0];  // Compute linear partial wrt xbar and ybar
    FXYbarMatL.val[1]   = FXYbarMatL.val[0];
    FXYbarMatL.val[2]   = FXYbarMatL.val[0];
    FXYbarMatL.val[3]   = FXYbarMatL.val[0];
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]   = 0.5*(FXbarMatC.val[pt] + FXbarMatL.val[pt]);   // Compute hybrid partial wrt xbar
        FYbarMat.val[pt]   = 0.5*(FYbarMatC.val[pt] + FYbarMatL.val[pt]);   // Compute hybrid partial wrt ybar
        FXYbarMat.val[pt]  = 0.5*(FXYbarMatC.val[pt] + FXYbarMatL.val[pt]); // Compute hybrid partial wrt xbar and ybar
    }
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

Bicomplex BicubicInterpolationHybridApprox(Bicomplex& x, double xA, double xB, Bicomplex& y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat)    // Bicubic interpolation for bicomplex input/output using hybrid approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    Bicomplex interpVal;       // Value of interpolated data at (x,y)
    doubleMat FXbarMatC(4);     // Values of cubic function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatC(4);     // Values of cubic function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatC(4);    // Values of cubic function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMatL(4);     // Values of linear function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatL(4);     // Values of linear function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatL(4);    // Values of linear function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMat(4);      // Values of hybrid function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of hybrid function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of hybrid function derivatives wrt xbar and ybar in [0,1]
    Bicomplex xbar, ybar;      // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    Bicomplex c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMatC.val[pt]   = FXMat.val[pt]*xdiff;          // Compute cubic partial wrt xbar
        FYbarMatC.val[pt]   = FYMat.val[pt]*ydiff;          // Compute cubic partial wrt ybar
        FXYbarMatC.val[pt]  = FXYMat.val[pt]*xdiff*ydiff;   // Compute cubic partial wrt xbar and ybar
    }
    
    FXbarMatL.val[0]    = FMat.val[2] - FMat.val[0];    // Compute linear partial wrt xbar
    FXbarMatL.val[1]    = FMat.val[3] - FMat.val[1];    // Compute linear partial wrt xbar
    FXbarMatL.val[2]    = FXbarMat.val[0];
    FXbarMatL.val[3]    = FXbarMat.val[1];
    FYbarMatL.val[0]    = FMat.val[1] - FMat.val[0];    // Compute linear partial wrt ybar
    FYbarMatL.val[1]    = FYbarMat.val[0];
    FYbarMatL.val[2]    = FMat.val[3] - FMat.val[2];    // Compute linear partial wrt ybar
    FYbarMatL.val[3]    = FYbarMat.val[2];
    FXYbarMatL.val[0]   = FYbarMat.val[2] - FYbarMat.val[0];    // Compute linear partial wrt xbar and ybar
    FXYbarMatL.val[1]   = FXYbarMat.val[0];
    FXYbarMatL.val[2]   = FXYbarMat.val[0];
    FXYbarMatL.val[3]   = FXYbarMat.val[0];
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]   = (FXbarMatC.val[pt] + FXbarMatL.val[pt])/2;     // Compute hybrid partial wrt xbar
        FYbarMat.val[pt]   = (FYbarMatC.val[pt] + FYbarMatL.val[pt])/2;     // Compute hybrid partial wrt ybar
        FXYbarMat.val[pt]  = (FXYbarMatC.val[pt] + FXYbarMatL.val[pt])/2;   // Compute hybrid partial wrt xbar and ybar
    }
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

HyperDual BicubicInterpolationHybridApprox(HyperDual& x, double xA, double xB, HyperDual& y, double yA, double yB, const doubleMat& FMat, const doubleMat& FXMat, const doubleMat& FYMat, const doubleMat& FXYMat)    // Bicubic interpolation for HyperDual input/output using hybrid approximation for partial derivatives; ordered in (xA,yA),(xA,yB),(xB,yA),(xB,yB) Inputs: (x,y) is point of interest, with x in [xA,xB] and y in [yA,yB], FMat are function values at cell vertices, FXMat are function derivatives wrt x at cell vertices, FYMat are function derivatives wrt y at cell vertices, FXYMat are function derivatives wrt x and y at cell vertices
{
    HyperDual interpVal;       // Value of interpolated data at (x,y)
    doubleMat FXbarMatC(4);     // Values of cubic function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatC(4);     // Values of cubic function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatC(4);    // Values of cubic function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMatL(4);     // Values of linear function derivatives wrt xbar in [0,1]
    doubleMat FYbarMatL(4);     // Values of linear function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMatL(4);    // Values of linear function derivatives wrt xbar and ybar in [0,1]
    doubleMat FXbarMat(4);      // Values of hybrid function derivatives wrt xbar in [0,1]
    doubleMat FYbarMat(4);      // Values of hybrid function derivatives wrt ybar in [0,1]
    doubleMat FXYbarMat(4);     // Values of hybrid function derivatives wrt xbar and ybar in [0,1]
    HyperDual xbar, ybar;      // Values of point of interest in [0,1]
    double xdiff, ydiff;        // Difference of cell intervals in x and y
    double a00,a01,a02,a03;     // Coefficients for bicubic interpolation
    double a10,a11,a12,a13;     // Coefficients for bicubic interpolation
    double a20,a21,a22,a23;     // Coefficients for bicubic interpolation
    double a30,a31,a32,a33;     // Coefficients for bicubic interpolation
    double b00,b01,b02,b03;     // Coefficients for bicubic interpolation
    double b10,b11,b12,b13;     // Coefficients for bicubic interpolation
    double b20,b21,b22,b23;     // Coefficients for bicubic interpolation
    double b30,b31,b32,b33;     // Coefficients for bicubic interpolation
    HyperDual c00,c10,c20,c30;  // Coefficients for bicubic interpolation
    
    xdiff = xB-xA;          // Difference in x interval
    ydiff = yB-yA;          // Difference in y interval
    xbar = (x-xA)/xdiff;    // Conversion to interval [0,1]
    ybar = (y-yA)/ydiff;    // Conversion to interval [0,1]
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMatC.val[pt]   = FXMat.val[pt]*xdiff;          // Compute cubic partial wrt xbar
        FYbarMatC.val[pt]   = FYMat.val[pt]*ydiff;          // Compute cubic partial wrt ybar
        FXYbarMatC.val[pt]  = FXYMat.val[pt]*xdiff*ydiff;   // Compute cubic partial wrt xbar and ybar
    }
    
    FXbarMatL.val[0]    = FMat.val[2] - FMat.val[0];    // Compute linear partial wrt xbar
    FXbarMatL.val[1]    = FMat.val[3] - FMat.val[1];    // Compute linear partial wrt xbar
    FXbarMatL.val[2]    = FXbarMat.val[0];
    FXbarMatL.val[3]    = FXbarMat.val[1];
    FYbarMatL.val[0]    = FMat.val[1] - FMat.val[0];    // Compute linear partial wrt ybar
    FYbarMatL.val[1]    = FYbarMat.val[0];
    FYbarMatL.val[2]    = FMat.val[3] - FMat.val[2];    // Compute linear partial wrt ybar
    FYbarMatL.val[3]    = FYbarMat.val[2];
    FXYbarMatL.val[0]   = FYbarMat.val[2] - FYbarMat.val[0];    // Compute linear partial wrt xbar and ybar
    FXYbarMatL.val[1]   = FXYbarMat.val[0];
    FXYbarMatL.val[2]   = FXYbarMat.val[0];
    FXYbarMatL.val[3]   = FXYbarMat.val[0];
    
    for (int pt=0; pt<4; pt++)  // For each point defining cell
    {
        FXbarMat.val[pt]   = (FXbarMatC.val[pt] + FXbarMatL.val[pt])/2;     // Compute hybrid partial wrt xbar
        FYbarMat.val[pt]   = (FYbarMatC.val[pt] + FYbarMatL.val[pt])/2;     // Compute hybrid partial wrt ybar
        FXYbarMat.val[pt]  = (FXYbarMatC.val[pt] + FXYbarMatL.val[pt])/2;   // Compute hybrid partial wrt xbar and ybar
    }
    
    // Compute bicubic interpolation coefficients
    b00 = FMat.val[0];
    b01 = FYbarMat.val[0];
    b02 = -3*FMat.val[0] + 3*FMat.val[1] - 2*FYbarMat.val[0] - FYbarMat.val[1];
    b03 = 2*FMat.val[0] - 2*FMat.val[1] + FYbarMat.val[0] + FYbarMat.val[1];
    b10 = FMat.val[2];
    b11 = FYbarMat.val[2];
    b12 = -3*FMat.val[2] + 3*FMat.val[3] - 2*FYbarMat.val[2] - FYbarMat.val[3];
    b13 = 2*FMat.val[2] - 2*FMat.val[3] + FYbarMat.val[2] + FYbarMat.val[3];
    b20 = FXbarMat.val[0];
    b21 = FXYbarMat.val[0];
    b22 = -3*FXbarMat.val[0] + 3*FXbarMat.val[1] - 2*FXYbarMat.val[0] - FXYbarMat.val[1];
    b23 = 2*FXbarMat.val[0] - 2*FXbarMat.val[1] + FXYbarMat.val[0] + FXYbarMat.val[1];
    b30 = FXbarMat.val[2];
    b31 = FXYbarMat.val[2];
    b32 = -3*FXbarMat.val[2] + 3*FXbarMat.val[3] - 2*FXYbarMat.val[2] - FXYbarMat.val[3];
    b33 = 2*FXbarMat.val[2] - 2*FXbarMat.val[3] + FXYbarMat.val[2] + FXYbarMat.val[3];
    
    a00 = b00;
    a01 = b01;
    a02 = b02;
    a03 = b03;
    a10 = b20;
    a11 = b21;
    a12 = b22;
    a13 = b23;
    a20 = -3*b00 + 3*b10 - 2*b20 - b30;
    a21 = -3*b01 + 3*b11 - 2*b21 - b31;
    a22 = -3*b02 + 3*b12 - 2*b22 - b32;
    a23 = -3*b03 + 3*b13 - 2*b23 - b33;
    a30 = 2*b00 - 2*b10 + b20 + b30;
    a31 = 2*b01 - 2*b11 + b21 + b31;
    a32 = 2*b02 - 2*b12 + b22 + b32;
    a33 = 2*b03 - 2*b13 + b23 + b33;
    
    c00 = a00 + a01*ybar+a02*ybar*ybar + a03*ybar*ybar*ybar;
    c10 = a10 + a11*ybar+a12*ybar*ybar + a13*ybar*ybar*ybar;
    c20 = a20 + a21*ybar+a22*ybar*ybar + a23*ybar*ybar*ybar;
    c30 = a30 + a31*ybar+a32*ybar*ybar + a33*ybar*ybar*ybar;
    
    interpVal = c00 + c10*xbar + c20*xbar*xbar + c30*xbar*xbar*xbar;
    
    return interpVal;
}

cubicInterpNAKModel ComputeCubicInterpNAKModel(int SolPts, const double* SolPtLocs, const double* SolVals)    // Computes coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    int N = SolPts-1;           // Number of intervals for cubic interpolation
    double h_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];              // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[SolPts];            // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[SolPts];   // Allocate memory for number of intervals minus one
    int P[SolPts+1];            // Allocate memory for number of intervals
    double Tol = 1e-8;          // Set tolerance for LUPDecompose function
    int stat;                   // Holder for LUPDecompose function output
    double y_i[SolPts];         // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    cubicInterpNAKModel cubicmodel; // Cubic interpolation model usnig "not a knot" condition
    
    if (SolPts<4)   // If less than 4 solution points to interrpolate
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",SolPts);
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs[coef+1] - SolPtLocs[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals[coef+1] - SolVals[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }
        
        for (int row=0; row<SolPts; row++)  // For each solution point
        {
            LUDMat[row] = getDoubleMat(SolPts); // Allocate memory for number of solution points
            if (row==0) // If first row in cubic spline system
            {
                LUDMat[0].val[0]    = -h_i[1];
                LUDMat[0].val[1]    = h_i[0]+h_i[1];
                LUDMat[0].val[2]    = -h_i[0];
                y_i[0]              = 0; // y_(1) = 0
            }
            else if (row==N)    // If final row in cubic spline system
            {
                LUDMat[N].val[N-2]  = -h_i[N-1];
                LUDMat[N].val[N-1]  = h_i[N-2]+h_i[N-1];
                LUDMat[N].val[N]    = -h_i[N-2];
                y_i[N]              = 0; // y_(SolPts) = 0
            }
            else    // Interior row in cubic spline system
            {
                LUDMat[row].val[row-1]  = c_i[row-1];
                LUDMat[row].val[row]    = 2*(c_i[row-1]+c_i[row]);
                LUDMat[row].val[row+1]  = c_i[row];
                y_i[row]                = -g_i[row-1] + g_i[row];  // y_i = -g_i + g_{i+1}
            }
        }
        
        stat = LUPDecompose(LUDMat,SolPts,Tol,P);   // Perform LU Decomposition
        
        LUPSolve(LUDMat,P,y_i,SolPts,m_i);  // Solve LUDMat*m_i = y_i for m_i
        
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            a_i[coef] = g_i[coef] - c_i[coef]*(m_i[coef+1]-m_i[coef]);
            b_i[coef] = SolVals[coef] - m_i[coef]*h_i[coef]*c_i[coef];
        }
        
        cubicmodel = getCubicInterpNAKModel(SolPts,SolPtLocs,m_i,a_i,b_i,h_i);
    }
    
    return cubicmodel;
}

cubicInterpNAKModel ComputeCubicInterpNAKModel(int SolPts, const doubleMat& SolPtLocs, const doubleMat& SolVals)    // Computes coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    int N = SolPts-1;           // Number of intervals for cubic interpolation
    double h_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double k_i[N];              // Difference between x_i values. Allocate memory for number of intervals
    double c_i[N];              // Difference between h_i/6 values. Allocate memory for number of intervals
    double m_i[SolPts];            // Coefficient values for cubic interpolation. Allocate memory for number of intervals minus one
    double g_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    doubleMat LUDMat[SolPts];   // Allocate memory for number of intervals minus one
    int P[SolPts+1];            // Allocate memory for number of intervals
    double Tol = 1e-8;          // Set tolerance for LUPDecompose function
    int stat;                   // Holder for LUPDecompose function output
    double y_i[SolPts];         // RHS of cubic spline system equation. Allocate memory for number of intervals minus one
    double a_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    double b_i[N];              // Coefficient values for cubic interpolation. Allocate memory for number of intervals
    cubicInterpNAKModel cubicmodel; // Cubic interpolation model usnig "not a knot" condition
    
    if (SolPts<4)   // If less than 4 solution points to interrpolate
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",SolPts);
    }
    else
    {
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            h_i[coef] = SolPtLocs.val[coef+1] - SolPtLocs.val[coef];    // Compute h_i = x_{i+1}-x_i
            k_i[coef] = SolVals.val[coef+1] - SolVals.val[coef];        // Compute k_i = f_{i+1}-f_i
            c_i[coef] = h_i[coef]/6;                                    // Compute c_i = h_i/6
            g_i[coef] = k_i[coef]/h_i[coef];                            // Compute g_i = k_i/h_i
        }
        
        for (int row=0; row<SolPts; row++)  // For each solution point
        {
            LUDMat[row] = getDoubleMat(SolPts); // Allocate memory for number of solution points
            if (row==0) // If first row in cubic spline system
            {
                LUDMat[0].val[0]    = -h_i[1];
                LUDMat[0].val[1]    = h_i[0]+h_i[1];
                LUDMat[0].val[2]    = -h_i[0];
                y_i[0]              = 0; // y_(1) = 0
            }
            else if (row==N)    // If final row in cubic spline system
            {
                LUDMat[N].val[N-2]  = -h_i[N-1];
                LUDMat[N].val[N-1]  = h_i[N-2]+h_i[N-1];
                LUDMat[N].val[N]    = -h_i[N-2];
                y_i[N]              = 0; // y_(SolPts) = 0
            }
            else    // Interior row in cubic spline system
            {
                LUDMat[row].val[row-1]  = c_i[row-1];
                LUDMat[row].val[row]    = 2*(c_i[row-1]+c_i[row]);
                LUDMat[row].val[row+1]  = c_i[row];
                y_i[row]                = -g_i[row-1] + g_i[row];  // y_i = -g_i + g_{i+1}
            }
        }
        
        stat = LUPDecompose(LUDMat,SolPts,Tol,P);   // Perform LU Decomposition
        
        LUPSolve(LUDMat,P,y_i,SolPts,m_i);  // Solve LUDMat*m_i = y_i for m_i
        
        for (int coef=0; coef<N; coef++)    // For each interval
        {
            a_i[coef] = g_i[coef] - c_i[coef]*(m_i[coef+1]-m_i[coef]);
            b_i[coef] = SolVals.val[coef] - m_i[coef]*h_i[coef]*c_i[coef];
        }
        
        cubicmodel = getCubicInterpNAKModel(SolPts,SolPtLocs,m_i,a_i,b_i,h_i);
    }
    
    return cubicmodel;
}

doubleMat EvaluateCubicInterpNAKModel(int PolPts, doubleMat& PolPtLocs, cubicInterpNAKModel& cubicmodel)    // Evaluate cubic interpolation model at points to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    doubleMat PolVals(PolPts);  // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    int CurrInt;                // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=cubicmodel.x_i[1]) // First solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLocs.val[pt]-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
            }
            else if (PolPtLocs.val[pt]>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<cubicmodel.Intervals)&&(PolPtLocs.val[pt]>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                
                PolVals.val[pt] = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
            }
        }
        
    }
    
    return PolVals;
}

BicomplexMat EvaluateCubicInterpNAKModel(int PolPts, BicomplexMat& PolPtLocs, const cubicInterpNAKModel& cubicmodel)  // Evaluate cubic interpolation model at points to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    BicomplexMat PolVals(PolPts);   // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    int CurrInt;                    // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=cubicmodel.x_i[1]) // First solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLocs.val[pt]-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
            }
            else if (PolPtLocs.val[pt]>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<cubicmodel.Intervals)&&(PolPtLocs.val[pt]>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                
                PolVals.val[pt] = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
            }
        }
        
    }
    
    return PolVals;
}

HyperDualMat EvaluateCubicInterpNAKModel(int PolPts, HyperDualMat& PolPtLocs, const cubicInterpNAKModel& cubicmodel)  // Evaluate cubic interpolation model at points to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    HyperDualMat PolVals(PolPts);   // Interpolated values to be returned. Allocate memory for number of interpolation (or extrapolation) points
    int CurrInt;                    // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)   // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        for (int pt=0; pt<PolPts; pt++) // For each interpolation point
        {
            if (PolPtLocs.val[pt]<=cubicmodel.x_i[1]) // First solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])*(cubicmodel.x_i[1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])*(PolPtLocs.val[pt]-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLocs.val[pt]-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
            }
            else if (PolPtLocs.val[pt]>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
            {
                PolVals.val[pt] = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLocs.val[pt]-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
            }
            else    // Interior solution interval used for interpolation
            {
                CurrInt = 1;    // Set to second interval defined by solution points
                while ((CurrInt<cubicmodel.Intervals)&&(PolPtLocs.val[pt]>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
                {
                    CurrInt++;  // Increment to next interval
                }
                // Should exit when current solution interval has upper point bound greater than current interpolation point
                
                PolVals.val[pt] = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])*(cubicmodel.x_i[CurrInt+1]-PolPtLocs.val[pt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLocs.val[pt]-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
            }
        }
        
    }
    
    return PolVals;
}

double EvaluateCubicInterpNAKModel(double PolPtLoc, const cubicInterpNAKModel& cubicmodel)  // Evaluate cubic interpolation model at point to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    double PolVal=0;  // Interpolated value to be returned
    int CurrInt;    // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)    // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        if (PolPtLoc<=cubicmodel.x_i[1]) // First solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLoc-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
        }
        else if (PolPtLoc>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
        }
        else    // Interior solution interval used for interpolation
        {
            CurrInt = 1;    // Set to second interval defined by solution points
            while ((CurrInt<cubicmodel.Intervals)&&(PolPtLoc>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
            {
                CurrInt++;  // Increment to next interval
            }
            // Should exit when current solution interval has upper point bound greater than current interpolation point
            
            PolVal = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLoc-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
        }
    }
    
    return PolVal;
}

Bicomplex EvaluateCubicInterpNAKModel(Bicomplex& PolPtLoc, const cubicInterpNAKModel& cubicmodel)    // Evaluate cubic interpolation model at point to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    Bicomplex PolVal;   // Interpolated value to be returned
    int CurrInt;        // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)    // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        if (PolPtLoc<=cubicmodel.x_i[1]) // First solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLoc-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
        }
        else if (PolPtLoc>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
        }
        else    // Interior solution interval used for interpolation
        {
            CurrInt = 1;    // Set to second interval defined by solution points
            while ((CurrInt<cubicmodel.Intervals)&&(PolPtLoc>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
            {
                CurrInt++;  // Increment to next interval
            }
            // Should exit when current solution interval has upper point bound greater than current interpolation point
            
            PolVal = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLoc-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
        }
    }
    
    return PolVal;
}

HyperDual EvaluateCubicInterpNAKModel(HyperDual& PolPtLoc, const cubicInterpNAKModel& cubicmodel)    // Evaluate cubic interpolation model at point to be interpolated; coefficients for cubic interpolation function using "not-a-knot" condition (SolPoints must be >= 4)
{
    HyperDual PolVal;   // Interpolated value to be returned
    int CurrInt;        // Current interval of solution points used for interpolation
    
    if (cubicmodel.SolPts<4)    // Less than 4 solution points to interrpolate, use linear interpolation
    {
        printf("\nERROR:Need at least 4 solution points to interpolate, SolPts = %d",cubicmodel.SolPts);
    }
    else
    {
        if (PolPtLoc<=cubicmodel.x_i[1]) // First solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[0]*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)*(cubicmodel.x_i[1]-PolPtLoc)/(6*cubicmodel.h_i[0]) + cubicmodel.m_i[1]*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])*(PolPtLoc-cubicmodel.x_i[0])/(6*cubicmodel.h_i[0]) + cubicmodel.a_i[0]*(PolPtLoc-cubicmodel.x_i[0]) + cubicmodel.b_i[0];
        }
        else if (PolPtLoc>=cubicmodel.x_i[cubicmodel.Intervals])   // Final solution interval used for interpolation
        {
            PolVal = cubicmodel.m_i[cubicmodel.Intervals-1]*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)*(cubicmodel.x_i[cubicmodel.Intervals]-PolPtLoc)/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.m_i[cubicmodel.Intervals]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1])/(6*cubicmodel.h_i[cubicmodel.Intervals-1]) + cubicmodel.a_i[cubicmodel.Intervals-1]*(PolPtLoc-cubicmodel.x_i[cubicmodel.Intervals-1]) + cubicmodel.b_i[cubicmodel.Intervals-1];
        }
        else    // Interior solution interval used for interpolation
        {
            CurrInt = 1;    // Set to second interval defined by solution points
            while ((CurrInt<cubicmodel.Intervals)&&(PolPtLoc>cubicmodel.x_i[CurrInt+1]))   // While CurrInt is less than the number of intervals and the location of the current interpolation point is greater than the upper point value of the current interval
            {
                CurrInt++;  // Increment to next interval
            }
            // Should exit when current solution interval has upper point bound greater than current interpolation point
            
            PolVal = cubicmodel.m_i[CurrInt]*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)*(cubicmodel.x_i[CurrInt+1]-PolPtLoc)/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.m_i[CurrInt+1]*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])*(PolPtLoc-cubicmodel.x_i[CurrInt])/(6*cubicmodel.h_i[CurrInt]) + cubicmodel.a_i[CurrInt]*(PolPtLoc-cubicmodel.x_i[CurrInt]) + cubicmodel.b_i[CurrInt];
        }
    }
    
    return PolVal;
}

double EvaluatePiecewisePolynomial(double PolPtLoc, const doubleMat& Breaks, const doubleMatMat& Coefs) // Evaluate a piecewise polynomial given the breaks and polynomial coefficients for each interval
{
    double PolVal;
    int NumIntervals;
    int NumCoefs;
    int CurrInterval;
    double CoeffVal;
    
    PolVal          = 0;                        // Initialize value at interpolated point to be zero
    NumIntervals    = Coefs.Len;                // Extract number of intervals piecewise polynomial covers
    NumCoefs        = Coefs.mat[0].Len;   // Extract number of coefficients used piecewise polynomials
    
    if (PolPtLoc<Breaks.val[1]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = 0;   // Initialize current interval to first interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else if (PolPtLoc>=Breaks.val[NumIntervals]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = NumIntervals-1;  // Initialize current interval to last interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else
    {
        CurrInterval = 1;   // Initialize current interval to first interval
        while ((CurrInterval<(NumIntervals-1))&&(PolPtLoc>Breaks.val[CurrInterval+1]))  // While current interval is not the last interval and the point to be interpolating is greater than the upper bound of the current interval
        {
            CurrInterval++; // Increment to next interval
        }   // Should exit in correct interval where PolPtLoc is in [Breaks.val[CurrInterval],Breaks.val[CurrInterval+1]]
        
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    
    
    return PolVal;
}

Bicomplex EvaluatePiecewisePolynomial(Bicomplex& PolPtLoc, const doubleMat& Breaks, const doubleMatMat& Coefs)   // Evaluate a piecewise polynomial given the breaks and polynomial coefficients for each interval
{
    Bicomplex PolVal;
    int NumIntervals;
    int NumCoefs;
    int CurrInterval;
    Bicomplex CoeffVal;
    
    NumIntervals    = Coefs.Len;                // Extract number of intervals piecewise polynomial covers
    NumCoefs        = Coefs.mat[0].Len;   // Extract number of coefficients used piecewise polynomials
    
    if (PolPtLoc<Breaks.val[1]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = 0;   // Initialize current interval to first interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else if (PolPtLoc>=Breaks.val[NumIntervals]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = NumIntervals-1;  // Initialize current interval to last interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else
    {
        CurrInterval = 1;   // Initialize current interval to first interval
        while ((CurrInterval<(NumIntervals-1))&&(PolPtLoc>Breaks.val[CurrInterval+1]))  // While current interval is not the last interval and the point to be interpolating is greater than the upper bound of the current interval
        {
            CurrInterval++; // Increment to next interval
        }   // Should exit in correct interval where PolPtLoc is in [Breaks.val[CurrInterval],Breaks.val[CurrInterval+1]]
        
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    
    
    return PolVal;
}

HyperDual EvaluatePiecewisePolynomial(HyperDual& PolPtLoc, const doubleMat& Breaks, const doubleMatMat& Coefs)   // Evaluate a piecewise polynomial given the breaks and polynomial coefficients for each interval
{
    HyperDual PolVal;
    int NumIntervals;
    int NumCoefs;
    int CurrInterval;
    HyperDual CoeffVal;
    
    NumIntervals    = Coefs.Len;                // Extract number of intervals piecewise polynomial covers
    NumCoefs        = Coefs.mat[0].Len;   // Extract number of coefficients used piecewise polynomials
    
    if (PolPtLoc<Breaks.val[1]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = 0;   // Initialize current interval to first interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else if (PolPtLoc>=Breaks.val[NumIntervals]) // If point to be interpolated is less than upper bound of first interval
    {
        CurrInterval = NumIntervals-1;  // Initialize current interval to last interval
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    else
    {
        CurrInterval = 1;   // Initialize current interval to first interval
        while ((CurrInterval<(NumIntervals-1))&&(PolPtLoc>Breaks.val[CurrInterval+1]))  // While current interval is not the last interval and the point to be interpolating is greater than the upper bound of the current interval
        {
            CurrInterval++; // Increment to next interval
        }   // Should exit in correct interval where PolPtLoc is in [Breaks.val[CurrInterval],Breaks.val[CurrInterval+1]]
        
        for (int coef=0; coef<NumCoefs; coef++) // For each coefficient in polynomial
        {
            CoeffVal = Coefs.mat[CurrInterval].val[coef]; // Initialize coefficient value to coeff at x^(NumCoefs-(coef+1)) in current interval
            for (int mult=0; mult<(NumCoefs-(coef+1)); mult++)  // For (NumCoefs-(coef+1)) times
            {
                CoeffVal = CoeffVal*(PolPtLoc-Breaks.val[CurrInterval]);    // Multiple coefficient by difference of interpolated point location and lower bound of current interval
            }
            PolVal = PolVal + CoeffVal; // Add coefficient value to interpolated value at point
        }
    }
    
    
    return PolVal;
}


double BicubicInterpolationWrapper(double x, double y, const doubleMat& xMat, const doubleMat& yMat, const doubleMatMat& FMatMat, const doubleMatMat& FXMatMat, const doubleMatMat& FYMatMat, const doubleMatMat& FXYMatMat)    // Bicubic interpolation for double input/output; inputs: point of interest (x,y) where xMat are x values of tqble rows, yMat are y values of table columns, FMatMat is f values at points in table, FXMatMat is derivative wrt x values at points in table, FYMatMat is derivative wrt y values at points in table, FXYMatMat is derivative wrt x and y values at points in table
{
    double PolVal;
    int NumX, NumY;
    int xLind, xUind;
    int yLind, yUind;
    doubleMat FMat(4),FXMat(4),FYMat(4),FXYMat(4);
    
    NumX = xMat.Len;
    NumY = yMat.Len;
    
    if (x<xMat.val[1])  // If x point is less than upper bound of first x interval
    {
        xLind = 0;  // Set lower index for x to index of lower bound in first interval
        xUind = 1;  // Set upper index for x to index of upper bound in first interval
    }
    else if (x>xMat.val[NumX-1])    // If x point is greater than upper bound of last x interval
    {
        xLind = NumX-2; // Set lower index for x to index of lower bound in last interval
        xUind = NumX-1; // Set upper index for x to index of upper bound in last interval
    }
    else
    {
        xUind = 2;  // Initialize lower index for x to index of lower bound in second interval
        while ((xUind<(NumX-1))&&(x>xMat.val[xUind]))   // If upper index is less than last index and point x is greater than upper bound of current interval
        {
            xUind++;    // Increment upper index for x by one
        }
        xLind = xUind-1;    // Set lower index for x equal to upper index minus one
    }
    
    if (y<yMat.val[1])  // If y point is less than upper bound of first y interval
    {
        yLind = 0;  // Set lower index for y to index of lower bound in first interval
        yUind = 1;  // Set upper index for y to index of upper bound in first interval
    }
    else if (y>yMat.val[NumY-1])    // If y point is greater than upper bound of last y interval
    {
        yLind = NumY-2; // Set lower index for y to index of lower bound in last interval
        yUind = NumY-1; // Set upper index for y to index of upper bound in last interval
    }
    else
    {
        yUind = 2;  // Initialize lower index for y to index of lower bound in second interval
        while ((yUind<(NumY-1))&&(y>yMat.val[yUind]))   // If upper index is less than last index and point y is greater than upper bound of current interval
        {
            yUind++;    // Increment upper index for y by one
        }
        yLind = yUind-1;    // Set lower index for y equal to upper index minus one
    }
    
//    printf4MATLAB("xMat",xMat);
//    printf4MATLAB("yMat",yMat);
//    printf("\nxLval = %.15e  |  xval = %.15e  |  xUval = %.15e",xMat.val[xLind],x,xMat.val[xUind]);
//    printf("\nyLval = %.15e  |  yval = %.15e  |  yUval = %.15e",yMat.val[yLind],y,yMat.val[yUind]);
    
    FMat.val[0] = FMatMat.mat[xLind].val[yLind];
    FMat.val[1] = FMatMat.mat[xLind].val[yUind];
    FMat.val[2] = FMatMat.mat[xUind].val[yLind];
    FMat.val[3] = FMatMat.mat[xUind].val[yUind];
    
    FXMat.val[0] = FXMatMat.mat[xLind].val[yLind];
    FXMat.val[1] = FXMatMat.mat[xLind].val[yUind];
    FXMat.val[2] = FXMatMat.mat[xUind].val[yLind];
    FXMat.val[3] = FXMatMat.mat[xUind].val[yUind];
    
    FYMat.val[0] = FYMatMat.mat[xLind].val[yLind];
    FYMat.val[1] = FYMatMat.mat[xLind].val[yUind];
    FYMat.val[2] = FYMatMat.mat[xUind].val[yLind];
    FYMat.val[3] = FYMatMat.mat[xUind].val[yUind];
    
    FXYMat.val[0] = FXYMatMat.mat[xLind].val[yLind];
    FXYMat.val[1] = FXYMatMat.mat[xLind].val[yUind];
    FXYMat.val[2] = FXYMatMat.mat[xUind].val[yLind];
    FXYMat.val[3] = FXYMatMat.mat[xUind].val[yUind];
    
//    printf("\nxLind = %d  |  xUind = %d  |  yLind = %d  |  yUind = %d",xLind,xUind,yLind,yUind);
//    printf4MATLAB("FMat",FMat);
//    printfMatrix(FMatMat);
//    printf4MATLAB("FXMat",FXMat);
//    printfMatrix(FXMatMat);
//    printf4MATLAB("FYMat",FYMat);
//    printfMatrix(FYMatMat);
//    printf4MATLAB("FXYMat",FXYMat);
//    printfMatrix(FXYMatMat);
    
    PolVal = BicubicInterpolation(x,xMat.val[xLind],xMat.val[xUind],y,yMat.val[yLind],yMat.val[yUind],FMat,FXMat,FYMat,FXYMat);
    
    return PolVal;
}

Bicomplex BicubicInterpolationWrapper(Bicomplex& x, Bicomplex& y, const doubleMat& xMat, const doubleMat& yMat, const doubleMatMat& FMatMat, const doubleMatMat& FXMatMat, const doubleMatMat& FYMatMat, const doubleMatMat& FXYMatMat)    // Bicubic interpolation for Bicomplex input/output; inputs: point of interest (x,y) where xMat are x values of tqble rows, yMat are y values of table columns, FMatMat is f values at points in table, FXMatMat is derivative wrt x values at points in table, FYMatMat is derivative wrt y values at points in table, FXYMatMat is derivative wrt x and y values at points in table
{
    Bicomplex PolVal;
    int NumX, NumY;
    int xLind, xUind;
    int yLind, yUind;
    doubleMat FMat(4),FXMat(4),FYMat(4),FXYMat(4);
    
    NumX = xMat.Len;
    NumY = yMat.Len;
    
    if (x<xMat.val[1])  // If x point is less than upper bound of first x interval
    {
        xLind = 0;  // Set lower index for x to index of lower bound in first interval
        xUind = 1;  // Set upper index for x to index of upper bound in first interval
    }
    else if (x>xMat.val[NumX-1])    // If x point is greater than upper bound of last x interval
    {
        xLind = NumX-2; // Set lower index for x to index of lower bound in last interval
        xUind = NumX-1; // Set upper index for x to index of upper bound in last interval
    }
    else
    {
        xUind = 2;  // Initialize lower index for x to index of lower bound in second interval
        while ((xUind<(NumX-1))&&(x>xMat.val[xUind]))   // If upper index is less than last index and point x is greater than upper bound of current interval
        {
            xUind++;    // Increment upper index for x by one
        }
        xLind = xUind-1;    // Set lower index for x equal to upper index minus one
    }
    
    if (y<yMat.val[1])  // If y point is less than upper bound of first y interval
    {
        yLind = 0;  // Set lower index for y to index of lower bound in first interval
        yUind = 1;  // Set upper index for y to index of upper bound in first interval
    }
    else if (y>yMat.val[NumY-1])    // If y point is greater than upper bound of last y interval
    {
        yLind = NumY-2; // Set lower index for y to index of lower bound in last interval
        yUind = NumY-1; // Set upper index for y to index of upper bound in last interval
    }
    else
    {
        yUind = 2;  // Initialize lower index for y to index of lower bound in second interval
        while ((yUind<(NumY-1))&&(y>yMat.val[yUind]))   // If upper index is less than last index and point y is greater than upper bound of current interval
        {
            yUind++;    // Increment upper index for y by one
        }
        yLind = yUind-1;    // Set lower index for y equal to upper index minus one
    }
    
//    printf4MATLAB("xMat",xMat);
//    printf4MATLAB("yMat",yMat);
//    printf("\nxLval = %.15e  |  xval = %.15e  |  xUval = %.15e",xMat.val[xLind],x.R,xMat.val[xUind]);
//    printf("\nyLval = %.15e  |  yval = %.15e  |  yUval = %.15e",yMat.val[yLind],y.R,yMat.val[yUind]);
    
    FMat.val[0] = FMatMat.mat[xLind].val[yLind];
    FMat.val[1] = FMatMat.mat[xLind].val[yUind];
    FMat.val[2] = FMatMat.mat[xUind].val[yLind];
    FMat.val[3] = FMatMat.mat[xUind].val[yUind];
    
    FXMat.val[0] = FXMatMat.mat[xLind].val[yLind];
    FXMat.val[1] = FXMatMat.mat[xLind].val[yUind];
    FXMat.val[2] = FXMatMat.mat[xUind].val[yLind];
    FXMat.val[3] = FXMatMat.mat[xUind].val[yUind];
    
    FYMat.val[0] = FYMatMat.mat[xLind].val[yLind];
    FYMat.val[1] = FYMatMat.mat[xLind].val[yUind];
    FYMat.val[2] = FYMatMat.mat[xUind].val[yLind];
    FYMat.val[3] = FYMatMat.mat[xUind].val[yUind];
    
    FXYMat.val[0] = FXYMatMat.mat[xLind].val[yLind];
    FXYMat.val[1] = FXYMatMat.mat[xLind].val[yUind];
    FXYMat.val[2] = FXYMatMat.mat[xUind].val[yLind];
    FXYMat.val[3] = FXYMatMat.mat[xUind].val[yUind];
    
//    printf("\nxLind = %d  |  xUind = %d  |  yLind = %d  |  yUind = %d",xLind,xUind,yLind,yUind);
//    printf4MATLAB("FMat",FMat);
//    printfMatrix(FMatMat);
//    printf4MATLAB("FXMat",FXMat);
//    printfMatrix(FXMatMat);
//    printf4MATLAB("FYMat",FYMat);
//    printfMatrix(FYMatMat);
//    printf4MATLAB("FXYMat",FXYMat);
//    printfMatrix(FXYMatMat);
    
    PolVal = BicubicInterpolation(x,xMat.val[xLind],xMat.val[xUind],y,yMat.val[yLind],yMat.val[yUind],FMat,FXMat,FYMat,FXYMat);
    
    return PolVal;
}

HyperDual BicubicInterpolationWrapper(HyperDual& x, HyperDual& y, const doubleMat& xMat, const doubleMat& yMat, const doubleMatMat& FMatMat, const doubleMatMat& FXMatMat, const doubleMatMat& FYMatMat, const doubleMatMat& FXYMatMat)    // Bicubic interpolation for HyperDual input/output; inputs: point of interest (x,y) where xMat are x values of tqble rows, yMat are y values of table columns, FMatMat is f values at points in table, FXMatMat is derivative wrt x values at points in table, FYMatMat is derivative wrt y values at points in table, FXYMatMat is derivative wrt x and y values at points in table
{
    HyperDual PolVal;
    int NumX, NumY;
    int xLind, xUind;
    int yLind, yUind;
    doubleMat FMat(4),FXMat(4),FYMat(4),FXYMat(4);
    
    NumX = xMat.Len;
    NumY = yMat.Len;
    
    if (x<xMat.val[1])  // If x point is less than upper bound of first x interval
    {
        xLind = 0;  // Set lower index for x to index of lower bound in first interval
        xUind = 1;  // Set upper index for x to index of upper bound in first interval
    }
    else if (x>xMat.val[NumX-1])    // If x point is greater than upper bound of last x interval
    {
        xLind = NumX-2; // Set lower index for x to index of lower bound in last interval
        xUind = NumX-1; // Set upper index for x to index of upper bound in last interval
    }
    else
    {
        xUind = 2;  // Initialize lower index for x to index of lower bound in second interval
        while ((xUind<(NumX-1))&&(x>xMat.val[xUind]))   // If upper index is less than last index and point x is greater than upper bound of current interval
        {
            xUind++;    // Increment upper index for x by one
        }
        xLind = xUind-1;    // Set lower index for x equal to upper index minus one
    }
    
    if (y<yMat.val[1])  // If y point is less than upper bound of first y interval
    {
        yLind = 0;  // Set lower index for y to index of lower bound in first interval
        yUind = 1;  // Set upper index for y to index of upper bound in first interval
    }
    else if (y>yMat.val[NumY-1])    // If y point is greater than upper bound of last y interval
    {
        yLind = NumY-2; // Set lower index for y to index of lower bound in last interval
        yUind = NumY-1; // Set upper index for y to index of upper bound in last interval
    }
    else
    {
        yUind = 2;  // Initialize lower index for y to index of lower bound in second interval
        while ((yUind<(NumY-1))&&(y>yMat.val[yUind]))   // If upper index is less than last index and point y is greater than upper bound of current interval
        {
            yUind++;    // Increment upper index for y by one
        }
        yLind = yUind-1;    // Set lower index for y equal to upper index minus one
    }
    
    //    printf4MATLAB("xMat",xMat);
    //    printf4MATLAB("yMat",yMat);
    //    printf("\nxLval = %.15e  |  xval = %.15e  |  xUval = %.15e",xMat.val[xLind],x.R,xMat.val[xUind]);
    //    printf("\nyLval = %.15e  |  yval = %.15e  |  yUval = %.15e",yMat.val[yLind],y.R,yMat.val[yUind]);
    
    FMat.val[0] = FMatMat.mat[xLind].val[yLind];
    FMat.val[1] = FMatMat.mat[xLind].val[yUind];
    FMat.val[2] = FMatMat.mat[xUind].val[yLind];
    FMat.val[3] = FMatMat.mat[xUind].val[yUind];
    
    FXMat.val[0] = FXMatMat.mat[xLind].val[yLind];
    FXMat.val[1] = FXMatMat.mat[xLind].val[yUind];
    FXMat.val[2] = FXMatMat.mat[xUind].val[yLind];
    FXMat.val[3] = FXMatMat.mat[xUind].val[yUind];
    
    FYMat.val[0] = FYMatMat.mat[xLind].val[yLind];
    FYMat.val[1] = FYMatMat.mat[xLind].val[yUind];
    FYMat.val[2] = FYMatMat.mat[xUind].val[yLind];
    FYMat.val[3] = FYMatMat.mat[xUind].val[yUind];
    
    FXYMat.val[0] = FXYMatMat.mat[xLind].val[yLind];
    FXYMat.val[1] = FXYMatMat.mat[xLind].val[yUind];
    FXYMat.val[2] = FXYMatMat.mat[xUind].val[yLind];
    FXYMat.val[3] = FXYMatMat.mat[xUind].val[yUind];
    
    //    printf("\nxLind = %d  |  xUind = %d  |  yLind = %d  |  yUind = %d",xLind,xUind,yLind,yUind);
    //    printf4MATLAB("FMat",FMat);
    //    printfMatrix(FMatMat);
    //    printf4MATLAB("FXMat",FXMat);
    //    printfMatrix(FXMatMat);
    //    printf4MATLAB("FYMat",FYMat);
    //    printfMatrix(FYMatMat);
    //    printf4MATLAB("FXYMat",FXYMat);
    //    printfMatrix(FXYMatMat);
    
    PolVal = BicubicInterpolation(x,xMat.val[xLind],xMat.val[xUind],y,yMat.val[yLind],yMat.val[yUind],FMat,FXMat,FYMat,FXYMat);
    
    return PolVal;
}

double getLagrangeInterp(const doubleMat& s, const doubleMat& sol, double sInterp) // Use Lagrange interpolating polynomial for support points s and values sol to interpolate at point sInterp in [-1,1] for double input/output
{
    double xInterp;
    double funcwght;
    
    xInterp = 0;
    
    for (int k=0; k<s.Len; k++)
    {
        funcwght = 1;
        
        for (int j=0; j<k; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        for (int j=k+1; j<s.Len; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        
        xInterp = xInterp + funcwght*sol.val[k];
        
//        printf("\nfuncwght = %.25f",funcwght);
    }
    
    return xInterp;
}

Bicomplex getLagrangeInterp(const doubleMat& s, const doubleMat& sol, Bicomplex& sInterp) // Use Lagrange interpolating polynomial for support points s and values sol to interpolate at point sInterp in [-1,1] for Bicomplex input/output
{
    Bicomplex xInterp;
    Bicomplex funcwght;
    
    xInterp = 0;
    
    for (int k=0; k<s.Len; k++)
    {
        funcwght = 1;
        
        for (int j=0; j<k; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        for (int j=k+1; j<s.Len; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        
        xInterp = xInterp + funcwght*sol.val[k];
        
//        printf("funcwght",funcwght);
    }
    
    return xInterp;
}

HyperDual getLagrangeInterp(const doubleMat& s, const doubleMat& sol, HyperDual& sInterp) // Use Lagrange interpolating polynomial for support points s and values sol to interpolate at point sInterp in [-1,1] for HyperDual input/output
{
    HyperDual xInterp;
    HyperDual funcwght;
    
    xInterp = 0;
    
    for (int k=0; k<s.Len; k++)
    {
        funcwght = 1;
        
        for (int j=0; j<k; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        for (int j=k+1; j<s.Len; j++)
        {
            funcwght = (sInterp - s.val[j])/(s.val[k] - s.val[j])*funcwght;
        }
        
        xInterp = xInterp + funcwght*sol.val[k];
        
        //        printf("funcwght",funcwght);
    }
    
    return xInterp;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------Parameter functions----------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void InitPhaseParameters(const int* Nt) // Initialize phase parameters used for computations in each phase dynamics/path/lagrange functions of problem
{
    //    printf("\nInitializing Phase Parameters");
    
    if (PhaseParametersInitFlagG)   // If phase parameters need to be initialized
    {
        // Allocate memory for each phase in problem
        phaseparametersG                = getParametersStructMat(PG);
        phaseparameterssolG             = getParametersStructMat(PG);
        phaseparametersBCG              = getParametersStructBCMat(PG);
        phaseparametersHDG              = getParametersStructHDMat(PG);
        phaseparametersCDG              = getParametersStructMat(PG);
        PhaseParameterDependenciesG     = new intMatMat[PG];
        StatePhaseDependenciesG         = new intMatMat[PG];
        ControlPhaseDependenciesG       = new intMatMat[PG];
        StaticPhaseDependenciesG        = new intMatMat[PG];
        TimePhaseDependenciesG          = new intMatMat[PG];
        DynamicPhaseDependenciesG       = new intMatMat[PG];
        PathPhaseDependenciesG          = new intMatMat[PG];
        LagrangePhaseDependenciesG      = new intMatMat[PG];
        PhaseDynamicTimeDependMapG      = new intMatMatMat[PG];
        PhaseDynamicStateDependMapG     = new intMatMatMat[PG];
        PhaseDynamicControlDependMapG   = new intMatMatMat[PG];
        PhaseDynamicStaticDependMapG    = new intMatMatMat[PG];
        PhasePathTimeDependMapG         = new intMatMatMat[PG];
        PhasePathStateDependMapG        = new intMatMatMat[PG];
        PhasePathControlDependMapG      = new intMatMatMat[PG];
        PhasePathStaticDependMapG       = new intMatMatMat[PG];
        PhaseLagrangeTimeDependMapG     = new intMatMatMat[PG];
        PhaseLagrangeStateDependMapG    = new intMatMatMat[PG];
        PhaseLagrangeControlDependMapG  = new intMatMatMat[PG];
        PhaseLagrangeStaticDependMapG   = new intMatMatMat[PG];
        DynamicTimeDependMapG           = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        DynamicStateDependMapG          = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        DynamicControlDependMapG        = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        DynamicStaticDependMapG         = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        PathTimeDependMapG              = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        PathStateDependMapG             = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        PathControlDependMapG           = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        PathStaticDependMapG            = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        LagrangeTimeDependMapG          = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        LagrangeStateDependMapG         = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        LagrangeControlDependMapG       = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        LagrangeStaticDependMapG        = getIntMatMatMat(PG);  // Allocate memory for each phase in problem
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            phaseparametersG.parametersStruct[phase]     = getParametersStruct(Nt[phase]+1);
            phaseparametersBCG.parametersStruct[phase]   = getParametersStructBC(Nt[phase]+1);
            phaseparametersHDG.parametersStruct[phase]   = getParametersStructHD(Nt[phase]+1);
            phaseparametersCDG.parametersStruct[phase]   = getParametersStruct(Nt[phase]+1);
            
            if (nppG[phase]>0)  // If phase parameters used in phase
            {
                // Allocate memory for number of phase parameters
                
                PhaseParameterDependenciesG[phase] = getIntMatMat(nppG[phase]); // Allocate memory for number of phase paramters;
                for (int comp=0; comp<(nppG[phase]-1); comp++)  // For each phase parameter except last
                {
                    PhaseParameterDependenciesG[phase].mat[comp] = getIntMat(nppG[phase]-(1+comp));  // Allocate memory for number of possible phase parameter dependencies
                }
                
                // Allocate memory for parameter to state and dynamic function dependencies mapping
                if (nxG[phase]>0)   // If there are 1 or more state components in phase
                {
                    StatePhaseDependenciesG[phase]      = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase;
                    DynamicPhaseDependenciesG[phase]    = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase;

                    for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        StatePhaseDependenciesG[phase].mat[comp]     = getIntMat(nppG[phase]);   // Allocate memory for number of phase parameters in phase
                        DynamicPhaseDependenciesG[phase].mat[comp]   = getIntMat(nppG[phase]);   // Allocate memory for number of phase parameters in phase
                    }
                    
                    PhaseDynamicTimeDependMapG[phase]       = getIntMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase;
                    PhaseDynamicStateDependMapG[phase]      = getIntMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase;
                    PhaseDynamicControlDependMapG[phase]    = getIntMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase;
                    PhaseDynamicStaticDependMapG[phase]     = getIntMatMatMat(nxG[phase]);  // Allocate memory for number of state components in phase;
                    
                    for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        PhaseDynamicTimeDependMapG[phase].mat[comp]       = getIntMatMat(1);          // Allocate memory for time in phase
                        PhaseDynamicStateDependMapG[phase].mat[comp]      = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                        if (nuG[phase]>0)   // If there are 1 or more control components in phase
                        {
                            PhaseDynamicControlDependMapG[phase].mat[comp]    = getIntMatMat(nuG[phase]); // Allocate memory for number of control components in phase
                        }
                        
                        if (nsG>0)  // If there are 1 or more static parameter in phase
                        {
                            PhaseDynamicStaticDependMapG[phase].mat[comp]     = getIntMatMat(nsG);    // Allocate memory for number of state parameters in phase
                        }
                    }
                }
                
                // Allocate memory for parameter to control dependencies mapping
                if (nuG[phase]>0)   // If there are 1 or more control components in phase
                {
                    ControlPhaseDependenciesG[phase] = getIntMatMat(nuG[phase]);    // Allocate memory for number of control components in phase;
                    for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                    {
                        ControlPhaseDependenciesG[phase].mat[comp] = getIntMat(nppG[phase]); // Allocate memory for number of phase parameters in phase
                    }
                }
                
                // Allocate memory for parameter to static parameter dependencies mapping
                if (nsG>0)  // If there are 1 or more static parameter in problem
                {
                    StaticPhaseDependenciesG[phase] = getIntMatMat(nsG);    // Allocate memory for number of static parameters in problem
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        StaticPhaseDependenciesG[phase].mat[comp] = getIntMat(nppG[phase]);  // Allocate memory for number of phase parameters in phase
                    }
                }
                
                // Allocate memory for parameter to time dependencies mapping
                TimePhaseDependenciesG[phase] = getIntMatMat(1);    // Allocate memory for time in phase;
                TimePhaseDependenciesG[phase].mat[0] = getIntMat(nppG[phase]);   // Allocate memory for number of phase parameters in phase
                
                // Allocate memory for parameter to path function dependencies mapping
                if (ncG[phase]>0)   // If there are 1 or more path components in phase
                {
                    PathPhaseDependenciesG[phase] = getIntMatMat(ncG[phase]);   // Allocate memory for number of path components in phase;
                    for (int comp=0; comp<ncG[phase]; comp++)   // For each path component in phase
                    {
                        PathPhaseDependenciesG[phase].mat[comp] = getIntMat(nppG[phase]);    // Allocate memory for number of phase parameters in phase
                    }
                    
                    PhasePathTimeDependMapG[phase]      = getIntMatMatMat(ncG[phase]);  // Allocate memory for number of path functions in phase;
                    PhasePathStateDependMapG[phase]     = getIntMatMatMat(ncG[phase]);  // Allocate memory for number of path functions in phase;
                    PhasePathControlDependMapG[phase]   = getIntMatMatMat(ncG[phase]);  // Allocate memory for number of path functions in phase;
                    PhasePathStaticDependMapG[phase]    = getIntMatMatMat(ncG[phase]);  // Allocate memory for number of path functions in phase;
                    
                    for (int comp=0; comp<ncG[phase]; comp++)   // For each path function in phase
                    {
                        PhasePathTimeDependMapG[phase].mat[comp] = getIntMatMat(1);   // Allocate memory for time in phase
                        
                        if (nxG[phase]>0)   // If there are 1 or more state components in phase
                        {
                            PhasePathStateDependMapG[phase].mat[comp] = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                        }
                        
                        if (nuG[phase]>0)   // If there are 1 or more control components in phase
                        {
                            PhasePathControlDependMapG[phase].mat[comp] = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
                        }
                        
                        if (nsG>0)  // If there are 1 or more static parameter in phase
                        {
                            PhasePathStaticDependMapG[phase].mat[comp]  = getIntMatMat(nsG);  // Allocate memory for number of static parameters in phase
                        }
                    }
                }
                
                // Allocate memory for parameter to lagrange function dependencies mapping
                if (nqG[phase]>0)   // If there are 1 or more integral components in phase
                {
                    LagrangePhaseDependenciesG[phase] = getIntMatMat(nqG[phase]);   // Allocate memory for number of integral components in phase;
                    for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                    {
                        LagrangePhaseDependenciesG[phase].mat[comp] = getIntMat(nppG[phase]);    // Allocate memory for number of phase parameters in phase
                    }
                    
                    PhaseLagrangeTimeDependMapG[phase]      = getIntMatMatMat(nqG[phase]);  // Allocate memory for number of lagrange functions in phase;
                    PhaseLagrangeStateDependMapG[phase]     = getIntMatMatMat(nqG[phase]);  // Allocate memory for number of lagrange functions in phase;
                    PhaseLagrangeControlDependMapG[phase]   = getIntMatMatMat(nqG[phase]);  // Allocate memory for number of lagrange functions in phase;
                    PhaseLagrangeStaticDependMapG[phase]    = getIntMatMatMat(nqG[phase]);  // Allocate memory for number of lagrange functions in phase;
                    
                    for (int comp=0; comp<nqG[phase]; comp++)   // For each lagrange function in phase
                    {
                        PhaseLagrangeTimeDependMapG[phase].mat[comp] = getIntMatMat(1);   // Allocate memory for time in phase
                        
                        if (nxG[phase]>0)   // If there are 1 or more state components in phase
                        {
                            PhaseLagrangeStateDependMapG[phase].mat[comp] = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                        }
                        
                        if (nuG[phase]>0)   // If there are 1 or more control components in phase
                        {
                            PhaseLagrangeControlDependMapG[phase].mat[comp] = getIntMatMat(nuG[phase]);   // Allocate memory for number of control components in phase
                        }
                        
                        if (nsG>0)  // If there are 1 or more static parameter in phase
                        {
                            PhaseLagrangeStaticDependMapG[phase].mat[comp] = getIntMatMat(nsG);   // Allocate memory for number of static parameters in phase
                        }
                    }
                }
            }
            
            
            // Allocate memory for parameter to state and dynamic function dependencies mapping
            if (nxG[phase]>0)   // If there are 1 or more state components in phase
            {
                DynamicTimeDependMapG.mat[phase]      = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                DynamicStateDependMapG.mat[phase]     = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                DynamicControlDependMapG.mat[phase]   = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                DynamicStaticDependMapG.mat[phase]    = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    DynamicTimeDependMapG.mat[phase].mat[comp]     = getIntMat(1);             // Allocate memory for time in phase
                    DynamicStateDependMapG.mat[phase].mat[comp]    = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase
                    
                    if (nuG[phase]>0)   // If there are 1 or more control components in phase
                    {
                        DynamicControlDependMapG.mat[phase].mat[comp]  = getIntMat(nuG[phase]);    // Allocate memory for number of control components in phase
                    }
                    
                    if (nsG>0)  // If there are 1 or more static parameter in phase
                    {
                        DynamicStaticDependMapG.mat[phase].mat[comp]   = getIntMat(nsG);       // Allocate memory for number of state parameters in phase
                    }
                }
            }
            
            // Allocate memory for parameter to path function dependencies mapping
            if (ncG[phase]>0)   // If there are 1 or more path components in phase
            {
                PathTimeDependMapG.mat[phase]     = getIntMatMat(ncG[phase]); // Allocate memory for number of path functions in phase;
                PathStateDependMapG.mat[phase]    = getIntMatMat(ncG[phase]); // Allocate memory for number of path functions in phase;
                PathControlDependMapG.mat[phase]  = getIntMatMat(ncG[phase]); // Allocate memory for number of path functions in phase;
                PathStaticDependMapG.mat[phase]   = getIntMatMat(ncG[phase]); // Allocate memory for number of path functions in phase;
                
                for (int comp=0; comp<ncG[phase]; comp++)   // For each path function in phase
                {
                    PathTimeDependMapG.mat[phase].mat[comp] = getIntMat(1);    // Allocate memory for time in phase
                    
                    if (nxG[phase]>0)   // If there are 1 or more state components in phase
                    {
                        PathStateDependMapG.mat[phase].mat[comp] = getIntMat(nxG[phase]);  // Allocate memory for number of state components in phase
                    }
                    
                    if (nuG[phase]>0)   // If there are 1 or more control components in phase
                    {
                        PathControlDependMapG.mat[phase].mat[comp] = getIntMat(nuG[phase]);    // Allocate memory for number of control components in phase
                    }
                    
                    if (nsG>0)  // If there are 1 or more static parameter in phase
                    {
                        PathStaticDependMapG.mat[phase].mat[comp]  = getIntMat(nsG);   // Allocate memory for number of static parameters in phase
                    }
                }
            }
            
            // Allocate memory for parameter to lagrange function dependencies mapping
            if (nqG[phase]>0)   // If there are 1 or more integral components in phase
            {
                LagrangeTimeDependMapG.mat[phase]     = getIntMatMat(nqG[phase]); // Allocate memory for number of lagrange functions in phase;
                LagrangeStateDependMapG.mat[phase]    = getIntMatMat(nqG[phase]); // Allocate memory for number of lagrange functions in phase;
                LagrangeControlDependMapG.mat[phase]  = getIntMatMat(nqG[phase]); // Allocate memory for number of lagrange functions in phase;
                LagrangeStaticDependMapG.mat[phase]   = getIntMatMat(nqG[phase]); // Allocate memory for number of lagrange functions in phase;
                
                for (int comp=0; comp<nqG[phase]; comp++)   // For each lagrange function in phase
                {
                    LagrangeTimeDependMapG.mat[phase].mat[comp] = getIntMat(1);    // Allocate memory for time in phase
                    
                    if (nxG[phase]>0)   // If there are 1 or more state components in phase
                    {
                        LagrangeStateDependMapG.mat[phase].mat[comp] = getIntMat(nxG[phase]);  // Allocate memory for number of state components in phase
                    }
                    
                    if (nuG[phase]>0)   // If there are 1 or more control components in phase
                    {
                        LagrangeControlDependMapG.mat[phase].mat[comp] = getIntMat(nuG[phase]);    // Allocate memory for number of control components in phase
                    }
                    
                    if (nsG>0)  // If there are 1 or more static parameter in phase
                    {
                        LagrangeStaticDependMapG.mat[phase].mat[comp]= getIntMat(nsG); // Allocate memory for number of static parameters in phase
                    }
                }
            }
        }
        
        PhaseParametersInitFlagG = 0;   // Indicate phase parameters have been initialized
    }
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        phaseparametersG.parametersStruct[phase]     = getParametersStruct(Nt[phase]+1);
        phaseparametersBCG.parametersStruct[phase]   = getParametersStructBC(Nt[phase]+1);
        phaseparametersHDG.parametersStruct[phase]   = getParametersStructHD(Nt[phase]+1);
        phaseparametersCDG.parametersStruct[phase]   = getParametersStruct(Nt[phase]+1);
        
        if (nppG[phase]>0)  // If phase parameters used in phase
        {
            // Allocate memory for parameters in phase
            for (int pt=0; pt<Nt[phase]+1; pt++)    // For each discretization point in phase
            {
                phaseparametersG.parametersStruct[phase].parametersMat[pt]    = getDoubleMat(nppG[phase]);    // Allocate memory for number of phase parameters in phase
                phaseparametersBCG.parametersStruct[phase].parametersMat[pt]  = getBicomplexMat(nppG[phase]); // Allocate memory for number of phase parameters in phase
                phaseparametersHDG.parametersStruct[phase].parametersMat[pt]  = getHyperDualMat(nppG[phase]); // Allocate memory for number of phase parameters in phase
                phaseparametersCDG.parametersStruct[phase].parametersMat[pt]  = getDoubleMat(nppG[phase]);    // Allocate memory for number of phase parameters in phase
            }
        }
    }
}

void InitEndpointParameters(void)   // Initialize endpoint parameters used for computations in objective/event functions of problem
{
    //    printf("\nInitializing Endpoint Parameters");
    
    if (EndpointParametersInitFlagG)    // If endpoint parameters need to be initialized
    {
        int nd = 0, ne = 0;
        if (DurationFlagG)
        {
            nd = PG;
        }
        if (ContinuityFlagG)
        {
            ne = neG;
        }
        
        // Allocate memory for each phase in problem
        InitStateEndpointDependenciesG      = new intMatMat[PG];
        FinalStateEndpointDependenciesG     = new intMatMat[PG];
        IntegralEndpointDependenciesG       = new intMatMat[PG];
        InitTimeEndpointDependenciesG       = new intMatMat[PG];
        FinalTimeEndpointDependenciesG      = new intMatMat[PG];
        EndpointEventInitStateDependMapG    = new intMatMatMat[PG];
        EndpointEventFinalStateDependMapG   = new intMatMatMat[PG];
        EndpointEventIntegralDependMapG     = new intMatMatMat[PG];
        EndpointEventInitTimeDependMapG     = new intMatMatMat[PG];
        EndpointEventFinalTimeDependMapG    = new intMatMatMat[PG];
        
        ObjectiveInitStateDependMapG    = getIntMatMat(PG); // Allocate memory for number of phases in problem
        ObjectiveFinalStateDependMapG   = getIntMatMat(PG); // Allocate memory for number of phases in problem
        ObjectiveIntegralDependMapG     = getIntMatMat(PG); // Allocate memory for number of phases in problem
        ObjectiveInitTimeDependMapG     = getIntMatMat(PG); // Allocate memory for number of phases in problem
        ObjectiveFinalTimeDependMapG    = getIntMatMat(PG); // Allocate memory for number of phases in problem
        ObjectiveStaticDependMapG       = getIntMatMat(1); // Allocate memory for number of phases in problem
        
        EventInitStateDependMapG    = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
        EventFinalStateDependMapG   = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
        EventIntegralDependMapG     = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
        EventInitTimeDependMapG     = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
        EventFinalTimeDependMapG    = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            // Allocate memory for parameter to state dependencies mapping
            if (nxG[phase]>0)   // If there are 1 or more state components in phase
            {
                ObjectiveInitStateDependMapG.mat[phase]  = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase;
                ObjectiveFinalStateDependMapG.mat[phase] = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase;
            }
            
            // Allocate memory for parameter to state dependencies mapping
            if (nqG[phase]>0)   // If there are 1 or more state components in phase
            {
                ObjectiveIntegralDependMapG.mat[phase] = getIntMat(nqG[phase]);  // Allocate memory for number of integral components in phase;
            }
            
            ObjectiveInitTimeDependMapG.mat[phase]   = getIntMat(1); // Allocate memory for initial time in phase;
            ObjectiveFinalTimeDependMapG.mat[phase]  = getIntMat(1); // Allocate memory for final time in phase;
            
        }
        
        if (nsG>0)
        {
            ObjectiveStaticDependMapG.mat[0] = getIntMat(nsG);   // Allocate memory for number of static parameters in problem;
        }
        
        if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
        {
            EventStaticDependMapG = getIntMatMat(nbG+nd+ne);   // Allocate memory for number of event constraints in problem
            
            for (int event=0; event<(nbG+nd+ne); event++)  // For each event constraint in problem
            {
                if (nsG)    // If there is one or more static parameters in problem
                {
                    EventStaticDependMapG.mat[event] = getIntMat(nsG);   // Allocate memory for number of static parameters in phase
                }
            }
            
            for (int phase=0; phase<PG; phase++)    // For each phase in problem
            {
                EventInitStateDependMapG.mat[phase]   = getIntMatMat(nbG+nd+ne); // Allocate memory for number of event constraints in problem
                EventFinalStateDependMapG.mat[phase]  = getIntMatMat(nbG+nd+ne); // Allocate memory for number of event constraints in problem
                EventIntegralDependMapG.mat[phase]    = getIntMatMat(nbG+nd+ne); // Allocate memory for number of event constraints in problem
                EventInitTimeDependMapG.mat[phase]    = getIntMatMat(nbG+nd+ne); // Allocate memory for number of event constraints in problem
                EventFinalTimeDependMapG.mat[phase]   = getIntMatMat(nbG+nd+ne); // Allocate memory for number of event constraints in problem
                
                for (int event=0; event<(nbG+nd+ne); event++)  // For each event constraint in problem
                {
                    if (nxG[phase]) // If there is one or more state components in phase
                    {
                        EventInitStateDependMapG.mat[phase].mat[event]     = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase
                        EventFinalStateDependMapG.mat[phase].mat[event]    = getIntMat(nxG[phase]);    // Allocate memory for number of state components in phase
                    }
                    
                    if (nqG[phase]) // If there is one or more integral components in phase
                    {
                        EventIntegralDependMapG.mat[phase].mat[event] = getIntMat(nqG[phase]); // Allocate memory for number of integral components in phase
                    }
                    
                    EventInitTimeDependMapG.mat[phase].mat[event]  = getIntMat(1); // Allocate memory for initial time in phase
                    EventFinalTimeDependMapG.mat[phase].mat[event] = getIntMat(1); // Allocate memory for final time in phase
                }
                
            }
        }
        
        if (nepG>0)
        {
            endpointparametersG             = getDoubleMat(nepG);       // Allocate memory for number of endpoint parameters in problem
            endpointparametersBCG           = getBicomplexMat(nepG);    // Allocate memory for number of endpoint parameters in problem
            endpointparametersHDG           = getHyperDualMat(nepG);    // Allocate memory for number of endpoint parameters in problem
            endpointparametersCDG           = getDoubleMat(nepG);       // Allocate memory for number of endpoint parameters in problem
            ObjectiveEndpointDependenciesG  = getIntMatMat(1);          // Allocate memory for number of endpoint parameters in problem
            EndpointParameterDependenciesG  = getIntMatMat(nepG);       // Allocate memory for number of endpoint parameters in problem;
            
            for (int param=0; param<(nepG-1); param++)  // For each endpoint parameter in problem except last
            {
                EndpointParameterDependenciesG.mat[param] = getIntMat(nepG-(1+param));   // Allocate memory for number of possible endpoint parameter dependencies
            }
            
            EndpointObjectiveInitStateDependMapG    = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
            EndpointObjectiveFinalStateDependMapG   = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
            EndpointObjectiveIntegralDependMapG     = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
            EndpointObjectiveInitTimeDependMapG     = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
            EndpointObjectiveFinalTimeDependMapG    = getIntMatMatMat(PG);  // Allocate memory for number of phases in problem
            EndpointObjectiveStaticDependMapG       = getIntMatMatMat(1);  // Allocate memory for number of phases in problem
            
            for (int phase=0; phase<PG; phase++)    // For each phase in problem
            {
                // Allocate memory for parameter to state dependencies mapping
                if (nxG[phase]>0)   // If there are 1 or more state components in phase
                {
                    InitStateEndpointDependenciesG[phase]   = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase;
                    FinalStateEndpointDependenciesG[phase]  = getIntMatMat(nxG[phase]);   // Allocate memory for number of state components in phase;
                    for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                    {
                        InitStateEndpointDependenciesG[phase].mat[comp]  = getIntMat(nepG);  // Allocate memory for number of endpoint parameters in problem
                        FinalStateEndpointDependenciesG[phase].mat[comp] = getIntMat(nepG);  // Allocate memory for number of endpoint parameters in problem
                    }
                    
                    EndpointObjectiveInitStateDependMapG.mat[phase]   = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase;
                    EndpointObjectiveFinalStateDependMapG.mat[phase]  = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase;
                }
                
                // Allocate memory for parameter to state dependencies mapping
                if (nqG[phase]>0)   // If there are 1 or more state components in phase
                {
                    IntegralEndpointDependenciesG[phase] = getIntMatMat(nqG[phase]);    // Allocate memory for number of state components in phase;
                    for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                    {
                        IntegralEndpointDependenciesG[phase].mat[comp] = getIntMat(nepG);    // Allocate memory for number of endpoint parameters in problem
                    }
                    
                    EndpointObjectiveIntegralDependMapG.mat[phase]   = getIntMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase;
                }
                
                // Allocate memory for parameter to time dependencies mapping
                InitTimeEndpointDependenciesG[phase]    = getIntMatMat(1);  // Allocate memory for time in phase;
                FinalTimeEndpointDependenciesG[phase]   = getIntMatMat(1);  // Allocate memory for time in phase;
                InitTimeEndpointDependenciesG[phase].mat[0]  = getIntMat(nepG);  // Allocate memory for number of endpoint parameters in problem
                FinalTimeEndpointDependenciesG[phase].mat[0] = getIntMat(nepG);  // Allocate memory for number of endpoint parameters in problem
                
                EndpointObjectiveInitTimeDependMapG.mat[phase]    = getIntMatMat(1);  // Allocate memory for initial time in phase;
                EndpointObjectiveFinalTimeDependMapG.mat[phase]   = getIntMatMat(1);  // Allocate memory for final time in phase;

            }
            if (nsG>0)
            {
                EndpointObjectiveStaticDependMapG.mat[0] = getIntMatMat(nsG); // Allocate memory for number of static parameters in problem;
            }
            
            // Allocate memory for parameter to objective function dependencies mapping
            ObjectiveEndpointDependenciesG.mat[0] = getIntMat(nepG); // Allocate memory for number of endpoint parameters in problem
            
            // Allocate memory for parameter to static parameter dependencies mapping
            if (nsG>0)  // If there are 1 or more static parameters in phase
            {
                StaticEndpointDependenciesG = getIntMatMat(nsG);    // Allocate memory for number of static parameters in phase;
                for (int comp=0; comp<nsG; comp++)  // For each static parameters in problem
                {
                    StaticEndpointDependenciesG.mat[comp] = getIntMat(nepG); // Allocate memory for number of endpoint parameters in problem
                }
            }
            
            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
            {
                EventEndpointDependenciesG  = getIntMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                EndpointEventStaticDependMapG       = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem

                for (int event=0; event<(nbG+nd+ne); event++)  // For each event constraint in problem
                {
                    // Allocate memory for parameter to event function dependencies mapping
                    EventEndpointDependenciesG.mat[event] = getIntMat(nepG); // Allocate memory for number of endpoint parameters in problem
                    
                    if (nsG)    // If there is one or more static parameters in problem
                    {
                        EndpointEventStaticDependMapG.mat[event] = getIntMatMat(nsG); // Allocate memory for number of static parameters in phase
                    }
                }
                
                for (int phase=0; phase<PG; phase++)    // For each phase in problem
                {
                    EndpointEventInitStateDependMapG[phase]     = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                    EndpointEventFinalStateDependMapG[phase]    = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                    EndpointEventIntegralDependMapG[phase]      = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                    EndpointEventInitTimeDependMapG[phase]      = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                    EndpointEventFinalTimeDependMapG[phase]     = getIntMatMatMat(nbG+nd+ne);  // Allocate memory for number of event constraints in problem
                    
                    for (int event=0; event<(nbG+nd+ne); event++)  // For each event constraint in problem
                    {
                        if (nxG[phase]) // If there is one or more state components in phase
                        {
                            EndpointEventInitStateDependMapG[phase].mat[event]    = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                            EndpointEventFinalStateDependMapG[phase].mat[event]   = getIntMatMat(nxG[phase]); // Allocate memory for number of state components in phase
                        }
                        
                        if (nqG[phase]) // If there is one or more integral components in phase
                        {
                            EndpointEventIntegralDependMapG[phase].mat[event]    = getIntMatMat(nqG[phase]);  // Allocate memory for number of integral components in phase
                        }
                        
                        EndpointEventInitTimeDependMapG[phase].mat[event]     = getIntMatMat(1);  // Allocate memory for initial time in phase
                        EndpointEventFinalTimeDependMapG[phase].mat[event]    = getIntMatMat(1);  // Allocate memory for final time in phase
                    }
                    
                }
            }
        }
        
        EndpointParametersInitFlagG = 0;    // Indicate endpoint parameters have been initialized
    }
}


void SetParametersBC(void)  // Set Bicomplex values of parameters used in problem
{
    SetPhaseParametersBC();      // Set values of global phaseparametersBCG variables using global phaseparametersG
    SetEndpointParametersBC();   // Set values of global endpointparametersBCG variables using global
}

void SetPhaseParametersBC(void) // Set values of global phaseparametersBCG variables using global phaseparametersG
{
//    printf("\nSetting Phase Parameters BC");
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nppG[phase])    // If phase parameters exist in problem
        {
            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
            {
                for (int point=0; point<(NtG[phase]+1); point++)    // For each discretization point in phase
                {
                    phaseparametersBCG.parametersStruct[phase].parametersMat[point].val[param] = phaseparametersG.parametersStruct[phase].parametersMat[point].val[param];    // Extract value of phase parameter at point from phaseparametersG
                }
            }
        }
    }
}

void SetEndpointParametersBC(void) // Set values of global endpointparametersBCG variables using global endpointparametersG
{
//    printf("\nSetting Endpoint Parameters BC");
    
    if (nepG)   // If endpoint parameters exist in problem
    {
        for (int param=0; param<nepG; param++)  // For each endpoint parameter
        {
            endpointparametersBCG.val[param] = endpointparametersG.val[param]; // Extract value of endpoint parameter at point from endpointparametersG
        }
    }
}

void SetParametersHD(void)  // Set Bicomplex values of parameters used in problem
{
    SetPhaseParametersHD();      // Set values of global phaseparametersHDG variables using global phaseparametersG
    SetEndpointParametersHD();   // Set values of global endpointparametersHDG variables using global
}

void SetPhaseParametersHD(void) // Set values of global phaseparametersHDG variables using global phaseparametersG
{
//    printf("\nSetting Phase Parameters HD");
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nppG[phase])    // If phase parameters exist in problem
        {
            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
            {
                for (int point=0; point<(NtG[phase]+1); point++)    // For each discretization point in phase
                {
                    phaseparametersHDG.parametersStruct[phase].parametersMat[point].val[param] = phaseparametersG.parametersStruct[phase].parametersMat[point].val[param];    // Extract value of phase parameter at point from phaseparametersG
                }
            }
        }
    }
}

void SetEndpointParametersHD(void) // Set values of global endpointparametersHDG variables using global endpointparametersG
{
//    printf("\nSetting Endpoint Parameters HD");
    
    if (nepG)   // If endpoint parameters exist in problem
    {
        for (int param=0; param<nepG; param++)  // For each endpoint parameter
        {
            endpointparametersHDG.val[param] = endpointparametersG.val[param]; // Extract value of endpoint parameter at point from endpointparametersG
        }
    }
}

void SetParametersCD(void)  // Set double values of parameters used in problem
{
    SetPhaseParametersCD();     // Set values of global phaseparametersCDG variables using global phaseparametersG
    SetEndpointParametersCD();  // Set values of global endpointparametersCDG variables using global endpointparametersG
}

void SetPhaseParametersCD(void) // Set values of global phaseparametersCDG variables using global phaseparametersG
{
//    printf("\nSetting Phase Parameters CD");
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nppG[phase])    // If phase parameters exist in problem
        {
            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
            {
                for (int point=0; point<(NtG[phase]+1); point++)    // For each discretization point in phase
                {
                    phaseparametersCDG.parametersStruct[phase].parametersMat[point].val[param] = phaseparametersG.parametersStruct[phase].parametersMat[point].val[param];    // Extract value of phase parameter at point from phaseparametersG
                }
            }
        }
    }
}

void SetEndpointParametersCD(void) // Set values of global endpointparametersCDG variables using global endpointparametersG
{
//    printf("\nSetting Endpoint Parameters CD");
    
    if (nepG)   // If endpoint parameters exist in problem
    {
        for (int param=0; param<nepG; param++)  // For each endpoint parameter
        {
            endpointparametersCDG.val[param] = endpointparametersG.val[param];    // Extract value of endpoint parameter at point from endpointparametersG
        }
    }
}
// START HERE (Change inputs)
void ComputeParameters(systemInfo& systeminfo, ParametersStructMat& phaseparametersStructMat, doubleMat& endpointparameters)  // Compute parameters used for computations in each functions of problem
{
    ComputePhaseParameters(systeminfo,phaseparametersStructMat);     // Compute phase parameters used for computations in each phase dynamics/path/lagrange functions of problem
    ComputeEndpointParameters(systeminfo,endpointparameters);   // Compute endpoint parameters used for computations in objective/event functions of problem
}

void ComputePhaseParameters(systemInfo& systeminfo, ParametersStructMat& phaseparametersStructMat)  // Compute phase parameters used for computations in each phase dynamics/path/lagrange functions of problem
{
    for (int phase=0; phase<phaseparametersStructMat.Len; phase++)  // For each phase in problem
    {
        if (phaseparametersStructMat.parametersStruct[phase].parametersMat[0].Len)  // If phase parameters exist in phase of problem
        {
            for (int param=0; param<phaseparametersStructMat.parametersStruct[phase].parametersMat[0].Len; param++) // For each phase parameter in phase
            {
                phase_parameters_func(PhaseSwitchG.val[phase],param,systeminfo.phaseinfo[phase],systeminfo.s,phaseparametersStructMat.parametersStruct[phase]);
            }
        }
    }
}

void ComputeEndpointParameters(systemInfo& systeminfo, doubleMat& endpointparameters) // Compute endpoint parameters used for computations in objective/event functions of problem
{
    for (int param=0; param<endpointparameters.Len; param++)    // For each endpoint parameter
    {
        endpoint_parameters_func(param,systeminfo.phaseinfo,systeminfo.s,endpointparameters.val);   // Compute and set endpoint parameter
    }
}

void DetermineParameterDependencies(void)   // Determine dependencies of phase and endpoint parameters wrt to variables and functions
{
    
    DeterminePhaseParameterDependencies();      // Determine dependencies of phase parameters
    
    DetermineEndpointParameterDependencies();   // Determine dependencies of endpoint parameters
    
    DetermineParametersMapping();
    
    ParameterDependenciesFlagG = 1;             // Indicate parameter dependencies have been taken
}

void DeterminePhaseParameterDependencies(void)  // Determine dependies of phase functions (dynamic/path/lagrange) and phase variables (x,u,t) wrt phase parameters
{
    HyperDual value;        // Flag for bicomplex computations
//    HyperDual value;        // Flag for HyperDual computations
    double dependval=0;     // Flag for dependencies of phase function on parameter
    int numtrials=4;        // Number of trials used to test dependencies
    intMat ParamParamMat;   // Holder for parameter dependencies
//    doubleMat dubMat(1);
    HyperDualMat HDMat(1);
//    HyperDualMat HDMat(1);
    ParametersStructHDMat parametersStructHDMat(PG);
//    ParametersStructHDMat parametersStructHDMat(PG);
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        parametersStructHDMat.parametersStruct[phase] = getParametersStructHD(1);
        parametersStructHDMat.parametersStruct[phase].parametersMat[0] = getHyperDualMat(nppG[phase]);
//        parametersStructHDMat.parametersStruct[phase] = getParametersStructHD(1);
//        parametersStructHDMat.parametersStruct[phase].parametersMat[0] = getHyperDualMat(nppG[phase]);
    }
    
    for (int trial=0; trial<numtrials; trial++) // For number of trials
    {
        switch (trial)  // Depending on trial number
        {
            case 0: // First trial
                // Leave as initial guess values
                break;
                
            case 1: // Second trial
                for (int phase=0; phase<PG; phase++)    // For each phase in problem
                {
                    if (nxG[phase]>0)   // If one or more state component in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 0.1*(nlpbG.PB[phase].xU[comp]-nlpbG.PB[phase].xL[comp]) + nlpbG.PB[phase].xL[comp];   // Set state component to be larger than minimum state component value plus 10% of difference between maximum and minimum state component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 1e-6;
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 0.1*(nlpbG.PB[phase].uU[comp]-nlpbG.PB[phase].uL[comp]) + nlpbG.PB[phase].uL[comp];   // Set control component to be larger than minimum control component value plus 10% of difference between maximum and minimum control component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 1e-6;
                            }
                        }
                    }
                    
                    sysinfoHDG.phaseinfo[phase].ptInfo[0].t = 0.1*(nlpbG.PB[phase].tfU - nlpbG.PB[phase].tfL) + nlpbG.PB[phase].tfL; // Set time to be larger than minimum final time component value plus 10% of difference between maximum and minimum final time value
                }
                
                if (nsG>0)  // If one or more static parameter in problem
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        sysinfoHDG.s[comp] = 0.1*(nlpbG.WB.sU[comp]-nlpbG.WB.sL[comp]) + nlpbG.WB.sL[comp]; // Set static parameter to be larger than minimum static parameter value plus 10% of difference between maximum and minimum control component value
                        if (sysinfoHDG.s[comp]==0)  // Check to make sure input is nonzero
                        {
                            sysinfoHDG.s[comp] = 1e-6;
                        }
                    }
                }
                break;
                
            case 2: // Third trial
                for (int phase=0; phase<PG; phase++)    // For each phase in problem
                {
                    if (nxG[phase]>0)   // If one or more state component in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 0.9*(nlpbG.PB[phase].xU[comp]-nlpbG.PB[phase].xL[comp]) + nlpbG.PB[phase].xL[comp];   // Set state component to be larger than minimum state component value plus 90% of difference between maximum and minimum state component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 1e-6;
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 0.9*(nlpbG.PB[phase].uU[comp]-nlpbG.PB[phase].uL[comp]) + nlpbG.PB[phase].uL[comp];   // Set control component to be larger than minimum control component value plus 90% of difference between maximum and minimum control component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 1e-6;
                            }
                        }
                    }
                    
                    sysinfoHDG.phaseinfo[phase].ptInfo[0].t = 0.9*(nlpbG.PB[phase].tfU - nlpbG.PB[phase].tfL) + nlpbG.PB[phase].tfL;    // Set time to be larger than minimum final time component value plus 90% of difference between maximum and minimum final time value
                }
                
                if (nsG>0)  // If one or more static parameter in problem
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        sysinfoHDG.s[comp] = 0.9*(nlpbG.WB.sU[comp]-nlpbG.WB.sL[comp]) + nlpbG.WB.sL[comp]; // Set static parameter to be larger than minimum static parameter value plus 90% of difference between maximum and minimum control component value
                        if (sysinfoHDG.s[comp]==0)  // Check to make sure input is nonzero
                        {
                            sysinfoHDG.s[comp] = 1e-6;
                        }
                    }
                }
                break;
                
            case 3: // Fourth trial
                for (int phase=0; phase<PG; phase++)    // For each phase in problem
                {
                    if (nxG[phase]>0)   // If one or more state component in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 0.5*(nlpbG.PB[phase].xU[comp]-nlpbG.PB[phase].xL[comp]) + nlpbG.PB[phase].xL[comp];   // Set state component to be larger than minimum state component value plus 50% of difference between maximum and minimum state component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp] = 1e-6;
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                        {
                            sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 0.5*(nlpbG.PB[phase].uU[comp]-nlpbG.PB[phase].uL[comp]) + nlpbG.PB[phase].uL[comp];   // Set control component to be larger than minimum control component value plus 50% of difference between maximum and minimum control component value
                            if (sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp]==0)   // Check to make sure input is nonzero
                            {
                                sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp] = 1e-6;
                            }
                        }
                    }
                    
                    sysinfoHDG.phaseinfo[phase].ptInfo[0].t = 0.5*(nlpbG.PB[phase].tfU - nlpbG.PB[phase].tfL) + nlpbG.PB[phase].tfL;    // Set time to be larger than minimum final time component value plus 50% of difference between maximum and minimum final time value
                }
                
                if (nsG>0)  // If one or more static parameter in problem
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        sysinfoHDG.s[comp] = 0.5*(nlpbG.WB.sU[comp]-nlpbG.WB.sL[comp]) + nlpbG.WB.sL[comp]; // Set static parameter to be larger than minimum static parameter value plus 50% of difference between maximum and minimum control component value
                        if (sysinfoHDG.s[comp]==0)  // Check to make sure input is nonzero
                        {
                            sysinfoHDG.s[comp] = 1e-6;
                        }
                    }
                }
                break;
                
            default:
                break;
        }
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            if (nppG[phase]>0)  // If one or more phase parameters
            {
                for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                {
//                    printf("\nHERE for phase %d param %d",phase+1,param+1);
                    
                    phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);    // Compute and set phase parameter param at first point
//                    printf("\nHERE for phase %d param %d",phase+1,param+1);
                    parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1    = stepeSizeG;   // Perturb current phase parameter param
                    for (int param2=(param+1); param2<nppG[phase]; param2++)    // For each phase parameter after current parameter param
                    {
//                        printf("\nHERE for phase %d param %d param2 %d",phase+1,param+1,param2+1);
                        phase_parameters_func(PhaseSwitchG.val[phase],param2,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);   // Compute and set phase parameter param2 at first point
//                        printf("\nHERE for phase %d param %d param2 %d",phase+1,param+1,param2+1);
                        
                        if ((parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param2].E1/stepeSizeG)==0)   // If partial is zero
                        {
                            // Do nothing
                        }
                        else    // Partial is nonzero
                        {
                            PhaseParameterDependenciesG[phase].mat[param].val[param2-(param+1)] = 1; // Indicate dependency between phase parameter param and phase parameter param2
                        }
                    }
                    parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1 = 0;    // Unperturb current phase parameter param
                }
                
                if (nxG[phase]>0)   // If one or more state components in phase
                {
                    for (int comp=0; comp<nxG[phase]; comp++)   // If one or more state components in phase
                    {
                        sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp].E1 = stepeSizeG;  // Perturb state component
                        for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                        {
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
                            phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);    // Compute and set phase parameter param at first point
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
//                            phaseparametersHDG.parametersStruct[phase].parametersMat[param].val[0] = HDMat.val[0]; // Set current phase parameter param
                            if ((parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1/stepeSizeG)==0)    // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                StatePhaseDependenciesG[phase].mat[comp].val[param] = 1; // Indicate dependency between state component and phase parameter
                                for (int param2=(param+1); param2<nppG[phase]; param2++)    // For each phase parameter after current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param].val[param2-(param+1)]) // If phase parameter param2 is dependent on current param
                                    {
                                        StatePhaseDependenciesG[phase].mat[comp].val[param2] = 1;    //  Indicate dependency between state component and phase parameter param2
                                    }
                                }
                            }
                        }
                        sysinfoHDG.phaseinfo[phase].ptInfo[0].x[comp].E1 = 0;   // Unperturb state component
                    }
                }
                
                if (nuG[phase]>0)   // If one or more control components in phase
                {
                    for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
                    {
                        sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp].E1 = stepeSizeG;  // Perturb control component
                        for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                        {
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
                            phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);    // Compute and set phase parameter param at first point
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
//                            phaseparametersHDG.parametersStruct[phase].parametersMat[param].val[0] = HDMat.val[0]; // Set current phase parameter param
                            if ((parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1/stepeSizeG)==0)    // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                ControlPhaseDependenciesG[phase].mat[comp].val[param] = 1;   // Indicate dependency between control component and phase parameter
                                for (int param2=(param+1); param2<nppG[phase]; param2++)    // For each phase parameter after current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param].val[param2-(param+1)]) // If phase parameter param2 is dependent on current param
                                    {
                                        ControlPhaseDependenciesG[phase].mat[comp].val[param2] = 1;  //  Indicate dependency between control component and phase parameter param2
                                    }
                                }
                            }
                        }
                        sysinfoHDG.phaseinfo[phase].ptInfo[0].u[comp].E1 = 0;   // Unperturb control component
                    }
                }
                
                if (nsG>0)  // If one or more static parameters in problem
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in phase
                    {
                        sysinfoHDG.s[comp].E1 = stepeSizeG; // Perturb static parameter
                        for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                        {
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
                            phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);    // Compute and set phase parameter param at first point
//                            printf("\nHERE for phase %d param %d",phase+1,param+1);
//                            phaseparametersHDG.parametersStruct[phase].parametersMat[param].val[0] = HDMat.val[0]; // Set current phase parameter param
                            if ((parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1/stepeSizeG)==0)    // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                StaticPhaseDependenciesG[phase].mat[comp].val[param] = 1;    // Indicate dependency between static parameter and phase parameter
                                for (int param2=(param+1); param2<nppG[phase]; param2++)    // For each phase parameter after current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param].val[param2-(param+1)]) // If phase parameter param2 is dependent on current param
                                    {
                                        StaticPhaseDependenciesG[phase].mat[comp].val[param2] = 1;   //  Indicate dependency between static parameter and phase parameter param2
                                    }
                                }
                            }
                        }
                        sysinfoHDG.s[comp].E1 = 0;  // Unperturb static parameter
                    }
                }
                
                sysinfoHDG.phaseinfo[phase].ptInfo[0].t.E1 = stepeSizeG;    // Perturb time
                for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                {
//                    printf("\nHERE for phase %d param %d",phase+1,param+1);
                    phase_parameters_func(PhaseSwitchG.val[phase],param,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);    // Compute and set phase parameter param at first point
//                    printf("\nHERE for phase %d param %d",phase+1,param+1);
//                    phaseparametersHDG.parametersStruct[phase].parametersMat[0].val[param] = HDMat.val[0]; // Set current phase parameter param
                    
                    if ((parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1/stepeSizeG)==0)    // If partial is zero
                    {
                        // Do nothing
                    }
                    else    // Partial is nonzero
                    {
                        TimePhaseDependenciesG[phase].mat[0].val[param] = 1; // Indicate dependency between time and phase parameter
                        for (int param2=(param+1); param2<nppG[phase]; param2++)    // For each phase parameter after current param
                        {
                            if (PhaseParameterDependenciesG[phase].mat[param].val[param2-(param+1)]) // If phase parameter param2 is dependent on current param
                            {
                                TimePhaseDependenciesG[phase].mat[0].val[param2] = 1;    //  Indicate dependency between time and phase parameter param2
                            }
                        }
                    }
                }
                sysinfoHDG.phaseinfo[phase].ptInfo[0].t.E1 = 0; // Unperturb time
                
                parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[0] = phaseparametersG.parametersStruct[phase].parametersMat[0].val[0]; // Set first phase parameter at first point to unperturbed value
                
                for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
                {
                    parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1 = stepeSizeG;   // Perturb current phase parameter
                    for (int param2=param+1; param2<nppG[phase]; param2++)  // For each phase parameter after current param
                    {
//                        printf("\nHERE for phase %d param %d param2 %d",phase+1,param+1,param2+1);
                        phase_parameters_func(PhaseSwitchG.val[phase],param2,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase]);   // Compute and set phase parameter param2 at first point
//                        printf("\nHERE for phase %d param %d param2 %d",phase+1,param+1,param2+1);
                    }
                    
                    if (nxG[phase]) // If one or more state component in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
//                            printf("\nHERE for phase %d param %d dyn %d",phase+1,param+1,comp+1);
                            dyn_func(PhaseSwitchG.val[phase],comp,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase],HDMat);  // Compute partial of comp dynamic function wrt phase parameter at first point
                            dependval = HDMat.val[0].E1;    // Extract partial value
//                            dependval = dyn_func_Grad(phase,comp,0);    // Compute partial of comp dynamic function wrt phase parameter at first point
//                            printf("\nHERE for phase %d param %d dyn %d",phase+1,param+1,comp+1);
                            if (dependval==0)   // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                DynamicPhaseDependenciesG[phase].mat[comp].val[param] = 1;   // Mark dependency of dynamic function on phase parameter param
                                for (int param2=0; param2<param; param2++)  // For each phase parameter before current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param2].val[param-(param2+1)])    // If phase parameter param is dependent on param2
                                    {
                                        DynamicPhaseDependenciesG[phase].mat[comp].val[param2] = 1;  // Mark dependency of dynamic function on phase parameter param2
                                    }
                                }
                            }
                        }
                    }
                    
                    if (ncG[phase]) // If one or more path constraint in phase
                    {
                        for (int comp=0; comp<ncG[phase]; comp++)   // For each path constraint in phase
                        {
//                            printf("\nHERE for phase %d param %d path %d",phase+1,param+1,comp+1);
                            
                            path_func(PhaseSwitchG.val[phase],comp,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase],HDMat); // Compute partial of comp path function wrt phase parameter at first point
                            dependval = HDMat.val[0].E1;    // Extract partial value
//                            dependval = path_func_Grad(phase,comp,0);   // Compute partial of comp path function wrt phase parameter at first point
//                            printf("\nHERE for phase %d param %d path %d",phase+1,param+1,comp+1);
                            if (dependval==0)   // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                PathPhaseDependenciesG[phase].mat[comp].val[param] = 1;  // Mark dependency of path function on phase parameter param
                                for (int param2=0; param2<param; param2++)  // For each phase parameter before current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param2].val[param-(param2+1)])    // If phase parameter param is dependent on param2
                                    {
                                        PathPhaseDependenciesG[phase].mat[comp].val[param2] = 1; // Mark dependency of path function on phase parameter param2
                                    }
                                }
                            }
                        }
                    }
                    
                    if (nqG[phase]) // If one or more integral constraint in phase
                    {
                        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral constraint in phase
                        {
                            lag_func(PhaseSwitchG.val[phase],comp,sysinfoHDG.phaseinfo[phase],sysinfoHDG.s,parametersStructHDMat.parametersStruct[phase],HDMat);  // Compute partial of comp lagrange function wrt phase parameter at first point
                            dependval = HDMat.val[0].E1;    // Extract partial value
//                            dependval = lag_func_Grad(phase,comp,0);    // Compute partial of comp lagrange function wrt phase parameter at first point
                            if (dependval==0)   // If partial is zero
                            {
                                // Do nothing
                            }
                            else    // Partial is nonzero
                            {
                                LagrangePhaseDependenciesG[phase].mat[comp].val[param] = 1;  // Mark dependency of path function on phase parameter param
                                for (int param2=0; param2<param; param2++)  // For each phase parameter before current param
                                {
                                    if (PhaseParameterDependenciesG[phase].mat[param2].val[param-(param2+1)])    // If phase parameter param is dependent on param2
                                    {
                                        LagrangePhaseDependenciesG[phase].mat[comp].val[param2] = 1; // Mark dependency of lagrange function on phase parameter param2
                                    }
                                }
                            }
                        }
                    }
                    
                    parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param].E1 = 0;    // Unperturb phase parameter
                    
                    if (param+1<nppG[phase])    // If there is another phase parameter after current param
                    {
                        parametersStructHDMat.parametersStruct[phase].parametersMat[0].val[param+1] = phaseparametersG.parametersStruct[phase].parametersMat[0].val[param+1]; // Set next phase parameter to be unperturbed value
                    }
                }
            }
        }
    }
}

void DetermineEndpointParameterDependencies(void)   // Determine dependies of endpoint functions (objective/event) and endpoint variables (x0,xf,q,t0,tf) wrt endpoint parameters
{
    double dependval=0; // Flag for dependencies of phase function on parameter
//    BicomplexMat endpointParameters(nepG);
    HyperDualMat endpointParameters(nepG);
    
    int nd = 0, ne = 0;
    if (DurationFlagG)
    {
        nd = PG;
    }
    if (ContinuityFlagG)
    {
        ne = neG;
    }
    
    if (nepG>0)   // If one or more endpoint parameter
    {
        for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
        {
            endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter param
            endpointParameters.val[param].E1 = stepeSizeG;   // Perturb current endpoint parameter param
//            printf(endpointparametersHDG.mat[param].val[0]);
            for (int param2=param+1; param2<nepG; param2++) // For each endpoint parameter after current endpoint param
            {
                endpoint_parameters_func(param2,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val); // Compute and set endpoint parameter param2
//                printf(endpointparametersHDG.mat[param2].val[0]);
                if ((endpointParameters.val[param2].E1/stepeSizeG)==0)   // If partial is zero
                {
                    // Do nothing
                }
                else    // Partial is nonzero
                {
                    EndpointParameterDependenciesG.mat[param].val[param2-(param+1)] = 1; // Indicate dependency between endpoint parameter param and endpoint parameter param2
                }
            }
            endpointParameters.val[param].E1 = 0;    // Unperturb current endpoint parameter param
        }
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            if (nxG[phase]>0)   // If one or more state component in phase
            {
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    sysinfoHDG.phaseinfo[phase].x0[comp].E1 = stepeSizeG; // Perturb initial state component
                    for (int param=0; param<nepG; param++)  // For each endpoint paramter
                    {
                        endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                        if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                        {
                            // Do nothing
                        }
                        else    // Partial is nonzero
                        {
                            InitStateEndpointDependenciesG[phase].mat[comp].val[param] = 1;  // Indicate dependency between initial state component and endpoint parameter
                            for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                            {
                                if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                                {
                                    InitStateEndpointDependenciesG[phase].mat[comp].val[param2] = 1; //  Indicate dependency between initial state and endpoint parameter param2
                                }
                            }
                        }
                    }
                    sysinfoHDG.phaseinfo[phase].x0[comp].E1 = 0;  // Unperturb initial state component
                }
                
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    sysinfoHDG.phaseinfo[phase].xf[comp].E1 = stepeSizeG; // Perturb final state component
                    for (int param=0; param<nepG; param++)  // For each endpoint paramter
                    {
                        endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                        if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                        {
                            // Do nothing
                        }
                        else    // Partial is nonzero
                        {
                            FinalStateEndpointDependenciesG[phase].mat[comp].val[param] = 1; // Indicate dependency between final state component and endpoint parameter
                            for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                            {
                                if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                                {
                                    FinalStateEndpointDependenciesG[phase].mat[comp].val[param2] = 1;    //  Indicate dependency between final state and endpoint parameter param2
                                }
                            }
                        }
                    }
                    sysinfoHDG.phaseinfo[phase].xf[comp].E1 = 0;  // Unperturb final state component
                }
            }
            
            if (nqG[phase]>0)   // If one or more integral component in phase
            {
                for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                {
                    sysinfoHDG.phaseinfo[phase].q[comp].E1 = stepeSizeG;  // Perturb integral component
                    for (int param=0; param<nepG; param++)  // For each endpoint paramter
                    {
                        endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                        if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                        {
                            // Do nothing
                        }
                        else    // Partial is nonzero
                        {
                            IntegralEndpointDependenciesG[phase].mat[comp].val[param] = 1;   // Indicate dependency between integral component and endpoint parameter
                            for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                            {
                                if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                                {
                                    IntegralEndpointDependenciesG[phase].mat[comp].val[param2] = 1;  //  Indicate dependency between integral comp and endpoint parameter param2
                                }
                            }
                        }
                    }
                    sysinfoHDG.phaseinfo[phase].q[comp].E1 = 0;   // Unperturb integral component
                }
            }
            
            sysinfoHDG.phaseinfo[phase].t0.E1 = stepeSizeG;   // Perturb initial time component
            for (int param=0; param<nepG; param++)  // For each endpoint paramter
            {
                endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                
                if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                {
                    // Do nothing
                }
                else    // Partial is nonzero
                {
                    InitTimeEndpointDependenciesG[phase].mat[0].val[param] = 1;  // Indicate dependency between initial time and endpoint parameter
                    for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                    {
                        if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                        {
                            InitTimeEndpointDependenciesG[phase].mat[0].val[param2] = 1; //  Indicate dependency between initial time and endpoint parameter param2
                        }
                    }
                }
            }
            sysinfoHDG.phaseinfo[phase].t0.E1 = 0;  // Unperturb initial time component
            
            sysinfoHDG.phaseinfo[phase].tf.E1 = stepeSizeG;   // Perturb final time component
            for (int param=0; param<nepG; param++)  // For each endpoint paramter
            {
                endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                {
                    // Do nothing
                }
                else    // Partial is nonzero
                {
                    FinalTimeEndpointDependenciesG[phase].mat[0].val[param] = 1; // Indicate dependency between final time and endpoint parameter
                    for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                    {
                        if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                        {
                            FinalTimeEndpointDependenciesG[phase].mat[0].val[param2] = 1;    //  Indicate dependency between final time and endpoint parameter param2
                        }
                    }
                }
            }
            sysinfoHDG.phaseinfo[phase].tf.E1 = 0;  // final final time component
        }
        
        if (nsG>0)  // If one or more static parameters in problem
        {
            for (int comp=0; comp<nsG; comp++)  // For each static parameter in phase
            {
                sysinfoHDG.s[comp].E1 = stepeSizeG; // Perturb static parameter
                for (int param=0; param<nepG; param++)  // For each endpoint paramter
                {
                    endpoint_parameters_func(param,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val);  // Compute and set endpoint parameter
                    if ((endpointParameters.val[param].E1/stepeSizeG)==0)    // If partial is zero
                    {
                        // Do nothing
                    }
                    else    // Partial is nonzero
                    {
                        StaticEndpointDependenciesG.mat[comp].val[param] = 1;    // Indicate dependency between static parameter and endpoint parameter
                        for (int param2=(param+1); param2<nepG; param2++)   // For each endpoint parameter after current param
                        {
                            if (EndpointParameterDependenciesG.mat[param].val[param2-(param+1)]) // If endpoint parameter param2 is dependent on current param
                            {
                                StaticEndpointDependenciesG.mat[comp].val[param2] = 1;   //  Indicate dependency between static parameter comp and endpoint parameter param2
                            }
                        }
                    }
                }
                sysinfoHDG.s[comp].E1 = 0; // Unperturb static parameter
            }
        }
        
        endpointParameters.val[0] = endpointparametersG.val[0]; // Set first endpoint parameter to unperturbed value
        
        for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
        {
            endpointParameters.val[param].E1 = stepeSizeG;   // Perturb endpoint parameter
            for (int param2=param+1; param2<nepG; param2++) // For each endpoint parameter after current param
            {
                endpoint_parameters_func(param2,sysinfoHDG.phaseinfo,sysinfoHDG.s,endpointParameters.val); // Compute and set endpoint parameter param2
            }
//            for (int phase=0; phase<PG; phase++)
//            {
                obj_func_Grad_HD(-1,-1,-1,endpointparametersG,sysinfoHDG,endpointParameters,dependval,stepeSizeG);   // Compute partial of objective function in phase wrt to endpoint parameter param
                if (dependval==0)   // If partial is zero
                {
                    // Do nothing
                }
                else    // Partial is nonzero
                {
                    ObjectiveEndpointDependenciesG.mat[0].val[param] = 1;    // Indicate dependency between objective function in phase and endpoint parameter param
                    for (int param2=0; param2<param; param2++)  // For each endpoint parameter before current param
                    {
                        if (EndpointParameterDependenciesG.mat[param2].val[param-(param2+1)])    // If endpoint parameter param is dependent on param2
                        {
                            ObjectiveEndpointDependenciesG.mat[0].val[param2] = 1;   // Mark dependency of objective function on endpoint parameter param2
                        }
                    }
                }
//            }
            if ((DurationFlagG)||(ContinuityFlagG)||(nbG))  // If event constraints enforced
            {
                for (int event=0; event<(nbG+nd+ne); event++)
                {
                    eve_func_Grad_HD(event,-1,-1,-1,endpointparametersG,sysinfoHDG,endpointParameters,dependval,stepeSizeG);    // Compute partial of event function wrt to endpoint parameter param
                    if (dependval==0)   // If partial is zero
                    {
                        // Do nothing
                    }
                    else    // Partial is nonzero
                    {
                        EventEndpointDependenciesG.mat[event].val[param] = 1;    // Indicate dependency between event function and endpoint parameter param
                        for (int param2=0; param2<param; param2++)  // For each endpoint parameter before current param
                        {
                            if (EndpointParameterDependenciesG.mat[param2].val[param-(param2+1)])    // If endpoint parameter param is dependent on param2
                            {
                                EventEndpointDependenciesG.mat[event].val[param2] = 1;   // Mark dependency of event function on endpoint parameter param2
                            }
                        }
                    }
                }
            }
            endpointParameters.val[param].E1 = 0;    // Unperturb endpoint parameter
            
            if (param+1<nepG)   // If there is another endpoint parameter after current param
            {
                endpointParameters.val[param+1] = endpointparametersG.val[param+1]; // Set next endpoint parameter to be unperturbed value
            }
        }
    }
}

void DetermineParametersMapping(void)   // Determine the mapping for parameters used in problem
{
    DeterminePhaseParametersMapping();      // Determine the mapping for phase parameters used in problem
    DetermineEndpointParametersMapping();   // Determine the mapping for endpoint parameters used in problem
}

void DeterminePhaseParametersMapping(void)  // Determine the mapping for phase parameters used in problem
{
    intMat PPPreLim;    // Preliminary list of phase parameters to be computed for function variable combination
    int numPP;          // Number of phase parameters that need to be computed for function variable combination
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nppG[phase])    // If one or more phase parameters in phase
        {
            PPPreLim = getIntMat(nppG[phase]);  // Allocate memory for number of phase parameters in phase
            
            if (nxG[phase]>0)   // If one or more state component in phase
            {
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                    {
                        numPP = 0;  // Initialize number of phase parameters flagged to zero
                        for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                        {
                            if ((DynamicPhaseDependenciesG[phase].mat[comp].val[param])&&(StatePhaseDependenciesG[phase].mat[comp2].val[param]))  // If dynamic function comp in phase is dependent on phase parameter param and phase parameter param is dependent on state component comp2 in phase
                            {
                                PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                numPP++;    // Increment index by one
                            }
                        }
                        if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                        {
                            PhaseDynamicStateDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);    // Allocate memory for number of phase parameters that need to be computed for function variable combination
                            for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                            {
                                PhaseDynamicStateDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];    // Extract index of phase parameter
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((DynamicPhaseDependenciesG[phase].mat[comp].val[param])&&(ControlPhaseDependenciesG[phase].mat[comp2].val[param]))    // If dynamic function comp in phase is dependent on phase parameter param and phase parameter param is dependent on control component comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhaseDynamicControlDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);  // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhaseDynamicControlDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];  // Extract index of phase parameter
                                }
                            }
                        }
                    }
                    
                    numPP = 0;  // Initialize number of phase parameters flagged to zero
                    for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                    {
                        if ((DynamicPhaseDependenciesG[phase].mat[comp].val[param])&&(TimePhaseDependenciesG[phase].mat[0].val[param]))   // If dynamic function comp in phase is dependent on phase parameter param and phase parameter param is dependent on time in phase
                        {
                            PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                            numPP++;    // Increment index by one
                        }
                    }
                    if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        PhaseDynamicTimeDependMapG[phase].mat[comp].mat[0] = getIntMat(numPP); // Allocate memory for number of phase parameters that need to be computed for function variable combination
                        for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                        {
                            PhaseDynamicTimeDependMapG[phase].mat[comp].mat[0].val[PP] = PPPreLim.val[PP]; // Extract index of phase parameter
                        }
                    }
                    
                    if (nsG>0)  // If one or more static parameters in problem
                    {
                        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((DynamicPhaseDependenciesG[phase].mat[comp].val[param])&&(StaticPhaseDependenciesG[phase].mat[comp2].val[param])) // If dynamic function comp in phase is dependent on phase parameter param and phase parameter param is dependent on static parameter comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhaseDynamicStaticDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);   // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhaseDynamicStaticDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];   // Extract index of phase parameter
                                }
                            }
                        }
                    }
                }
            }
            
            if (ncG[phase]>0)   // If one or more path functions in phase
            {
                for (int comp=0; comp<ncG[phase]; comp++)   // For each path function in phase
                {
                    if (nxG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((PathPhaseDependenciesG[phase].mat[comp].val[param])&&(StatePhaseDependenciesG[phase].mat[comp2].val[param])) // If path function comp in phase is dependent on phase parameter param and phase parameter param is dependent on state component comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhasePathStateDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);   // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhasePathStateDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];   // Extract index of phase parameter
                                }
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((PathPhaseDependenciesG[phase].mat[comp].val[param])&&(ControlPhaseDependenciesG[phase].mat[comp2].val[param]))   // If path function comp in phase is dependent on phase parameter param and phase parameter param is dependent on control component comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhasePathControlDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP); // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhasePathControlDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP]; // Extract index of phase parameter
                                }
                            }
                        }
                    }
                    
                    numPP = 0;  // Initialize number of phase parameters flagged to zero
                    for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                    {
                        if ((PathPhaseDependenciesG[phase].mat[comp].val[param])&&(TimePhaseDependenciesG[phase].mat[0].val[param]))  // If path function comp in phase is dependent on phase parameter param and phase parameter param is dependent on time in phase
                        {
                            PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                            numPP++;    // Increment index by one
                        }
                    }
                    if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        PhasePathTimeDependMapG[phase].mat[comp].mat[0] = getIntMat(numPP);    // Allocate memory for number of phase parameters that need to be computed for function variable combination
                        for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                        {
                            PhasePathTimeDependMapG[phase].mat[comp].mat[0].val[PP] = PPPreLim.val[PP];    // Extract index of phase parameter
                        }
                    }
                    
                    if (nsG>0)  // If one or more static parameters in problem
                    {
                        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((PathPhaseDependenciesG[phase].mat[comp].val[param])&&(StaticPhaseDependenciesG[phase].mat[comp2].val[param]))    // If path function comp in phase is dependent on phase parameter param and phase parameter param is dependent on static parameter comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhasePathStaticDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);  // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhasePathStaticDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];  // Extract index of phase parameter
                                }
                            }
                        }
                    }
                }
            }
            
            if (nqG[phase]>0)   // If one or more lagrange functions in phase
            {
                for (int comp=0; comp<nqG[phase]; comp++)   // For each lagrange function in phase
                {
                    if (nxG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each state component in phase
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((LagrangePhaseDependenciesG[phase].mat[comp].val[param])&&(StatePhaseDependenciesG[phase].mat[comp2].val[param])) // If lagrange function comp in phase is dependent on phase parameter param and phase parameter param is dependent on state component comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhaseLagrangeStateDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);   // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhaseLagrangeStateDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];   // Extract index of phase parameter
                                }
                            }
                        }
                    }
                    
                    if (nuG[phase]>0)   // If one or more control component in phase
                    {
                        for (int comp2=0; comp2<nuG[phase]; comp2++)    // For each control component in phase
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((LagrangePhaseDependenciesG[phase].mat[comp].val[param])&&(ControlPhaseDependenciesG[phase].mat[comp2].val[param]))   // If lagrange function comp in phase is dependent on phase parameter param and phase parameter param is dependent on control component comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhaseLagrangeControlDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP); // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhaseLagrangeControlDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP]; // Extract index of phase parameter
                                }
                            }
                        }
                    }
                    
                    numPP = 0;  // Initialize number of phase parameters flagged to zero
                    for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                    {
                        if ((LagrangePhaseDependenciesG[phase].mat[comp].val[param])&&(TimePhaseDependenciesG[phase].mat[0].val[param]))  // If lagrange function comp in phase is dependent on phase parameter param and phase parameter param is dependent on time in phase
                        {
                            PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                            numPP++;    // Increment index by one
                        }
                    }
                    if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        PhaseLagrangeTimeDependMapG[phase].mat[comp].mat[0] = getIntMat(numPP);    // Allocate memory for number of phase parameters that need to be computed for function variable combination
                        for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                        {
                            PhaseLagrangeTimeDependMapG[phase].mat[comp].mat[0].val[PP] = PPPreLim.val[PP];    // Extract index of phase parameter
                        }
                    }
                    
                    if (nsG>0)  // If one or more static parameters in problem
                    {
                        for (int comp2=0; comp2<nsG; comp2++)   // For each static parameter in problem
                        {
                            numPP = 0;  // Initialize number of phase parameters flagged to zero
                            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter in phase
                            {
                                if ((LagrangePhaseDependenciesG[phase].mat[comp].val[param])&&(StaticPhaseDependenciesG[phase].mat[comp2].val[param]))    // If lagrange function comp in phase is dependent on phase parameter param and phase parameter param is dependent on static parameter comp2 in phase
                                {
                                    PPPreLim.val[numPP] = param;    // Mark phase parameter param as needing to be computed for function variable combination
                                    numPP++;    // Increment index by one
                                }
                            }
                            if (numPP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                PhaseLagrangeStaticDependMapG[phase].mat[comp].mat[comp2] = getIntMat(numPP);  // Allocate memory for number of phase parameters that need to be computed for function variable combination
                                for (int PP=0; PP<numPP; PP++)  // For each phase parameter that needs to be computed
                                {
                                    PhaseLagrangeStaticDependMapG[phase].mat[comp].mat[comp2].val[PP] = PPPreLim.val[PP];  // Extract index of phase parameter
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}

void DetermineEndpointParametersMapping(void)   // Determine the mapping for endpoint parameters used in problem
{
    
    intMat EPPreLim;    // Preliminary list of endpoint parameters to be computed for function variable combination
    int numEP;          // Number of endpoint parameters that need to be computed for function variable combination
    
    int nd = 0, ne = 0;
    if (DurationFlagG)
    {
        nd = PG;
    }
    if (ContinuityFlagG)
    {
        ne = neG;
    }
    
    if (nepG>0) // If one or more endpoint parameters used in problem
    {
        EPPreLim = getIntMat(nepG); // Allocate memory for number of endpoint parameters in problem

        int numEvent;   // Holder for number of events
        
        numEvent = nbG + nd + ne; // Set number of event used to nbG
        
        for (int phase=0; phase<PG; phase++)    // For each phase in problem
        {
            if (nxG[phase]) // If one or more state components in phase
            {
                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                {
                    numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                    for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                    {
                        if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(InitStateEndpointDependenciesG[phase].mat[comp].val[param])) // If objective function in phase is dependent on endpoint parameter param and endpoint parameter param is dependent on initial state component comp in phase
                        {
                            EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                            numEP++;    // Increment index by one
                        }
                    }
                    if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        EndpointObjectiveInitStateDependMapG.mat[phase].mat[comp] = getIntMat(numEP);  // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                        for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                        {
                            EndpointObjectiveInitStateDependMapG.mat[phase].mat[comp].val[EP] = EPPreLim.val[EP];  // Extract index of endpoint parameter
                        }
                    }
                    
                    numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                    for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                    {
                        if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(FinalStateEndpointDependenciesG[phase].mat[comp].val[param]))    // If objective function in phase is dependent on endpoint parameter param and endpoint parameter param is dependent on final state component comp in phase
                        {
                            EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                            numEP++;    // Increment index by one
                        }
                    }
                    if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comp] = getIntMat(numEP); // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                        for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                        {
                            EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comp].val[EP] = EPPreLim.val[EP]; // Extract index of endpoint parameter
                        }
                    }
                }
            }
            
            if (nqG[phase]) // If one or more integral components in phase
            {
                for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                {
                    numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                    for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                    {
                        if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(IntegralEndpointDependenciesG[phase].mat[comp].val[param]))  // If objective function in phase is dependent on endpoint parameter param and endpoint parameter param is dependent on integral component comp in phase
                        {
                            EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                            numEP++;    // Increment index by one
                        }
                    }
                    if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        EndpointObjectiveIntegralDependMapG.mat[phase].mat[comp] = getIntMat(numEP);   // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                        for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                        {
                            EndpointObjectiveIntegralDependMapG.mat[phase].mat[comp].val[EP] = EPPreLim.val[EP];   // Extract index of endpoint parameter
                        }
                    }
                }
            }
            
            numEP = 0;  // Initialize number of endpoint parameters flagged to zero
            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
            {
                if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(InitTimeEndpointDependenciesG[phase].mat[0].val[param])) // If objective function in phase is dependent on endpoint parameter param and endpoint parameter param is dependent on initial time in phase
                {
                    EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                    numEP++;    // Increment index by one
                }
            }
            if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
            {
                EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0] = getIntMat(numEP);  // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                {
                    EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0].val[EP] = EPPreLim.val[EP];  // Extract index of endpoint parameter
                }
            }
            
            numEP = 0;  // Initialize number of endpoint parameters flagged to zero
            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
            {
                if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(FinalTimeEndpointDependenciesG[phase].mat[0].val[param]))    // If objective function in phase is dependent on endpoint parameter param and endpoint parameter param is dependent on final time in phase
                {
                    EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                    numEP++;    // Increment index by one
                }
            }
            if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
            {
                EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0] = getIntMat(numEP); // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                {
                    EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0].val[EP] = EPPreLim.val[EP]; // Extract index of endpoint parameter
                }
            }
            
            if (numEvent>0)   // If one or more event in problem
            {
                for (int event=0; event<numEvent; event++)  // For each event in problem
                {
                    if (nxG[phase]) // If one or more state components in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
                            numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                            {
                                if ((EventEndpointDependenciesG.mat[event].val[param])&&(InitStateEndpointDependenciesG[phase].mat[comp].val[param])) // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on initial state component comp in phase
                                {
                                    EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                                    numEP++;    // Increment index by one
                                }
                            }
                            if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                EndpointEventInitStateDependMapG[phase].mat[event].mat[comp] = getIntMat(numEP);   // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                                for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                                {
                                    EndpointEventInitStateDependMapG[phase].mat[event].mat[comp].val[EP] = EPPreLim.val[EP];   // Extract index of endpoint parameter
                                }
                            }
                            
                            numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                            {
                                if ((EventEndpointDependenciesG.mat[event].val[param])&&(FinalStateEndpointDependenciesG[phase].mat[comp].val[param]))    // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on final state component comp in phase
                                {
                                    EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                                    numEP++;    // Increment index by one
                                }
                            }
                            if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                EndpointEventFinalStateDependMapG[phase].mat[event].mat[comp] = getIntMat(numEP);  // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                                for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                                {
                                    EndpointEventFinalStateDependMapG[phase].mat[event].mat[comp].val[EP] = EPPreLim.val[EP];  // Extract index of endpoint parameter
                                }
                            }
                        }
                    }
                    
                    if (nqG[phase]) // If one or more integral components in phase
                    {
                        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                        {
                            numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                            {
                                if ((EventEndpointDependenciesG.mat[event].val[param])&&(IntegralEndpointDependenciesG[phase].mat[comp].val[param]))  // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on integral component comp in phase
                                {
                                    EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                                    numEP++;    // Increment index by one
                                }
                            }
                            if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                            {
                                EndpointEventIntegralDependMapG[phase].mat[event].mat[comp] = getIntMat(numEP);    // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                                for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                                {
                                    EndpointEventIntegralDependMapG[phase].mat[event].mat[comp].val[EP] = EPPreLim.val[EP];    // Extract index of endpoint parameter
                                }
                            }
                        }
                    }
                    
                    numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                    for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                    {
                        if ((EventEndpointDependenciesG.mat[event].val[param])&&(InitTimeEndpointDependenciesG[phase].mat[0].val[param])) // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on initial time in phase
                        {
                            EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                            numEP++;    // Increment index by one
                        }
                    }
                    if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        EndpointEventInitTimeDependMapG[phase].mat[event].mat[0] = getIntMat(numEP);   // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                        for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                        {
                            EndpointEventInitTimeDependMapG[phase].mat[event].mat[0].val[EP] = EPPreLim.val[EP];   // Extract index of endpoint parameter
                        }
                    }
                    
                    numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                    for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                    {
                        if ((EventEndpointDependenciesG.mat[event].val[param])&&(FinalTimeEndpointDependenciesG[phase].mat[0].val[param]))    // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on final time in phase
                        {
                            EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                            numEP++;    // Increment index by one
                        }
                    }
                    if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                    {
                        EndpointEventFinalTimeDependMapG[phase].mat[event].mat[0] = getIntMat(numEP);  // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                        for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                        {
                            EndpointEventFinalTimeDependMapG[phase].mat[event].mat[0].val[EP] = EPPreLim.val[EP];  // Extract index of endpoint parameter
                        }
                    }
                }
            }
        }
        
        if (nsG)    // If one or more static parameters in problem
        {
            for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
            {
                numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                {
                    if ((ObjectiveEndpointDependenciesG.mat[0].val[param])&&(StaticEndpointDependenciesG.mat[comp].val[param]))  // If objective function is dependent on endpoint parameter param and endpoint parameter param is dependent on static component comp
                    {
                        EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                        numEP++;    // Increment index by one
                    }
                }
                if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                {
                    EndpointObjectiveStaticDependMapG.mat[0].mat[comp] = getIntMat(numEP); // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                    for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                    {
                        EndpointObjectiveStaticDependMapG.mat[0].mat[comp].val[EP] = EPPreLim.val[EP]; // Extract index of endpoint parameter
                    }
                }
            }
        }
        
        if (numEvent>0)
        {
            if (nsG)    // If one or more static parameters in problem
            {
                for (int event=0; event<numEvent; event++)  // For each event in problem
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        numEP = 0;  // Initialize number of endpoint parameters flagged to zero
                        for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
                        {
                            if ((EventEndpointDependenciesG.mat[event].val[param])&&(StaticEndpointDependenciesG.mat[comp].val[param]))   // If event function event is dependent on endpoint parameter param and endpoint parameter param is dependent on static parameter comp in phase
                            {
                                EPPreLim.val[numEP] = param;    // Mark endpoint parameter param as needing to be computed for function variable combination
                                numEP++;    // Increment index by one
                            }
                        }
                        if (numEP>0)    // If one or more phase parameter needs to be computed for function variable combination
                        {
                            EndpointEventStaticDependMapG.mat[event].mat[comp] = getIntMat(numEP); // Allocate memory for number of endpoint parameters that need to be computed for function variable combination
                            for (int EP=0; EP<numEP; EP++)  // For each endpoint parameter that needs to be computed
                            {
                                EndpointEventStaticDependMapG.mat[event].mat[comp].val[EP] = EPPreLim.val[EP]; // Extract index of endpoint parameter
                            }
                        }
                    }
                }
            }
        }
    }
}

void DetermineFunctionMapping(int LavrentievConstraintFlag) // Determine the mapping for functions used in problem. Input: flag indicating Lavrentiev constraints are being used
{
//    setSystemInfoBC();                      // Set global sysinfoBCG structure using global sysinfoG structure
//    SetParametersBC();                  // Set global Bicomplex parameter structures using global double parameter structure
    setSystemInfoHD();                      // Set global sysinfoHDG structure using global sysinfoG structure
    SetParametersHD();                  // Set global HyperDual parameter structures using global double parameter structure
    DeterminePhaseFunctionMapping(1);       // Determine the mapping for phase functions used in problem
    DetermineEndpointFunctionMapping(1);    // Determine the mapping for endpoint functions used in problem
}

void DeterminePhaseFunctionMapping(void)    // Determine the mapping for phase functions used in problem
{
//    printf("\nDynamicTimeDependMapG");
//    printf(DynamicTimeDependMapG);
//    printf("\nDynamicStateDependMapG");
//    printf(DynamicStateDependMapG);
//    printf("\nDynamicControlDependMapG");
//    printf(DynamicControlDependMapG);
//    printf("\nDynamicStaticDependMapG");
//    printf(DynamicStaticDependMapG);
//    printf("\nPathTimeDependMapG");
//    printf(PathTimeDependMapG);
//    printf("\nPathStateDependMapG");
//    printf(PathStateDependMapG);
//    printf("\nPathControlDependMapG");
//    printf(PathControlDependMapG);
//    printf("\nPathStaticDependMapG");
//    printf(PathStaticDependMapG);
//    printf("\nLagrangeTimeDependMapG");
//    printf(LagrangeTimeDependMapG);
//    printf("\nLagrangeStateDependMapG");
//    printf(LagrangeStateDependMapG);
//    printf("\nLagrangeControlDependMapG");
//    printf(LagrangeControlDependMapG);
//    printf("\nLagrangeStaticDependMapG");
//    printf(LagrangeStaticDependMapG);
    
//    printf(sysinfoG);
//    printf(sysinfoBCG);
    
//    for (int p=0; p<PG; p++)
//    {
//        printf("\nPhaseDynamicStateDependMapG[%d] = ",p);
//        printf(PhaseDynamicStateDependMapG[p]);
//        printf("\nphaseparametersG[%d] = ",p);
//        printf(phaseparametersG[p]);
//        for (int np=0; np<nppG[p]; np++)
//        {
//            printf("\nphaseparametersBCG[%d].mat[%d].val[0] = ",p,np);
//            printf(phaseparametersBCG[p].mat[np].val[0]);
//        }
//        printf("\n");
//    }
    
//    double value;   // Holder for outputs of phase function partials
    doubleMat value(1); // Holder for outputs of phase function partials
    int var;
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        var = -1;   // Indicate partial wrt to time
        
        if (nxG[phase]>0)   // If one or more dynamic functions in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
            {
                dyn_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);   // Evaluate partial of dynamic function comp2 wrt time at first point in phase
                
                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    DynamicTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;    // Indicate dynamic function comp2 is dependent on time
                }
            }
        }
        
        if (ncG[phase]>0)   // If one or more path functions in phase
        {
            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
            {
                path_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);  // Evaluate partial of path function comp2 wrt time at first point in phase

                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    PathTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;   // Indicate path function comp2 is dependent on time
                }
            }
        }
        
        if (nqG[phase]>0)   // If one or more lagrange functions in phase
        {
            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
            {
                lag_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);   // Evaluate partial of lagrange function comp2 wrt time at first point in phase

                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    LagrangeTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;   // Indicate lagrange function comp2 is dependent on time
                }
            }
        }
        
        if (nxG[phase]) // If one or more state components in phase
        {
            var = 1;      // Set variable type to state
            
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                {
                    dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt state comp at first point in phase

                    if (value.val[0]==0)    // If value is zero
                    {
                        // Do nothing
                    }
                    else    // value is nonzero
                    {
                        DynamicStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;    // Indicate dynamic function comp2 is dependent on state component comp
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt state comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on state component comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt state comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate lagrange function comp2 is dependent on state component comp
                        }
                    }
                }
            }
        }
        
        if (nuG[phase]) // If one or more control components in phase
        {
            var = 2;      // Set variable type to control

            for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
            {
                if (nxG[phase]>0)   // If one or more dynamic functions in phase
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                    {
                        dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt control comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            DynamicControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on control component comp
                        }
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt control comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on control component comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt control comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate lagrange function comp2 is dependent on control component comp
                        }
                    }
                }
            }
        }
        
        if (nsG)    // If one or more static parameters
        {
            var = 6;      // Set variable type to static

            for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
            {
                if (nxG[phase]>0)   // If one or more dynamic functions in phase
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                    {
                        dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt static parameter comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            DynamicStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on static parameter comp
                        }
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt static parameter comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on static parameter comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt static parameter comp at first point in phase

                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate lagrange function comp2 is dependent on static parameter comp
                        }
                    }
                }
            }
        }
        
//        printf("\nDynamicTimeDependMapG");
//        printf(DynamicTimeDependMapG);
        
        if (nppG[phase]>0)  // If one or more phase parameter
        {
            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
            {
                if (nxG[phase]) // If one or more dynamic functions in problem
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                    {
                        if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                DynamicTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;    // Indicate dynamic function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (ncG[phase]) // If one or more path functions in problem
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                    {
                        if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                PathTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;  // Indicate path function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (nqG[phase]) // If one or more lagrange functions in problem
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                    {
                        if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                LagrangeTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;  // Indicate lagrange function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (nxG[phase]) // If one or more state components in phase
                {
                    for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in problem
                    {
                        for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                        {
                            if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                            {
                                if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                {
                                    DynamicStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;    // Indicate dynamic function comp2 is dependent on state component comp
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path function in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                    {
                                        PathStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on state component comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange function in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                    {
                                        LagrangeStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate lagrange function comp2 is dependent on state component comp
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (nuG[phase]) // If one or more control components in phase
                {
                    for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in problem
                    {
                        
                        if (nxG[phase]) // If one or more dynamic functions in problem
                        {
                            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                            {
                                if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        DynamicControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path functions in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        PathControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate path function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange functions in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        LagrangeControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate lagrange function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (nsG)    // If one or more static parameters in phase
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        if (nxG[phase]) // If one or more dynamic functions in problem
                        {
                            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                            {
                                if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        DynamicStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate dynamic function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path functions in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        PathStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate path function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange functions in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        LagrangeStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate lagrange function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
//    printf("\nDynamicTimeDependMapG");
//    printf(DynamicTimeDependMapG);  // Check dynamic function dependencies on time: Appears to be good
//    printf("\nDynamicStateDependMapG");
//    printf(DynamicStateDependMapG); // Check dynamic function dependencies on state: Appears to be good
//    printf("\nDynamicControlDependMapG");
//    printf(DynamicControlDependMapG);   // Check dynamic function dependencies on control: Appears to be good
//    printf("\nDynamicStaticDependMapG");
//    printf(DynamicStaticDependMapG);    // Check dynamic function dependencies on static: Appears to be good
    
//    printf("\nPathTimeDependMapG");
//    printf(PathTimeDependMapG); // Check path function dependencies on time: Appears to be good
//    printf("\nPathStateDependMapG");
//    printf(PathStateDependMapG);    // Check path function dependencies on state: Appears to be good
//    printf("\nPathControlDependMapG");
//    printf(PathControlDependMapG);  // Check path function dependencies on control: Appears to be good
//    printf("\nPathStaticDependMapG");
//    printf(PathStaticDependMapG);   // Check path function dependencies on static: Appears to be good
    
//    printf("\nLagrangeTimeDependMapG");
//    printf(LagrangeTimeDependMapG); // Check lagrange function dependencies on time: Appears to be good
//    printf("\nLagrangeStateDependMapG");
//    printf(LagrangeStateDependMapG);    // Check lagrange function dependencies on state: Appears to be good
//    printf("\nLagrangeControlDependMapG");
//    printf(LagrangeControlDependMapG);  // Check lagrange function dependencies on control: Appears to be good
//    printf("\nLagrangeStaticDependMapG");
//    printf(LagrangeStaticDependMapG);   // Check lagrange function dependencies on static: Appears to be good
}

void DeterminePhaseFunctionMapping(int LavrentievConstraintFlag)    // Determine the mapping for phase functions used in problem. Input: flag indicating Lavrentiev constraints are being used
{
//    printf("\nDynamicTimeDependMapG");
//    printf(DynamicTimeDependMapG);
//    printf("\nDynamicStateDependMapG");
//    printf(DynamicStateDependMapG);
//    printf("\nDynamicControlDependMapG");
//    printf(DynamicControlDependMapG);
//    printf("\nDynamicStaticDependMapG");
//    printf(DynamicStaticDependMapG);
//    printf("\nPathTimeDependMapG");
//    printf(PathTimeDependMapG);
//    printf("\nPathStateDependMapG");
//    printf(PathStateDependMapG);
//    printf("\nPathControlDependMapG");
//    printf(PathControlDependMapG);
//    printf("\nPathStaticDependMapG");
//    printf(PathStaticDependMapG);
//    printf("\nLagrangeTimeDependMapG");
//    printf(LagrangeTimeDependMapG);
//    printf("\nLagrangeStateDependMapG");
//    printf(LagrangeStateDependMapG);
//    printf("\nLagrangeControlDependMapG");
//    printf(LagrangeControlDependMapG);
//    printf("\nLagrangeStaticDependMapG");
//    printf(LagrangeStaticDependMapG);

//    printf(sysinfoG);
//    printf(sysinfoBCG);

//    for (int p=0; p<PG; p++)
//    {
//        printf("\nPhaseDynamicStateDependMapG[%d] = ",p);
//        printf(PhaseDynamicStateDependMapG[p]);
//        printf("\nphaseparametersG[%d] = ",p);
//        printf(phaseparametersG[p]);
//        for (int np=0; np<nppG[p]; np++)
//        {
//            printf("\nphaseparametersBCG[%d].mat[%d].val[0] = ",p,np);
//            printf(phaseparametersBCG[p].mat[np].val[0]);
//        }
//        printf("\n");
//    }
    
    //    double value;   // Holder for outputs of phase function partials
    doubleMat value(1); // Holder for outputs of phase function partials
    int var;
    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        var = -1;   // Indicate partial wrt to time
        
        if (nxG[phase]>0)   // If one or more dynamic functions in phase
        {
            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
            {
                dyn_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);   // Evaluate partial of dynamic function comp2 wrt time at first point in phase
                
                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    DynamicTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;    // Indicate dynamic function comp2 is dependent on time
                }
            }
        }
        
        if (ncG[phase]>0)   // If one or more path functions in phase
        {
            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
            {
                path_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);  // Evaluate partial of path function comp2 wrt time at first point in phase
                
                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    PathTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;   // Indicate path function comp2 is dependent on time
                }
            }
        }
        
        if (nqG[phase]>0)   // If one or more lagrange functions in phase
        {
            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
            {
                lag_func_Grad_HD(phase,comp2,var,-1,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);   // Evaluate partial of lagrange function comp2 wrt time at first point in phase
                
                if (value.val[0]==0)    // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    LagrangeTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;   // Indicate lagrange function comp2 is dependent on time
                }
            }
        }
        
        if (nxG[phase]) // If one or more state components in phase
        {
            var = 1;      // Set variable type to state
            
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                {
                    dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt state comp at first point in phase
                    
                    if (value.val[0]==0)    // If value is zero
                    {
                        // Do nothing
                    }
                    else    // value is nonzero
                    {
                        DynamicStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;    // Indicate dynamic function comp2 is dependent on state component comp
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt state comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on state component comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt state comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate lagrange function comp2 is dependent on state component comp
                        }
                    }
                }
            }
        }
        
        if (nuG[phase]) // If one or more control components in phase
        {
            var = 2;      // Set variable type to control
            
            for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in phase
            {
                if (nxG[phase]>0)   // If one or more dynamic functions in phase
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                    {
                        dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt control comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            DynamicControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on control component comp
                        }
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt control comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on control component comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt control comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate lagrange function comp2 is dependent on control component comp
                        }
                    }
                }
            }
        }
        
        if (nsG)    // If one or more static parameters
        {
            var = 6;      // Set variable type to static
            
            for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
            {
                if (nxG[phase]>0)   // If one or more dynamic functions in phase
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in phase
                    {
                        dyn_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of dynamic function comp2 wrt static parameter comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            DynamicStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on static parameter comp
                        }
                    }
                }
                
                if (ncG[phase]>0)   // If one or more path functions in phase
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in phase
                    {
                        path_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG);    // Evaluate partial of path function comp2 wrt static parameter comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            PathStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on static parameter comp
                        }
                    }
                }
                
                if (nqG[phase]>0)   // If one or more lagrange functions in phase
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in phase
                    {
                        lag_func_Grad_HD(phase,comp2,var,comp,phaseparametersG.parametersStruct[phase],sysinfoHDG,phaseparametersHDG.parametersStruct[phase],value,stepeSizeG); // Evaluate partial of lagrange function comp2 wrt static parameter comp at first point in phase
                        
                        if (value.val[0]==0)    // If value is zero
                        {
                            // Do nothing
                        }
                        else    // value is nonzero
                        {
                            LagrangeStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate lagrange function comp2 is dependent on static parameter comp
                        }
                    }
                }
            }
        }
        
        //        printf("\nDynamicTimeDependMapG");
        //        printf(DynamicTimeDependMapG);
        
        if (nppG[phase]>0)  // If one or more phase parameter
        {
            for (int param=0; param<nppG[phase]; param++)   // For each phase parameter
            {
                if (nxG[phase]) // If one or more dynamic functions in problem
                {
                    for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                    {
                        if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                DynamicTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;    // Indicate dynamic function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (ncG[phase]) // If one or more path functions in problem
                {
                    for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                    {
                        if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                PathTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;  // Indicate path function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (nqG[phase]) // If one or more lagrange functions in problem
                {
                    for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                    {
                        if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                        {
                            if (TimePhaseDependenciesG[phase].mat[0].val[param]) // If phase parameter param is dependent on time in phase
                            {
                                LagrangeTimeDependMapG.mat[phase].mat[comp2].val[0] = 1;  // Indicate lagrange function comp2 is dependent on time
                            }
                        }
                    }
                }
                
                if (nxG[phase]) // If one or more state components in phase
                {
                    for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in problem
                    {
                        for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                        {
                            if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                            {
                                if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                {
                                    DynamicStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;    // Indicate dynamic function comp2 is dependent on state component comp
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path function in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                    {
                                        PathStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate path function comp2 is dependent on state component comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange function in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (StatePhaseDependenciesG[phase].mat[comp].val[param]) // If phase parameter param is dependent on state component comp in phase
                                    {
                                        LagrangeStateDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate lagrange function comp2 is dependent on state component comp
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (nuG[phase]) // If one or more control components in phase
                {
                    for (int comp=0; comp<nuG[phase]; comp++)   // For each control component in problem
                    {
                        
                        if (nxG[phase]) // If one or more dynamic functions in problem
                        {
                            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                            {
                                if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        DynamicControlDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate dynamic function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path functions in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        PathControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate path function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange functions in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (ControlPhaseDependenciesG[phase].mat[comp].val[param])   // If phase parameter param is dependent on control component comp in phase
                                    {
                                        LagrangeControlDependMapG.mat[phase].mat[comp2].val[comp] = 1; // Indicate lagrange function comp2 is dependent on control component comp
                                    }
                                }
                            }
                        }
                    }
                }
                
                if (nsG)    // If one or more static parameters in phase
                {
                    for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
                    {
                        if (nxG[phase]) // If one or more dynamic functions in problem
                        {
                            for (int comp2=0; comp2<nxG[phase]; comp2++)    // For each dynamic function in problem
                            {
                                if(DynamicPhaseDependenciesG[phase].mat[comp2].val[param])   // If dynamic function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        DynamicStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;   // Indicate dynamic function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                        
                        if (ncG[phase]) // If one or more path functions in problem
                        {
                            for (int comp2=0; comp2<ncG[phase]; comp2++)    // For each path function in problem
                            {
                                if(PathPhaseDependenciesG[phase].mat[comp2].val[param])  // If path function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        PathStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate path function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                        
                        if (nqG[phase]) // If one or more lagrange functions in problem
                        {
                            for (int comp2=0; comp2<nqG[phase]; comp2++)    // For each lagrange function in problem
                            {
                                if(LagrangePhaseDependenciesG[phase].mat[comp2].val[param])  // If lagrange function comp2 is dependent on phase parameter param
                                {
                                    if (StaticPhaseDependenciesG[phase].mat[comp].val[param])    // If phase parameter param is dependent on static parameter comp in phase
                                    {
                                        LagrangeStaticDependMapG.mat[phase].mat[comp2].val[comp] = 1;  // Indicate lagrange function comp2 is dependent on static parameter comp
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
//    printf("\nObjectiveInitStateDependMapG");
//    printf(ObjectiveInitStateDependMapG);   // Check objective function dependencies on initial state: Appears to be good
//    printf("\nObjectiveFinalStateDependMapG");
//    printf(ObjectiveFinalStateDependMapG);  // Check objective function dependencies on final state: Appears to be good
//    printf("\nObjectiveIntegralDependMapG");
//    printf(ObjectiveIntegralDependMapG);    // Check objective function dependencies on integral: Appears to be good
//    printf("\nObjectiveInitTimeDependMapG");
//    printf(ObjectiveInitTimeDependMapG);    // Check objective function dependencies on initial time: Appears to be good
//    printf("\nObjectiveFinalTimeDependMapG");
//    printf(ObjectiveFinalTimeDependMapG);   // Check objective function dependencies on final time: Appears to be good
//    printf("\nObjectiveStaticDependMapG");
//    printf(ObjectiveStaticDependMapG);  // Check objective function dependencies on static: Appears to be good
    
//    printf("\nEventInitStateDependMapG");
//    printf(EventInitStateDependMapG);   // Check event function dependencies on initial state: Appears to be good
//    printf("\nEventFinalStateDependMapG");
//    printf(EventFinalStateDependMapG);  // Check event function dependencies on final state: Appears to be good
//    printf("\nEventIntegralDependMapG");
//    printf(EventIntegralDependMapG);    // Check event function dependencies on integral: Appears to be good
//    printf("\nEventInitTimeDependMapG");
//    printf(EventInitTimeDependMapG);    // Check event function dependencies on initial time: Appears to be good
//    printf("\nEventFinalTimeDependMapG");
//    printf(EventFinalTimeDependMapG);   // Check event function dependencies on final time: Appears to be good
//    printf("\nEventStaticDependMapG");
//    printf(EventStaticDependMapG);  // Check event function dependencies on static: Appears to be good
}

void DetermineEndpointFunctionMapping(int LavrentievConstraintFlag) // Determine the mapping for endpoint functions used in problem. Input: flag indicating Lavrentiev constraints are being used
{
//    printf("\nObjectiveInitStateDependMapG");
//    printf(ObjectiveInitStateDependMapG);
//    printf("\nObjectiveFinalStateDependMapG");
//    printf(ObjectiveFinalStateDependMapG);
//    printf("\nObjectiveIntegralDependMapG");
//    printf(ObjectiveIntegralDependMapG);
//    printf("\nObjectiveInitTimeDependMapG");
//    printf(ObjectiveInitTimeDependMapG);
//    printf("\nObjectiveFinalTimeDependMapG");
//    printf(ObjectiveFinalTimeDependMapG);
//    printf("\nObjectiveStaticDependMapG");
//    printf(ObjectiveStaticDependMapG);
//    printf("\nEventInitStateDependMapG");
//    printf(EventInitStateDependMapG);
//    printf("\nEventFinalStateDependMapG");
//    printf(EventFinalStateDependMapG);
//    printf("\nEventIntegralDependMapG");
//    printf(EventIntegralDependMapG);
//    printf("\nEventInitTimeDependMapG");
//    printf(EventInitTimeDependMapG);
//    printf("\nEventFinalTimeDependMapG");
//    printf(EventFinalTimeDependMapG);
//    printf("\nEventStaticDependMapG");
//    printf(EventStaticDependMapG);
    
    double value;   // Holder for outputs of phase function partials
    int var;
    int numEvent=0;
    int nd=0,ne=0;         // Number of active event constraints
    
    if (DurationFlagG)
    {
        nd = PG;
    }
    if (ContinuityFlagG)
    {
        ne = neG;
    }
    numEvent = nbG + nd + ne;

    
    for (int phase=0; phase<PG; phase++)    // For each phase in problem
    {
        if (nxG[phase]>0)   // If one or more state components in phase
        {
            for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
            {
                var = 1;    // Set variable type to initial state
                value = 0;
                obj_func_Grad_HD(phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG); // Evaluate partial of objective function wrt initial state comp in phase

                if (value==0)  // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    ObjectiveInitStateDependMapG.mat[phase].val[comp] = 1;   // Indicate objective function is dependent on initial state comp in phase
                }
                
                if (numEvent>0)   // If one or more event constraints in problem
                {
                    for (int event=0; event<numEvent; event++)  // For each event constraint in problem
                    {
                        value = 0;
                        eve_func_Grad_HD(event,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of event function wrt initial state comp in phase

                        if (value==0)  // If value is zero
                        {
//                            printf("\nvalue = %.15e",value);
                        }
                        else    // value is nonzero
                        {
                            EventInitStateDependMapG.mat[phase].mat[event].val[comp] = 1;  // Indicate event function is dependent on initial state comp in phase
//                            printf("\nvalue = %.15e",value);
                        }
                    }
                }
                
                var = 2;    // Set variable type to final state
                
                value = 0;
                obj_func_Grad_HD(phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG); // Evaluate partial of objective function wrt final state comp in phase

                if (value==0)  // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    ObjectiveFinalStateDependMapG.mat[phase].val[comp] = 1;  // Indicate objective function is dependent on final state comp in phase
                }
                
                if (numEvent>0)   // If one or more event constraints in problem
                {
                    for (int event=0; event<numEvent; event++)    // For each event constraint in problem
                    {
                        value = 0;
                        eve_func_Grad_HD(event,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of event function wrt final state comp in phase
                        
                        if (value==0)  // If value is zero
                        {
//                            printf("\nvalue = %.15e",value);
                        }
                        else    // value is nonzero
                        {
                            EventFinalStateDependMapG.mat[phase].mat[event].val[comp] = 1; // Indicate event function is dependent on final state comp in phase
//                            printf("\nvalue = %.15e",value);
                        }
                    }
                }
            }
        }
        
        if (nqG[phase]>0)   // If one or more integral components in phase
        {
            var = 3;    // Set variable type to integral
            for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
            {
                value = 0;
                obj_func_Grad_HD(phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG); // Evaluate partial of objective function wrt integral state comp in phase
                
                if (value==0)  // If value is zero
                {
                    // Do nothing
                }
                else    // value is nonzero
                {
                    ObjectiveIntegralDependMapG.mat[phase].val[comp] = 1;    // Indicate objective function is dependent on integral comp in phase
                }
                
                if (numEvent>0)   // If one or more event constraints in problem
                {
                    for (int event=0; event<numEvent; event++)    // For each event constraint in problem
                    {
                        value = 0;
                        eve_func_Grad_HD(event,phase,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of event function wrt integral state comp in phase
                        
                        if (value==0)  // If value is zero
                        {
//                            printf("\nvalue = %.15e",value);
                        }
                        else    // value is nonzero
                        {
                            EventIntegralDependMapG.mat[phase].mat[event].val[comp] = 1;   // Indicate event function is dependent on integral comp in phase
//                            printf("\nvalue = %.15e",value);
                        }
                    }
                }
            }
        }
        
        var = 4;      // Set variable type to initial time
        
        value = 0;
        obj_func_Grad_HD(phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of objective function wrt initial time in phase
        
        if (value==0)  // If value is zero
        {
            // Do nothing
        }
        else    // value is nonzero
        {
            ObjectiveInitTimeDependMapG.mat[phase].val[0] = 1;   // Indicate objective function is dependent on initial time in phase
        }
        
        if (numEvent>0)   // If one or more event constraints in problem
        {
            for (int event=0; event<numEvent; event++)    // For each event constraint in problem
            {
                value = 0;
                eve_func_Grad_HD(event,phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG); // Evaluate partial of event function wrt initial time in phase
                
                if (value==0)  // If value is zero
                {
//                    printf("\nvalue = %.15e",value);
                }
                else    // value is nonzero
                {
                    EventInitTimeDependMapG.mat[phase].mat[event].val[0] = 1;  // Indicate event function is dependent on initial time in phase
//                    printf("\nvalue = %.15e",value);
                }
            }
        }
        
        var = 5;      // Set variable type to final time
        
        value = 0;
        obj_func_Grad_HD(phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of objective function wrt final time in phase
        
        if (value==0)  // If value is zero
        {
            // Do nothing
        }
        else    // value is nonzero
        {
            ObjectiveFinalTimeDependMapG.mat[phase].val[0] = 1;  // Indicate objective function is dependent on final time in phase
        }
        if (numEvent>0)   // If one or more event constraints in problem
        {
            for (int event=0; event<numEvent; event++)    // For each event constraint in problem
            {
                value = 0;
                eve_func_Grad_HD(event,phase,var,-1,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG); // Evaluate partial of event function wrt final time in phase
                
                if (value==0)  // If value is zero
                {
//                    printf("\nvalue = %.15e",value);
                }
                else    // value is nonzero
                {
                    EventFinalTimeDependMapG.mat[phase].mat[event].val[0] = 1; // Indicate event function is dependent on final time in phase
//                    printf("\nvalue = %.15e",value);
                }
            }
        }
        
        if (nepG>0) // If one or more endpoint parameters used in problem
        {
            for (int param=0; param<nepG; param++)  // For each endpoint parameter in problem
            {
                if (ObjectiveEndpointDependenciesG.mat[0].val[param])    // If objective function in phase is dependent on endpoint parameter param
                {
                    if (nxG[phase]) // If one or more state components in phase
                    {
                        for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                        {
                            if (InitStateEndpointDependenciesG[phase].mat[comp].val[param])  // If endpoint parameter param is dependent on initial state component comp in phase
                            {
                                ObjectiveInitStateDependMapG.mat[phase].val[comp] = 1;   // Indicate objective function is dependent on initial state comp in phase
                            }
                            
                            if (FinalStateEndpointDependenciesG[phase].mat[comp].val[param]) // If endpoint parameter param is dependent on final state component comp in phase
                            {
                                ObjectiveFinalStateDependMapG.mat[phase].val[comp] = 1;  // Indicate objective function is dependent on final state comp in phase
                            }
                        }
                    }
                    
                    if (nqG[phase]) // If one or more integral components in phase
                    {
                        for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                        {
                            if (IntegralEndpointDependenciesG[phase].mat[comp].val[param])   // If endpoint parameter param is dependent on integral component comp in phase
                            {
                                ObjectiveIntegralDependMapG.mat[phase].val[comp] = 1;    // Indicate objective function is dependent on integral comp in phase
                            }
                        }
                    }
                    
                    if (InitTimeEndpointDependenciesG[phase].mat[0].val[param])  // If endpoint parameter param is dependent on initial time in phase
                    {
                        ObjectiveInitTimeDependMapG.mat[phase].val[0] = 1;   // Indicate objective function is dependent on initial time in phase
                    }
                    
                    if (FinalTimeEndpointDependenciesG[phase].mat[0].val[param]) // If endpoint parameter param is dependent on final time in phase
                    {
                        ObjectiveFinalTimeDependMapG.mat[phase].val[0] = 1;  // Indicate objective function is dependent on final time in phase
                    }
                }
                
                if (numEvent>0)   // If one or more event constraints in problem
                {
                    for (int event=0; event<numEvent; event++)    // For each event constraint in problem
                    {
                        if (EventEndpointDependenciesG.mat[event].val[param])    // If event function event is dependent on endpoint parameter param
                        {
                            if (nxG[phase]) // If one or more state components in phase
                            {
                                for (int comp=0; comp<nxG[phase]; comp++)   // For each state component in phase
                                {
                                    if (InitStateEndpointDependenciesG[phase].mat[comp].val[param])  // If endpoint parameter param is dependent on initial state component comp in phase
                                    {
                                        EventInitStateDependMapG.mat[phase].mat[event].val[comp] = 1;  // Indicate event function event is dependent on initial state comp in phase
                                    }
                                    
                                    if (FinalStateEndpointDependenciesG[phase].mat[comp].val[param]) // If endpoint parameter param is dependent on final state component comp
                                    {
                                        EventFinalStateDependMapG.mat[phase].mat[event].val[comp] = 1; // Indicate event function event is dependent on final state comp in phase
                                    }
                                }
                            }
                            
                            if (nqG[phase]) // If one or more integral components in phase
                            {
                                for (int comp=0; comp<nqG[phase]; comp++)   // For each integral component in phase
                                {
                                    if (IntegralEndpointDependenciesG[phase].mat[comp].val[param])   // If endpoint parameter param is dependent on integral component comp in phase
                                    {
                                        EventIntegralDependMapG.mat[phase].mat[event].val[comp] = 1;   // Indicate event function event is dependent on integral comp in phase
                                    }
                                }
                            }
                            
                            if (InitTimeEndpointDependenciesG[phase].mat[0].val[param])  // If endpoint parameter param is dependent on initial time in phase
                            {
                                EventInitTimeDependMapG.mat[phase].mat[event].val[0] = 1;  // Indicate event function event is dependent on initial time in phase
                            }
                            
                            if (FinalTimeEndpointDependenciesG[phase].mat[0].val[param]) // If endpoint parameter param is dependent on final time in phase
                            {
                                EventFinalTimeDependMapG.mat[phase].mat[event].val[0] = 1; // Indicate event function event is dependent on final time in phase
                            }
                        }
                    }
                }
            }
        }
    }
    
    if (nsG>0)  // If one or more static parameters in problem
    {
        var = 6;    // Set variable type to static parameter
        
        for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
        {
            value = 0;
            obj_func_Grad_HD(-1,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);    // Evaluate partial of objective function wrt static parameter comp
            
            if (value==0)  // If value is zero
            {
                // Do nothing
            }
            else    // value is nonzero
            {
                ObjectiveStaticDependMapG.mat[0].val[comp] = 1;  // Indicate objective function is dependent on static parameter comp in phase
            }
        }
    }
    
    if (nsG>0)  // If one or more static parameters in problem
    {
        var = 6;    // Set variable type to integral
        if (numEvent>0)   // If one or more event constraints in problem
        {
            for (int comp=0; comp<nsG; comp++)  // For each static parameter in problem
            {
                for (int event=0; event<numEvent; event++)    // For each event constraint in problem
                {
                    value = 0;
                    eve_func_Grad_HD(event,-1,var,comp,endpointparametersG,sysinfoHDG,endpointparametersHDG,value,stepeSizeG);   // Evaluate partial of event function wrt initial state comp in phase
                    
                    if (value==0)  // If value is zero
                    {
                        // Do nothing
                    }
                    else    // value is nonzero
                    {
                        EventStaticDependMapG.mat[event].val[comp] = 1;  // Indicate event function is dependent on static parameter comp
                    }
                    
                    if (nepG>0) // If one or more endpoint parameter
                    {
                        for (int param=0; param<nepG; param++)  // For each endpoint parameter
                        {
                            if (EventEndpointDependenciesG.mat[event].val[param])    // If event constraint event is dependent on endpoint parameter param
                            {
                                if (StaticEndpointDependenciesG.mat[comp].val[param])    // If endpoint parameter param is dependent on static parameter comp
                                {
                                    EventStaticDependMapG.mat[event].val[comp] = 1;  // Indicate event function event is dependent on static parameter comp
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
//    printf("\nObjectiveInitStateDependMapG");
//    printf(ObjectiveInitStateDependMapG);   // Check objective function dependencies on initial state: Appears to be good
//    printf("\nObjectiveFinalStateDependMapG");
//    printf(ObjectiveFinalStateDependMapG);  // Check objective function dependencies on final state: Appears to be good
//    printf("\nObjectiveIntegralDependMapG");
//    printf(ObjectiveIntegralDependMapG);    // Check objective function dependencies on integral: Appears to be good
//    printf("\nObjectiveInitTimeDependMapG");
//    printf(ObjectiveInitTimeDependMapG);    // Check objective function dependencies on initial time: Appears to be good
//    printf("\nObjectiveFinalTimeDependMapG");
//    printf(ObjectiveFinalTimeDependMapG);   // Check objective function dependencies on final time: Appears to be good
//    printf("\nObjectiveStaticDependMapG");
//    printf(ObjectiveStaticDependMapG);  // Check objective function dependencies on static: Appears to be good

//    printf("\nEventInitStateDependMapG");
//    printf(EventInitStateDependMapG);   // Check event function dependencies on initial state: Appears to be good
//    printf("\nEventFinalStateDependMapG");
//    printf(EventFinalStateDependMapG);  // Check event function dependencies on final state: Appears to be good
//    printf("\nEventIntegralDependMapG");
//    printf(EventIntegralDependMapG);    // Check event function dependencies on integral: Appears to be good
//    printf("\nEventInitTimeDependMapG");
//    printf(EventInitTimeDependMapG);    // Check event function dependencies on initial time: Appears to be good
//    printf("\nEventFinalTimeDependMapG");
//    printf(EventFinalTimeDependMapG);   // Check event function dependencies on final time: Appears to be good
//    printf("\nEventStaticDependMapG");
//    printf(EventStaticDependMapG);  // Check event function dependencies on static: Appears to be good
}

void PerturbEndpointParametersA(const int& phase, const int& component, const int& funcType, systemInfoBC& systeminfo, BicomplexMat& parametersMat, const int& phaA, const int& varA, const int& comA)    // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters A BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using Bicomplex input
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);  // Compute endpoint parameter param using Bicomplex input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersA(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, BicomplexMat& parametersMat, const int& phaA, const int& varA, const int& comA)   // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nUnperturbing Endpoint Parameters A BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set bicomplex value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set bicomplex value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, systemInfoBC& systeminfo, BicomplexMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB)    // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
//    printf("\nPerturbing Endpoint Parameters AB BC");

    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B

        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;

                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;

                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }

                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;

                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;

                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }

                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed

                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using Bicomplex input
                    }
                }
                break;

            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
//                                printf("\nHERE A");
//                                printf4MATLAB("EndpointParamFlagsA",EndpointParamFlagsA);
                            }
                            break;

                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;

                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;

                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;

                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }

                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                                
//                                printf("\nHERE B");
//                                printf4MATLAB("EndpointParamFlagsB",EndpointParamFlagsB);
                            }
                            break;

                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;

                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;

                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;

                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }

                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed

                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using Bicomplex input
                    }
                }
                break;

            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, BicomplexMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB)   // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters AB BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]];    // Set bicomplex value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                                
//                                printf("\nHERE A");
//                                printf4MATLAB("EndpointParamFlagsA",EndpointParamFlagsA);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                                
//                                printf("\nHERE B");
//                                printf4MATLAB("EndpointParamFlagsB",EndpointParamFlagsB);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]]; // Set bicomplex value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersA(const int& phase, const int& component, const int& funcType, phaseInfoBC& phaseinfo, Bicomplex* staticparameters, ParametersStructBC& parametersStruct, const int& varA, const int& comA)  // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using Bicomplex input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersA(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStructBC& parametersStruct, const int& varA, const int& comA)    // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, phaseInfoBC& phaseinfo, Bicomplex* staticparameters, ParametersStructBC& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB)   // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = stepiSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using Bicomplex input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStructBC& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB)   // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB BC");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].I1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].I2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set bicomplex value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbEndpointParametersA(const int& phase, const int& component, const int& funcType, systemInfoHD& systeminfo, HyperDualMat& parametersMat, const int& phaA, const int& varA, const int& comA)    // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters A HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using HyperDual input
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);  // Compute endpoint parameter param using HyperDual input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersA(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, HyperDualMat& parametersMat, const int& phaA, const int& varA, const int& comA)   // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nUnperturbing Endpoint Parameters A HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set HyperDual value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set HyperDual value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, systemInfoHD& systeminfo, HyperDualMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB)    // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters AB HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using HyperDual input
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                                //                                printf("\nHERE A");
                                //                                printf4MATLAB("EndpointParamFlagsA",EndpointParamFlagsA);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                                
                                //                                printf("\nHERE B");
                                //                                printf4MATLAB("EndpointParamFlagsB",EndpointParamFlagsB);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using HyperDual input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, HyperDualMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB)   // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters AB HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]];    // Set HyperDual value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                                
                                //                                printf("\nHERE A");
                                //                                printf4MATLAB("EndpointParamFlagsA",EndpointParamFlagsA);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case -1: // Perturbing endpoint parameter
                            // Do nothing
                            break;
                            
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                                
                                //                                printf("\nHERE B");
                                //                                printf4MATLAB("EndpointParamFlagsB",EndpointParamFlagsB);
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]]; // Set HyperDual value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersA(const int& phase, const int& component, const int& funcType, phaseInfoHD& phaseinfo, HyperDual* staticparameters, ParametersStructHD& parametersStruct, const int& varA, const int& comA)  // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using HyperDual input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersA(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStructHD& parametersStruct, const int& varA, const int& comA)    // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, phaseInfoHD& phaseinfo, HyperDual* staticparameters, ParametersStructHD& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB)   // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = stepeSizeG;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using HyperDual input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStructHD& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB)   // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB HD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comA,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comA].E1 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -2:
                            //            printf("\nPerturbing parameter %d in phase %d for first partial",comB,phase);
                            for (int pnt=0; pnt<parametersStruct.Len; pnt++)
                            {
                                parametersStruct.parametersMat[pnt].val[comB].E2 = 0;
                            }
                            break;
                            
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set HyperDual value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbEndpointParametersA(const int& phase, const int& component, const int& funcType, systemInfo& systeminfo, doubleMat& parametersMat, const int& phaA, const int& varA, const int& comA)  // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Endpoint Parameters A CD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using double input
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlagsA.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);  // Compute endpoint parameter param using double input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersA(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, doubleMat& parametersMat, const int& phaA, const int& varA, const int& comA)  // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set double value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(EndpointParamFlagsA.Len); param++) // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlagsA.val[param]] = parametersMatSol.val[EndpointParamFlagsA.val[param]];    // Set double value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, systemInfo& systeminfo, doubleMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB) // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using double input
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        endpoint_parameters_func(EndpointParamFlags.val[param],systeminfo.phaseinfo,systeminfo.s,parametersMat.val);   // Compute endpoint parameter param using double input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbEndpointParametersAB(const int& phase, const int& component, const int& funcType, doubleMat& parametersMatSol, doubleMat& parametersMat, const int& phaA, const int& varA, const int& comA, const int& phaB, const int& varB, const int& comB)  // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat EndpointParamFlags;  // Holder for flags indicating which endpoint parameters need to be computed for partial
        intMat EndpointParamFlagsA; // Holder for flags indicating which endpoint parameters need to be computed for partial A
        intMat EndpointParamFlagsB; // Holder for flags indicating which endpoint parameters need to be computed for partial B
        
        switch (funcType)   // Function type
        {
            case 1: // Objective function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comA];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointObjectiveStaticDependMapG.mat[0].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveInitStateDependMapG.mat[phase].mat[comB];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phase]>0)   // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveFinalStateDependMapG.mat[phase].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phase]>0)   // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveIntegralDependMapG.mat[phase].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointObjectiveInitTimeDependMapG.mat[phase].mat[0];   // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointObjectiveFinalTimeDependMapG.mat[phase].mat[0];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointObjectiveStaticDependMapG.mat[0].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of objective function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]];    // Set double value to unperturbed double value
                    }
                }
                break;
                
            case 5: // Event function
                if (nepG>0) // If one or more endpoint parameters in problem
                {
                    switch (varA)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventInitStateDependMapG[phaA].mat[component].mat[comA]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaA]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsA = EndpointEventFinalStateDependMapG[phaA].mat[component].mat[comA];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaA]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsA = EndpointEventIntegralDependMapG[phaA].mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsA = EndpointEventInitTimeDependMapG[phaA].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsA = EndpointEventFinalTimeDependMapG[phaA].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsA = EndpointEventStaticDependMapG.mat[component].mat[comA];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)    // Variable type
                    {
                        case 1: // Initial State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventInitStateDependMapG[phaB].mat[component].mat[comB]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Final State variable type
                            if (nxG[phaB]>0)    // If one or more state components in phase
                            {
                                EndpointParamFlagsB = EndpointEventFinalStateDependMapG[phaB].mat[component].mat[comB];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 3: // Integral variable type
                            if (nqG[phaB]>0)    // If one or more integral components in phase
                            {
                                EndpointParamFlagsB = EndpointEventIntegralDependMapG[phaB].mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 4: // Initial time variable type
                            EndpointParamFlagsB = EndpointEventInitTimeDependMapG[phaB].mat[component].mat[0]; // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 5: // Final time variable type
                            EndpointParamFlagsB = EndpointEventFinalTimeDependMapG[phaB].mat[component].mat[0];    // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameters in phase
                            {
                                EndpointParamFlagsB = EndpointEventStaticDependMapG.mat[component].mat[comB];  // Extract indices of endpoint parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of event function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    EndpointParamFlags = MergeIntMatLists(EndpointParamFlagsA,EndpointParamFlagsB); // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(EndpointParamFlags.Len); param++)  // For each endpoint parameter flagged for computation
                    {
                        parametersMat.val[EndpointParamFlags.val[param]] = parametersMatSol.val[EndpointParamFlags.val[param]];    // Set double value to unperturbed double value
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersA(const int& phase, const int& component, const int& funcType, phaseInfo& phaseinfo, double* staticparameters, ParametersStruct& parametersStruct, const int& varA, const int& comA) // Perturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A CD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlagsA.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using double input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersA(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStruct& parametersStruct, const int& varA, const int& comA)  // Unperturb phase parameters used for computations in each phase of problem for first-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters A CD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    for (int param=0; param<(PhaseParamFlagsA.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.parametersMat[PhaseParamFlagsA.val[param]].Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlagsA.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlagsA.val[param]]; // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void PerturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, phaseInfo& phaseinfo, double* staticparameters, ParametersStruct& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB)  // Perturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB CD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct);
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        phase_parameters_func(PhaseSwitchG.val[phase],PhaseParamFlags.val[param],phaseinfo,staticparameters,parametersStruct); // Compute phase parameter param using double input
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void UnperturbPhaseParametersAB(const int& phase, const int& component, const int& funcType, ParametersStruct& parametersStructSol, ParametersStruct& parametersStruct, const int& varA, const int& comA, const int& varB, const int& comB) // Unperturb phase parameters used for computations in each phase of problem for second-derivative level partial
{
    //    printf("\nPerturbing Phase Parameters AB CD");
    
    if (ParameterDependenciesFlagG) // If parameter dependencies have been determined
    {
        intMat PhaseParamFlags;     // Holder for flags indicating which phase parameters need to be computed for partial
        intMat PhaseParamFlagsB;    // Holder for flags indicating which phase parameters need to be computed for partial B
        intMat PhaseParamFlagsA;    // Holder for flags indicating which phase parameters need to be computed for partial A
        
        switch (funcType)   // Function type
        {
            case 2: // Dynamic function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicStateDependMapG[phase].mat[component].mat[comA];    // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseDynamicControlDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseDynamicTimeDependMapG[phase].mat[component].mat[0];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicStateDependMapG[phase].mat[component].mat[comB];    // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseDynamicControlDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseDynamicStaticDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of dynamic function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++)   // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 3: // Path function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhasePathStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhasePathControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhasePathStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhasePathTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhasePathStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhasePathControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhasePathStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of path function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]];   // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            case 4: // Lagrange function
                if (nppG[phase]>0)  // If one or more phase parameter
                {
                    switch (varA)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsA = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comA];   // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsA = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comA]; // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsA = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comA];  // Extract indices of phase parameters that need to be computed for function variable combination for partial A
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varA);
                            break;
                    }
                    
                    switch (varB)
                    {
                        case -1:    // Time variable type
                            PhaseParamFlagsB = PhaseLagrangeTimeDependMapG[phase].mat[component].mat[0];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            break;
                            
                        case 1: // State variable type
                            if (nxG[phase]>0)   // If one or more state component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeStateDependMapG[phase].mat[component].mat[comB];   // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 2: // Control variable type
                            if (nuG[phase]>0)   // If one or more control component in phase
                            {
                                PhaseParamFlagsB = PhaseLagrangeControlDependMapG[phase].mat[component].mat[comB]; // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        case 6: // Static parameter variable type
                            if (nsG>0)  // If one or more static parameter
                            {
                                PhaseParamFlagsB = PhaseLagrangeStaticDependMapG[phase].mat[component].mat[comB];  // Extract indices of phase parameters that need to be computed for function variable combination for partial B
                            }
                            break;
                            
                        default:    // Unknown variable type
                            printf("\nPartial of lagrange function being taken with respect to unknown variable type = %d",varB);
                            break;
                    }
                    
                    PhaseParamFlags = MergeIntMatLists(PhaseParamFlagsA,PhaseParamFlagsB);  // Merge lists of endpoint parameters that need to be computed
                    
                    for (int param=0; param<(PhaseParamFlags.Len); param++) // For each phase parameter flagged for computation
                    {
                        for (int pt=0; pt<parametersStruct.Len; pt++) // For each point in phase
                        {
                            parametersStruct.parametersMat[pt].val[PhaseParamFlags.val[param]] = parametersStructSol.parametersMat[pt].val[PhaseParamFlags.val[param]]; // Set double value equal to unperturbed double value
                        }
                    }
                }
                break;
                
            default: // Unknown function
                printf("\nPartial of unknown function type = %d",funcType);
                break;
        }
    }
}

void GetSystemEndpointVariableStepSize(const int& phase, const int& var, const int& comp, systemInfo& systeminfosol, double& stepSize0, double& stepSize)   // Get system endpoint variable stepsize for derivative approximation
{
    // Compute appropriate stepsize
    switch (var)   // Variable type
    {
        case 1: // Initial state
            stepSize = stepSize0*(abs(systeminfosol.phaseinfo[phase].x0[comp])+1.0);    // Compute appropriate stepSize using variable magnitude
            break;
            
        case 2: // Final state
            stepSize = stepSize0*(abs(systeminfosol.phaseinfo[phase].xf[comp])+1.0);    // Compute appropriate stepSize using variable magnitude
            break;
            
        case 3: // Integral
            stepSize = stepSize0*(abs(systeminfosol.phaseinfo[phase].q[comp])+1.0); // Compute appropriate stepSize using variable magnitude
            break;
            
        case 4: // Initial Time
            stepSize = stepSize0*(abs(systeminfosol.phaseinfo[phase].t0)+1.0);  // Compute appropriate stepSize using variable magnitude
            break;
            
        case 5: // Final Time
            stepSize = stepSize0*(abs(systeminfosol.phaseinfo[phase].tf)+1.0);  // Compute appropriate stepSize using variable magnitude
            break;
            
        case 6: // Static parameter
            stepSize = stepSize0*(abs(systeminfosol.s[comp])+1.0);  // Compute appropriate stepSize using variable magnitude
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariablePlus(const int& phase, const int& var, const int& comp, systemInfo& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation by positive step
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp] = systeminfo.phaseinfo[phase].x0[comp] + stepSize; // Perturb initial state component comp in phase by positive step
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp] = systeminfo.phaseinfo[phase].xf[comp] + stepSize; // Perturb final state component comp in phase by positive step
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp] = systeminfo.phaseinfo[phase].q[comp] + stepSize;   // Perturb integral component comp at in phase by positive step
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0 = systeminfo.phaseinfo[phase].t0 + stepSize; // Perturb initial time at in phase by positive step
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf = systeminfo.phaseinfo[phase].tf + stepSize; // Perturb final time at in phase by positive step
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfo.s[comp] + stepSize; // Perturb static component comp at in phase by positive step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariableMinus(const int& phase, const int& var, const int& comp, systemInfo& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation by negative step
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp] = systeminfo.phaseinfo[phase].x0[comp] - stepSize; // Perturb initial state component comp in phase by negative step
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp] = systeminfo.phaseinfo[phase].xf[comp] - stepSize; // Perturb final state component comp in phase by negative step
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp] = systeminfo.phaseinfo[phase].q[comp] - stepSize;   // Perturb integral component comp at in phase by negative step
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0 = systeminfo.phaseinfo[phase].t0 - stepSize; // Perturb initial time at in phase by negative step
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf = systeminfo.phaseinfo[phase].tf - stepSize; // Perturb final time at in phase by negative step
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfo.s[comp] - stepSize; // Perturb static component comp at in phase by negative step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemEndpointVariable(const int& phase, const int& var, const int& comp, systemInfo& systeminfosol, systemInfo& systeminfo)    // Unperturb system endpoint variable
{
    
    // Unperturb variable component for desired partial
    switch (var)   // Variable type
    {
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp] = systeminfosol.phaseinfo[phase].x0[comp]; // Set initial state component comp in phase to unperturbed value
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp] = systeminfosol.phaseinfo[phase].xf[comp]; // Set final state component comp in phase to unperturbed value
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp] = systeminfosol.phaseinfo[phase].q[comp];   // Set integral component comp in phase to unperturbed value
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0 = systeminfosol.phaseinfo[phase].t0; // Set initial time in phase to unperturbed value
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf = systeminfosol.phaseinfo[phase].tf; // Set final time in phase to unperturbed value
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfosol.s[comp]; // Set static component comp to unperturbed value
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void GetSystemPhaseVariablesStepSizes(const int& phase, const int& var, const int& comp, systemInfo& systeminfosol, double& stepSize0, doubleMat& stepSizes)    // Get system phase variables step sizes for derivative approximation
{
    // Compute appropriate stepsize
    switch (var)   // Variable type
    {
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                stepSizes.val[pt] = stepSize0*(abs(systeminfosol.phaseinfo[phase].ptInfo[pt].t)+1.0);   // Compute appropriate stepSize using variable magnitude
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                stepSizes.val[pt] = stepSize0*(abs(systeminfosol.phaseinfo[phase].ptInfo[pt].x[comp])+1.0); // Compute appropriate stepSize using variable magnitude
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                stepSizes.val[pt] = stepSize0*(abs(systeminfosol.phaseinfo[phase].ptInfo[pt].u[comp])+1.0); // Compute appropriate stepSize using variable magnitude
            }
            break;
            
        case 6: // Static parameter
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                stepSizes.val[pt] = stepSize0*(abs(systeminfosol.s[comp])+1.0);  // Compute appropriate stepSize using variable magnitude
            }
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesPlus(const int& phase, const int& var, const int& comp, systemInfo& systeminfo, doubleMat& stepSizes) // Perturb system phase variables for derivative approximation by positive step
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t = systeminfo.phaseinfo[phase].ptInfo[pt].t + stepSizes.val[pt];    // Perturb time at pt in phase by positive step
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp] = systeminfo.phaseinfo[phase].ptInfo[pt].x[comp] + stepSizes.val[pt];    // Perturb state component comp at pt in phase by positive step
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp] = systeminfo.phaseinfo[phase].ptInfo[pt].u[comp] + stepSizes.val[pt];    // Perturb control component comp at pt in phase by positive step
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfo.s[comp] + stepSizes.val[0]; // Perturb static component comp in phase by positive step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesMinus(const int& phase, const int& var, const int& comp, systemInfo& systeminfo, doubleMat& stepSizes)    // Perturb system phase variables for derivative approximation by negative step
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t = systeminfo.phaseinfo[phase].ptInfo[pt].t - stepSizes.val[pt];    // Perturb time at pt in phase by negative step
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp] = systeminfo.phaseinfo[phase].ptInfo[pt].x[comp] - stepSizes.val[pt];    // Perturb state component comp at pt in phase by negative step
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp] = systeminfo.phaseinfo[phase].ptInfo[pt].u[comp] - stepSizes.val[pt];    // Perturb control component comp at pt in phase by negative step
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfo.s[comp] - stepSizes.val[0]; // Perturb static component comp in phase by negative step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemPhaseVariables(const int& phase, const int& var, const int& comp, systemInfo& systeminfosol, systemInfo& systeminfo, doubleMat& stepSizes)  // Unperturb system phase variables
{
    
    // Unperturb variable component for desired partial
    switch (var)   // Variable type
    {
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t = systeminfosol.phaseinfo[phase].ptInfo[pt].t; // Unperturb time at pt in phase
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp] = systeminfosol.phaseinfo[phase].ptInfo[pt].x[comp]; // Unperturb state component comp at pt in phase
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp] = systeminfosol.phaseinfo[phase].ptInfo[pt].u[comp]; // Unperturb control component comp at pt in phase
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp] = systeminfosol.s[comp]; // Unperturb static component comp in phase
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariableI1(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation in I1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Perturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].I1 = stepSize; // Perturb initial state component comp in phase in I1 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].I1 = stepSize; // Perturb final state component comp in phase in I1 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].I1 = stepSize;   // Perturb integral component comp at in phase in I1 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.I1 = stepSize; // Perturb initial time at in phase in I1 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.I1 = stepSize; // Perturb final time at in phase in I1 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I1 = stepSize; // Perturb static component comp at in phase in I1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariableI2(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation in I2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Perturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].I2 = stepSize; // Perturb initial state component comp in phase in I2 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].I2 = stepSize; // Perturb final state component comp in phase in I2 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].I2 = stepSize;   // Perturb integral component comp at in phase in I2 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.I2 = stepSize; // Perturb initial time at in phase in I2 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.I2 = stepSize; // Perturb final time at in phase in I2 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I2 = stepSize; // Perturb static component comp at in phase in I2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemEndpointVariableI1(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo) // Unperturb system endpoint variable in I1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Unperturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].I1 = 0;    // Unperturb initial state component comp in phase in I1 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].I1 = 0;    // Unperturb final state component comp in phase in I1 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].I1 = 0; // Unperturb integral component comp at in phase in I1 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.I1 = 0;  // Unperturb initial time at in phase in I1 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.I1 = 0;  // Unperturb final time at in phase in I1 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I1 = 0;  // Unperturb static component comp at in phase in I1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemEndpointVariableI2(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo) // Unperturb system endpoint variable in I2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Unperturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].I2 = 0;    // Unperturb initial state component comp in phase in I2 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].I2 = 0;    // Unperturb final state component comp in phase in I2 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].I2 = 0; // Unperturb integral component comp at in phase in I2 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.I2 = 0;  // Unperturb initial time at in phase in I2 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.I2 = 0;  // Unperturb final time at in phase in I2 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I2 = 0;  // Unperturb static component comp at in phase in I2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesI1(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, doubleMat& stepSizes) // Perturb system phase variables for derivative approximation in I1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Perturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.I1 = stepSizes.val[pt];    // Perturb time at pt in phase in I1 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].I1 = stepSizes.val[pt];  // Perturb state component comp at pt in phase in I1 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].I1 = stepSizes.val[pt];  // Perturb control component comp at pt in phase in I1 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I1 = stepSizes.val[0];   // Perturb static component comp in phase in I1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesI2(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, doubleMat& stepSizes) // Perturb system phase variables for derivative approximation in I2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Perturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.I2 = stepSizes.val[pt];    // Perturb time at pt in phase in I2 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].I2 = stepSizes.val[pt];  // Perturb state component comp at pt in phase in I2 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].I2 = stepSizes.val[pt];  // Perturb control component comp at pt in phase in I2 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I2 = stepSizes.val[0];   // Perturb static component comp in phase in I2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemPhaseVariablesI1(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, doubleMat& stepSizes)   // Unperturb system phase variables in I1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Unperturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.I1 = 0;    // Unperturb time at pt in phase in I1 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].I1 = 0;  // Unperturb state component comp at pt in phase in I1 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].I1 = 0;  // Unperturb control component comp at pt in phase in I1 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I1 = 0;  // Unperturb static component comp in phase in I1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemPhaseVariablesI2(const int& phase, const int& var, const int& comp, systemInfoBC& systeminfo, doubleMat& stepSizes)   // Unperturb system phase variables in I2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Unperturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.I2 = 0;    // Unperturb time at pt in phase in I2 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].I2 = 0;  // Unperturb state component comp at pt in phase in I2 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].I2 = 0;  // Unperturb control component comp at pt in phase in I2 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].I2 = 0;  // Unperturb static component comp in phase in I2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariableE1(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation in E1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Perturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].E1 = stepSize; // Perturb initial state component comp in phase in E1 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].E1 = stepSize; // Perturb final state component comp in phase in E1 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].E1 = stepSize;   // Perturb integral component comp at in phase in E1 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.E1 = stepSize; // Perturb initial time at in phase in E1 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.E1 = stepSize; // Perturb final time at in phase in E1 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E1 = stepSize; // Perturb static component comp at in phase in E1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemEndpointVariableE2(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, double& stepSize)   // Perturb system endpoint variable for derivative approximation in E2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Perturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].E2 = stepSize; // Perturb initial state component comp in phase in E2 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].E2 = stepSize; // Perturb final state component comp in phase in E2 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].E2 = stepSize;   // Perturb integral component comp at in phase in E2 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.E2 = stepSize; // Perturb initial time at in phase in E2 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.E2 = stepSize; // Perturb final time at in phase in E2 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E2 = stepSize; // Perturb static component comp at in phase in E2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemEndpointVariableE1(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo) // Unperturb system endpoint variable in E1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Unperturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].E1 = 0;    // Unperturb initial state component comp in phase in E1 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].E1 = 0;    // Unperturb final state component comp in phase in E1 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].E1 = 0; // Unperturb integral component comp at in phase in E1 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.E1 = 0;  // Unperturb initial time at in phase in E1 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.E1 = 0;  // Unperturb final time at in phase in E1 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E1 = 0;  // Unperturb static component comp at in phase in E1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemEndpointVariableE2(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo) // Unperturb system endpoint variable in E2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -1: // Unperturbing endpoint parameter
            // Do nothing
            break;
            
        case 1: // Initial state
            systeminfo.phaseinfo[phase].x0[comp].E2 = 0;    // Unperturb initial state component comp in phase in E2 direction
            break;
            
        case 2: // Final state
            systeminfo.phaseinfo[phase].xf[comp].E2 = 0;    // Unperturb final state component comp in phase in E2 direction
            break;
            
        case 3: // Integral
            systeminfo.phaseinfo[phase].q[comp].E2 = 0; // Unperturb integral component comp at in phase in E2 direction
            break;
            
        case 4: // Initial Time
            systeminfo.phaseinfo[phase].t0.E2 = 0;  // Unperturb initial time at in phase in E2 direction
            break;
            
        case 5: // Final Time
            systeminfo.phaseinfo[phase].tf.E2 = 0;  // Unperturb final time at in phase in E2 direction
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E2 = 0;  // Unperturb static component comp at in phase in E2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesE1(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, doubleMat& stepSizes) // Perturb system phase variables for derivative approximation in E1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Perturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.E1 = stepSizes.val[pt];    // Perturb time at pt in phase in E1 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].E1 = stepSizes.val[pt];  // Perturb state component comp at pt in phase in E1 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].E1 = stepSizes.val[pt];  // Perturb control component comp at pt in phase in E1 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E1 = stepSizes.val[0];   // Perturb static component comp in phase in E1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void PerturbSystemPhaseVariablesE2(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, doubleMat& stepSizes) // Perturb system phase variables for derivative approximation in E2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Perturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.E2 = stepSizes.val[pt];    // Perturb time at pt in phase in E2 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].E2 = stepSizes.val[pt];  // Perturb state component comp at pt in phase in E2 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].E2 = stepSizes.val[pt];  // Perturb control component comp at pt in phase in E2 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E2 = stepSizes.val[0];   // Perturb static component comp in phase in E2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemPhaseVariablesE1(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, doubleMat& stepSizes)   // Unperturb system phase variables in E1 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Unperturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.E1 = 0;    // Unperturb time at pt in phase in E1 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].E1 = 0;  // Unperturb state component comp at pt in phase in E1 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].E1 = 0;  // Unperturb control component comp at pt in phase in E1 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E1 = 0;  // Unperturb static component comp in phase in E1 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void UnperturbSystemPhaseVariablesE2(const int& phase, const int& var, const int& comp, systemInfoHD& systeminfo, doubleMat& stepSizes)   // Unperturb system phase variables in E2 direction
{
    
    // Perturb variable component for desired partial using positive step
    switch (var)   // Variable type
    {
        case -2: // Unperturbing phase parameter
            // Do nothing
            break;
            
        case -1: // Time
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].t.E2 = 0;    // Unperturb time at pt in phase in E2 direction
            }
            break;
            
        case 1: //  State
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].x[comp].E2 = 0;  // Unperturb state component comp at pt in phase in E2 direction
            }
            break;
            
        case 2: // Control
            for (int pt=0; pt<stepSizes.Len; pt++)  // For each discretization point in phase
            {
                systeminfo.phaseinfo[phase].ptInfo[pt].u[comp].E2 = 0;  // Unperturb control component comp at pt in phase in E2 direction
            }
            break;
            
        case 6: // Static parameter
            systeminfo.s[comp].E2 = 0;  // Unperturb static component comp in phase in E2 direction
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

void SetIndependentSystemEndpointVariable(const int& phase, const int& var, const int& comp, double& xp, systemInfo& systeminfosol) // Set independent system endpoint variable for algorithmic differentiation
{
    
    // Declare independent variable component for desired partial
    switch (var)   // Variable type
    {
        case 1: // Initial state
            xp = systeminfosol.phaseinfo[phase].x0[comp];   // Set independent initial state component comp in phase by positive step
            break;
            
        case 2: // Final state
            xp = systeminfosol.phaseinfo[phase].xf[comp];   // Set independent final state component comp in phase by positive step
            break;
            
        case 3: // Integral
            xp = systeminfosol.phaseinfo[phase].q[comp]; // Set independent integral component comp at in phase by positive step
            break;
            
        case 4: // Initial Time
            xp = systeminfosol.phaseinfo[phase].t0;   // Set independent initial time at in phase by positive step
            break;
            
        case 5: // Final Time
            xp = systeminfosol.phaseinfo[phase].tf;   // Set independent final time at in phase by positive step
            break;
            
        case 6: // Static parameter
            xp = systeminfosol.s[comp];   // Set independent static component comp at in phase by positive step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}


void SetIndependentSystemPhaseVariable(const int& phase, const int& point, const int& var, const int& comp, double& yp, double* xp, double* up, double tp, double* sp, double* pp)  // Set independent system phase variable for algorithmic differentiation
{
    
    // Declare independent variable component for desired partial
    switch (var)   // Variable type
    {
        case 1: // state
            yp = xp[comp];  // Set independent initial state component comp in phase by positive step
            break;
            
        case 2: // control
            yp = up[comp];  // Set independent final state component comp in phase by positive step
            break;
            
        case -1: // time
            yp = tp;    // Set independent initial time at in phase by positive step
            break;
            
        case -2: // phase parameter
            yp = pp[comp];  // Set independent final time at in phase by positive step
            break;
            
        case 6: // Static parameter
            yp = sp[comp];  // Set independent static component comp at in phase by positive step
            break;
            
        default:    // Unknown variable type
            printf("\nTaking partial of function in phase %d wrt unknown variable type %d",phase+1,var);
            break;
    }
}

intMat MergeIntMatLists(const intMat& list1, const intMat& list2)   // Merge integer sets of two intMats (must be in numerical order, no repeating numbers)
{
    intMat newList;     // Merged list to be returned
    intMat tempList;    // Temporary list for holding values when updating newList
    int ind1=0, ind2=0; // Index values for lists
    int longlist;       // Holder for which list is longer
    
    if (list1.Len>=list2.Len)   // If length of list1 is as longer or longer than list2
    {
        newList = list1;    // Set newlist equal to list1
        longlist = 1;       // Set longlist to 1
    }
    else    // list2 is longer than list1
    {
        newList = list2;    // Set newList equal to list2
        longlist = 2;       // Set longlist to 2
    }
    
    switch (longlist)
    {
        case 1:
            while ((ind1<newList.Len)&&(ind2<list2.Len))    // While indices of lists are both within range of lists
            {
//                printf("\nlist2.val[%d] = %d  |  newList.val[%d] = %d");
                if (list2.val[ind2]<newList.val[ind1])  // If current integer in list2 is less than current integer in newList
                {
                    tempList = newList; // Set tempList equal to current newList
                    newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                    for (int currind=0; currind<ind1; currind++)    // For each index before current index of newList
                    {
                        newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                    }
                    newList.val[ind1] = list2.val[ind2];    // Set to current value of list2
                    for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                    {
                        newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                    }
                    ind1++; // Increment newList index to next element
                    ind2++; // Increment list2 index to next element
                }
                else if (list2.val[ind2]==newList.val[ind1])    // If current integer in list2 is equal to current integer in newList
                {
                    ind1++; // Increment newList index to next element
                    ind2++; // Increment list2 index to next element
                }
                else if (list2.val[ind2]>newList.val[ind1]) // If current integer in list2 is greater than current integer in newList
                {
                    ind1++; // Increment newList index to next element
                }
            }
            
            if (ind1==newList.Len)  // Reached end of newList
            {
                while (ind2<list2.Len)  // While ind2 is within range of list2
                {
                    if (list2.val[ind2]>newList.val[ind1-1])    // If current integer in list2 is greater than current integer in newList
                    {
                        tempList = newList; // Set tempList equal to current newList
                        newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                        for (int currind=0; currind<ind1; currind++)    // For each index up to current index of newList
                        {
                            newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                        }
                        newList.val[ind1] = list2.val[ind2];  // Set to current value of list2
                        for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                        {
                            newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                        }
                        ind1++; // Increment newList index to next element
                        ind2++; // Increment list2 index to next element
                    }
                    else if (list2.val[ind2]<newList.val[ind1-1])   // If current integer in list2 is less than current integer in newList (shouldn't happen...)
                    {
                        tempList = newList; // Set tempList equal to current newList
                        newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                        for (int currind=0; currind<ind1; currind++)    // For each index up to current index of newList
                        {
                            newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                        }
                        newList.val[ind1] = list2.val[ind2];    // Set to current value of list2
                        for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                        {
                            newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                        }
                        ind1++; // Increment newList index to next element
                        ind2++; // Increment list2 index to next element
                    }
                    else if (list2.val[ind2]==newList.val[ind1-1])  // If current integer in list2 is equal to current integer in newList (shouldn't happen...)
                    {
                        ind2++; // Increment list2 index to next element
                    }
                }
            }
            else if (ind2==list2.Len)   // Reached end of list2
            {
                // Finished merging lists
            }
            break;
            
        case 2:
            while ((ind1<newList.Len)&&(ind2<list1.Len))    // While indices of lists are both within range of lists
            {
                if (list1.val[ind2]<newList.val[ind1])  // If current integer in list1 is less than current integer in newList
                {
                    tempList = newList; // Set tempList equal to current newList
                    newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                    for (int currind=0; currind<ind1; currind++)    // For each index before current index of newList
                    {
                        newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                    }
                    newList.val[ind1] = list1.val[ind2];    // Set to current value of list1
                    for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                    {
                        newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                    }
                    ind1++; // Increment newList index to next element
                    ind2++; // Increment list1 index to next element
                }
                else if (list1.val[ind2]==newList.val[ind1])    // If current integer in list1 is equal to current integer in newList
                {
                    ind1++; // Increment newList index to next element
                    ind2++; // Increment list1 index to next element
                }
                else if (list1.val[ind2]>newList.val[ind1]) // If current integer in list1 is greater than current integer in newList
                {
                    ind1++; // Increment newList index to next element
                }
            }
            
            if (ind1==newList.Len)  // Reached end of newList
            {
                while (ind2<list1.Len)  // While ind2 is within range of list1
                {
                    if (list1.val[ind2]>newList.val[ind1-1])    // If current integer in list1 is greater than current integer in newList
                    {
                        tempList = newList; // Set tempList equal to current newList
                        newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                        for (int currind=0; currind<ind1; currind++)  // For each index before current index of newList
                        {
                            newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                        }
                        newList.val[ind1] = list1.val[ind2];    // Set to current value of list1
                        for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                        {
                            newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                        }
                        ind1++; // Increment newList index to next element
                        ind2++; // Increment list1 index to next element
                    }
                    else if (list1.val[ind2]<newList.val[ind1-1])   // If current integer in list1 is less than current integer in newList (shouldn't happen...)
                    {
                        tempList = newList; // Set tempList equal to current newList
                        newList = getIntMat(newList.Len+1); // Allocate memory for current length of newList plus one
                        for (int currind=0; currind<ind1; currind++)    // For each index before current index of newList
                        {
                            newList.val[currind] = tempList.val[currind];   // Extract values from tempList
                        }
                        newList.val[ind1] = list1.val[ind2];    // Set to current value of list1
                        for (int currind=(ind1+1); currind<newList.Len; currind++)  // For each index equal to and after current index of newlist
                        {
                            newList.val[currind] = tempList.val[currind-1]; // Extract values from tempList
                        }
                        ind1++; // Increment newList index to next element
                        ind2++; // Increment list1 index to next element
                    }
                    else if (list1.val[ind2]==newList.val[ind1-1])  // If current integer in list1 is equal to current integer in newList (shouldn't happen...)
                    {
                        ind2++; // Increment list1 index to next element
                    }
                }
            }
            else if (ind2==list1.Len)   // Reached end of list1
            {
                // Finished merging lists
            }
            break;
            
        default:
            break;
    }
    
    return newList;
}


////////////////////////////////////////////////////////////////////////////////////////////////
//---------------------------------------Output File functions--------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////

void CGPOPS_IPOPT_solution_saver(int TempFlag)  // Save CGPOPS IPOPT solution to m-script
{
//    double myFloat=69.96;
//    char buffer[64];
//    int ret = snprintf(buffer, sizeof buffer, "%.15f", myFloat);
//
//    if (ret)
//    {
//        printf("\nret = %d",ret);
//        printf("\n");
//        for (int c=0; c<strlen(buffer); c++)
//        {
//            printf("%c",buffer[c]);
//        }
//        printf("\n%s",buffer);
//    }
    
//    double myDub = 69.96;
//    int myInt = 101;
    char dubvalstr[64];
    char intvalstr[64];
    int retdub, retint;
    
//    int retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.15f", myDub);
//    int retint = snprintf(intvalstr, sizeof intvalstr, "%d", myInt);
//
//    char fileName[] = "../output/testfilename.m";
    
//    char newFileName[] = "../output/cgpopsIPOPTSolution.m";
    char newFileName[45];
    char tempFileName[45];
    char systemstr[10];
    int retsys;
//    char systemstr[] = "\nsystem";
    char phasestr[] = ".phase(";
    char ptstr[] = ").point(";
    char statestr[] = ").x(";
    char controlstr[] = ").u(";
    char timestr[] = ").t.point(";
    char taustr[] = ").tau.point(";
    char lambdastr[] = ").lam(";
    char integralstr[] = ").q(";
    char initstatestr[] = ").x0(";
    char finalstatestr[] = ").xf(";
    char inittimestr[] = ").t0";
    char finaltimestr[] = ").tf";
    char staticstr[] = ".s(";
    FILE* fd = NULL;
    int retfw;
    int egnum=0;
    char nxstr[] = "\nnx(";
    char nustr[] = "\nnu(";
    char nqstr[] = "\nnq(";
    char nsstr[] = "\nns";
    char Ntstr[] = "\nNt(";
    char initnumintervalstr[] = "initnuminterval";
    char initcolptsstr[] = "initcolpts";
    char currnumintervalstr[] = "currnuminterval";
    char currcolptsstr[] = "currcolpts";
    int newfileflag=1;
    char iteripoptstr[] = "iterIPOPT";
    char objipoptstr[] = "NLPobjIPOPT";
    char runtimestr[] = "runTimeIPOPT";
    char endpointparameterstr[] = ".parameter(";
    char phaseparameterstr[] = ").parameter(";
    char lavrentievstr[] = "LavrentievConstraintFlagG";
    char newFileNameBin[45];
    
    if (TempFlag==1)
    {
        if (derivativeSupplierG==0)
        {
            retsys = snprintf(newFileName, sizeof newFileName, "../output/cgpopsIPOPTSolutionHD.m");
            retsys = snprintf(systemstr, sizeof systemstr, "\nsystemHD");
            
            fd = fopen(newFileName,"r");
            if(NULL == fd)
            {
                //                printf("\n fopen() Error!!!\n");
                newfileflag=1;
                retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/cgpopsIPOPTSolutionHD.bin");
            }
            else
            {
                //                printf("\nFile opened successfully through fopen()\n");
                fclose(fd);
                //                printf("\n File stream closed through fclose()\n");
                
                retsys = snprintf(tempFileName, sizeof tempFileName, "cgpopsIPOPTSolutionHD");
            }
            while (newfileflag==0)
            {
                retsys = snprintf(newFileName, sizeof newFileName, "../output/%s%d.m", tempFileName, egnum);
                
                fd = fopen(newFileName,"r");
                if(NULL == fd)
                {
                    //                    printf("\n fopen() Error!!!\n");
                    newfileflag=1;
                    retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/%s%d.bin", tempFileName, egnum);
                }
                else
                {
                    //                    printf("\nFile opened successfully through fopen()\n");
                    fclose(fd);
                    //                    printf("\n File stream closed through fclose()\n");
                    egnum++;
                }
            }
        }
        else if (derivativeSupplierG==1)
        {
            retsys = snprintf(newFileName, sizeof newFileName, "../output/cgpopsIPOPTSolutionBC.m");
            retsys = snprintf(systemstr, sizeof systemstr, "\nsystemBC");
            
            fd = fopen(newFileName,"r");
            if(NULL == fd)
            {
//                printf("\n fopen() Error!!!\n");
                newfileflag=1;
                retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/cgpopsIPOPTSolutionBC.bin");
            }
            else
            {
//                printf("\nFile opened successfully through fopen()\n");
                fclose(fd);
//                printf("\n File stream closed through fclose()\n");
                
                retsys = snprintf(tempFileName, sizeof tempFileName, "cgpopsIPOPTSolutionBC");
            }
            while (newfileflag==0)
            {
                retsys = snprintf(newFileName, sizeof newFileName, "../output/%s%d.m", tempFileName, egnum);
                
                fd = fopen(newFileName,"r");
                if(NULL == fd)
                {
//                    printf("\n fopen() Error!!!\n");
                    newfileflag=1;
                    retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/%s%d.bin", tempFileName, egnum);
                }
                else
                {
//                    printf("\nFile opened successfully through fopen()\n");
                    fclose(fd);
//                    printf("\n File stream closed through fclose()\n");
                    egnum++;
                }
            }
        }
        else if (derivativeSupplierG==2)
        {
            retsys = snprintf(newFileName, sizeof newFileName, "../output/cgpopsIPOPTSolutionCD.m");
            retsys = snprintf(systemstr, sizeof systemstr, "\nsystemCD");
            
            fd = fopen(newFileName,"r");
            if(NULL == fd)
            {
//                printf("\n fopen() Error!!!\n");
                newfileflag=1;
                retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/cgpopsIPOPTSolutionCD.bin");
            }
            else
            {
//                printf("\nFile opened successfully through fopen()\n");
                fclose(fd);
//                printf("\n File stream closed through fclose()\n");
                
                retsys = snprintf(tempFileName, sizeof tempFileName, "cgpopsIPOPTSolutionCD");
            }
            while (newfileflag==0)
            {
                retsys = snprintf(newFileName, sizeof newFileName, "../output/%s%d.m", tempFileName, egnum);
                
                fd = fopen(newFileName,"r");
                if(NULL == fd)
                {
//                    printf("\n fopen() Error!!!\n");
                    newfileflag=1;
                    retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/%s%d.bin", tempFileName, egnum);
                }
                else
                {
//                    printf("\nFile opened successfully through fopen()\n");
                    fclose(fd);
//                    printf("\n File stream closed through fclose()\n");
                    egnum++;
                }
            }
        }
        else if (derivativeSupplierG==3)
        {
            retsys = snprintf(newFileName, sizeof newFileName, "../output/cgpopsIPOPTSolutionCN.m");
            retsys = snprintf(systemstr, sizeof systemstr, "\nsystemCN");
            
            fd = fopen(newFileName,"r");
            if(NULL == fd)
            {
                //                printf("\n fopen() Error!!!\n");
                newfileflag=1;
                retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/cgpopsIPOPTSolutionCN.bin");
            }
            else
            {
                //                printf("\nFile opened successfully through fopen()\n");
                fclose(fd);
                //                printf("\n File stream closed through fclose()\n");
                
                retsys = snprintf(tempFileName, sizeof tempFileName, "cgpopsIPOPTSolutionCN");
            }
            while (newfileflag==0)
            {
                retsys = snprintf(newFileName, sizeof newFileName, "../output/%s%d.m", tempFileName, egnum);
                
                fd = fopen(newFileName,"r");
                if(NULL == fd)
                {
                    //                    printf("\n fopen() Error!!!\n");
                    newfileflag=1;
                    retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/%s%d.bin", tempFileName, egnum);
                }
                else
                {
                    //                    printf("\nFile opened successfully through fopen()\n");
                    fclose(fd);
                    //                    printf("\n File stream closed through fclose()\n");
                    egnum++;
                }
            }
        }
        if (sysinfosolG.NumP>PorigG)
        {
//            printf("\n\n\nsysinfosolG:");
//            printf(sysinfosolG);
//            printf("\nPorigG = %d",PorigG);
//            printf4MATLAB("PhaseSwitchG",PhaseSwitchG);
            int NumD[PorigG];
            for (int p=0; p<PorigG; p++)
            {
                NumD[p] = 0;
                for (int d=0; d<PhaseSwitchG.Len; d++)
                {
                    if (PhaseSwitchG.val[d]==p)
                    {
                        NumD[p] = NumD[p] + 1;
                    }
                }
//                printf("\nNumD[%d] = %d",p,NumD[p]);
            }
            sysinfodomainG = sysinfosolG;
//            printf(sysinfodomainG);
//            systemInfo systemextract;
//            systemextract = extractSystemInfo(sysinfodomainG,PorigG,NumD);
            sysinfosolG = extractSystemInfo(sysinfodomainG,PorigG,NumD);
//            printf("\n\n\nsystemextract:");
//            printf(systemextract);
        }
    }
    else
    {
        retsys = snprintf(newFileName, sizeof newFileName, "../output/cgpopsIPOPTSolution.m");
        retsys = snprintf(systemstr, sizeof systemstr, "\nsystem");
        
        fd = fopen(newFileName,"r");
        if(NULL == fd)
        {
            //            printf("\n fopen() Error!!!\n");
            newfileflag=1;
            retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/cgpopsIPOPTSolution.bin");
        }
        else
        {
//            printf("\nFile opened successfully through fopen()\n");
            fclose(fd);
//            printf("\n File stream closed through fclose()\n");
            
            retsys = snprintf(tempFileName, sizeof tempFileName, "cgpopsIPOPTSolution");
        }
        while (newfileflag==0)
        {
            retsys = snprintf(newFileName, sizeof newFileName, "../output/%s%d.m", tempFileName, egnum);
            
            fd = fopen(newFileName,"r");
            if(NULL == fd)
            {
//                printf("\n fopen() Error!!!\n");
                newfileflag=1;
                retsys = snprintf(newFileNameBin, sizeof newFileNameBin, "../output/%s%d.bin", tempFileName, egnum);
            }
            else
            {
//                printf("\nFile opened successfully through fopen()\n");
                fclose(fd);
//                printf("\n File stream closed through fclose()\n");
                egnum++;
            }
        }
    }
    
    fd = fopen(newFileName,"w");
    if(NULL == fd)
    {
        printf("\n fopen() Error!!!\n");
    }
    else
    {
//        printf("\n File opened successfully through fopen()\n");
    }
    
    retfw = (int) fwrite("\%\% ", 3, 1, fd);
    retfw = (int) fwrite(newFileName,strlen(newFileName),1,fd);
    
    retfw = (int) fwrite("\n\% ", 3, 1, fd);
    retfw = (int) fwrite(initnumintervalstr, strlen(initnumintervalstr), 1, fd);
    retfw = (int) fwrite(" = ", 3, 1, fd);
    retint = snprintf(intvalstr, sizeof intvalstr, "%d", numintervalsG);
    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
    retfw = (int) fwrite(", ", 2, 1, fd);
    retfw = (int) fwrite(initcolptsstr, strlen(initcolptsstr), 1, fd);
    retfw = (int) fwrite(" = ", 3, 1, fd);
    retint = snprintf(intvalstr, sizeof intvalstr, "%d", initcolptsG);
    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
    
    for (int p=0; p<sysinfosolG.NumP; p++)
    {
        retfw = (int) fwrite("\n\% Phase = ", 11, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", p);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(", ", 2, 1, fd);
        retfw = (int) fwrite(currnumintervalstr, strlen(currnumintervalstr), 1, fd);
        retfw = (int) fwrite(" = ", 3, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", rpmdG[p].NumInterval);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(", ", 2, 1, fd);
        retfw = (int) fwrite(currcolptsstr, strlen(currcolptsstr), 1, fd);
        retfw = (int) fwrite(" = ", 3, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", rpmdG[p].sumColPoints);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
    }
                                                               
    retfw = (int) fwrite("\n\% ", 3, 1, fd);
    retfw = (int) fwrite(lavrentievstr, strlen(lavrentievstr), 1, fd);
    retfw = (int) fwrite(" = ", 3, 1, fd);
    retint = snprintf(intvalstr, sizeof intvalstr, "%d", LavrentievConstraintFlagG);
    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
    retfw = (int) fwrite("\n\% MeshIterG = ", 15, 1, fd);
    retint = snprintf(intvalstr, sizeof intvalstr, "%d", MeshIterG);
    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);

    if (derivativeSupplierG==0)
    {
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(iteripoptstr, strlen(iteripoptstr), 1, fd);
        retfw = (int) fwrite("HD = ", 5, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", iterIPOPTG);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(objipoptstr, strlen(objipoptstr), 1, fd);
        retfw = (int) fwrite("HD = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", ipoptNLPObjG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(runtimestr, strlen(runtimestr), 1, fd);
        retfw = (int) fwrite("HD = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", runtimeG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
    }
    else if (derivativeSupplierG==1)
    {
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(iteripoptstr, strlen(iteripoptstr), 1, fd);
        retfw = (int) fwrite("BC = ", 5, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", iterIPOPTG);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(objipoptstr, strlen(objipoptstr), 1, fd);
        retfw = (int) fwrite("BC = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", ipoptNLPObjG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(runtimestr, strlen(runtimestr), 1, fd);
        retfw = (int) fwrite("BC = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", runtimeG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
    }
    else if (derivativeSupplierG==2)
    {
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(iteripoptstr, strlen(iteripoptstr), 1, fd);
        retfw = (int) fwrite("CD = ", 5, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", iterIPOPTG);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(objipoptstr, strlen(objipoptstr), 1, fd);
        retfw = (int) fwrite("CD = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", ipoptNLPObjG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(runtimestr, strlen(runtimestr), 1, fd);
        retfw = (int) fwrite("CD = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", runtimeG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
    }
    else if (derivativeSupplierG==3)
    {
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(iteripoptstr, strlen(iteripoptstr), 1, fd);
        retfw = (int) fwrite("CN = ", 5, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", iterIPOPTG);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(objipoptstr, strlen(objipoptstr), 1, fd);
        retfw = (int) fwrite("CN = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", ipoptNLPObjG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite("\n", 1, 1, fd);
        retfw = (int) fwrite(runtimestr, strlen(runtimestr), 1, fd);
        retfw = (int) fwrite("CN = ", 5, 1, fd);
        retint = snprintf(dubvalstr, sizeof dubvalstr, "%.25e", runtimeG);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
    }
    
    retfw = (int) fwrite("\n\n", 2, 1, fd);
    

    for (int phase=0; phase<sysinfosolG.NumP; phase++)    // For each phase in problem
    {
        retfw = (int) fwrite(nxstr, strlen(nxstr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(") = ", 4, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", nxG[phase]);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite(nustr, strlen(nustr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(") = ", 4, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", nuG[phase]);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite(nqstr, strlen(nqstr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(") = ", 4, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", nqG[phase]);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        retfw = (int) fwrite(Ntstr, strlen(Ntstr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(") = ", 4, 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", sysinfosolG.phaseinfo[phase].NumColPts);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
    }
    retfw = (int) fwrite(nsstr, strlen(nsstr), 1, fd);
    retfw = (int) fwrite(" = ", 3, 1, fd);
    retint = snprintf(intvalstr, sizeof intvalstr, "%d", nsG);
    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
    retfw = (int) fwrite(";", 1, 1, fd);
    
    for (int phase=0; phase<sysinfosolG.NumP; phase++)    // For each phase in problem
    {
        if (sysinfosolG.phaseinfo[phase].NumX) // If one or more state component in phase
        {
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumX; comp++)    // For each state component in phase
            {
                for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++) // For each discretization point in phase
                {
                    retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].ptInfo[pt].x[comp]);
                    retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                    retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(statestr, strlen(statestr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(ptstr, strlen(ptstr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(") = ", 4, 1, fd);
                    retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                    retfw = (int) fwrite(";", 1, 1, fd);
                }
            }
            
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumX; comp++)    // For each state component in phase
            {
                for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++) // For each discretization point in phase
                {
                    retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].ptInfo[pt].lam[comp]);
                    retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                    retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(lambdastr, strlen(lambdastr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(ptstr, strlen(ptstr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(") = ", 4, 1, fd);
                    retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                    retfw = (int) fwrite(";", 1, 1, fd);
                }
            }
        }
        
        if (sysinfosolG.phaseinfo[phase].NumU) // If one or more control component in phase
        {
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumU; comp++)   // For each control component in phase
            {
                for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++) // For each discretization point in phase
                {
                    retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].ptInfo[pt].u[comp]);
                    retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                    retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(controlstr, strlen(controlstr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(ptstr, strlen(ptstr), 1, fd);
                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                    retfw = (int) fwrite(") = ", 4, 1, fd);
                    retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                    retfw = (int) fwrite(";", 1, 1, fd);
                }
            }
        }
        
        for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++) // For each discretization point in phase
        {
            retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].ptInfo[pt].t);
            retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
            retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
            retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
            retfw = (int) fwrite(timestr, strlen(timestr), 1, fd);
            retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
            retfw = (int) fwrite(") = ", 4, 1, fd);
            retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
            retfw = (int) fwrite(";", 1, 1, fd);
        }
        
        for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++) // For each discretization point in phase
        {
            retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].ptInfo[pt].tau);
            retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
            retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
            retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
            retfw = (int) fwrite(taustr, strlen(taustr), 1, fd);
            retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
            retfw = (int) fwrite(") = ", 4, 1, fd);
            retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
            retfw = (int) fwrite(";", 1, 1, fd);
        }
        
        if (sysinfosolG.phaseinfo[phase].NumX) // If one or more state component in phase
        {
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumX; comp++)   // For each state component in phase
            {
                retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].x0[comp]);
                retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(initstatestr, strlen(initstatestr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(") = ", 4, 1, fd);
                retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                retfw = (int) fwrite(";", 1, 1, fd);
            }
            
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumX; comp++)   // For each state component in phase
            {
                retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].xf[comp]);
                retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(finalstatestr, strlen(finalstatestr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(") = ", 4, 1, fd);
                retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                retfw = (int) fwrite(";", 1, 1, fd);
            }
        }
        
        if (sysinfosolG.phaseinfo[phase].NumQ) // If one or more integral component in phase
        {
            for (int comp=0; comp<sysinfosolG.phaseinfo[phase].NumQ; comp++)   // For each integral component in phase
            {
                retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].q[comp]);
                retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
                retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(integralstr, strlen(integralstr), 1, fd);
                retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
                retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
                retfw = (int) fwrite(") = ", 4, 1, fd);
                retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
                retfw = (int) fwrite(";", 1, 1, fd);
            }
        }
        
        retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].t0);
        retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
        retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(inittimestr, strlen(inittimestr), 1, fd);
        retfw = (int) fwrite(" = ", 3, 1, fd);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        
        retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.phaseinfo[phase].tf);
        retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
        retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
        retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
        retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
        retfw = (int) fwrite(finaltimestr, strlen(finaltimestr), 1, fd);
        retfw = (int) fwrite(" = ", 3, 1, fd);
        retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
        retfw = (int) fwrite(";", 1, 1, fd);
        
//        if (nppG[phase])    // If one or more phase parameter
//        {
//            for (int comp=0; comp<nppG[phase]; comp++)  // For each phase parameter in phase
//            {
//                for (int pt=0; pt<sysinfosolG.phaseinfo[phase].NumPts; pt++)    // For each discretization point in phase
//                {
//                    retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",phaseparameterssolG.parametersStruct[phase].parametersMat[pt].val[comp]);
//                    retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
//                    retfw = (int) fwrite(phasestr, strlen(phasestr), 1, fd);
//                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", phase+1);
//                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
//                    retfw = (int) fwrite(phaseparameterstr, strlen(phaseparameterstr), 1, fd);
//                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
//                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
//                    retfw = (int) fwrite(ptstr, strlen(ptstr), 1, fd);
//                    retint = snprintf(intvalstr, sizeof intvalstr, "%d", pt+1);
//                    retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
//                    retfw = (int) fwrite(") = ", 4, 1, fd);
//                    retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
//                    retfw = (int) fwrite(";", 1, 1, fd);
//                }
//            }
//        }
        
    }
    
    if (nsG)    // If one or more static parameters in problem
    {
        for (int comp=0; comp<nsG; comp++)   // For each integral component in phase
        {
            retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",sysinfosolG.s[comp]);
            retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
            retfw = (int) fwrite(staticstr, strlen(staticstr), 1, fd);
            retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
            retfw = (int) fwrite(") = ", 4, 1, fd);
            retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
            retfw = (int) fwrite(";", 1, 1, fd);
        }
    }
    
//    if (nepG)   // If one or more endpoint parameters in problem
//    {
//        for (int comp=0; comp<nepG; comp++)   // For each integral component in phase
//        {
//            retdub = snprintf(dubvalstr, sizeof dubvalstr, "%.25e",endpointparameterssolG.val[comp]);
//            retfw = (int) fwrite(systemstr, strlen(systemstr), 1, fd);
//            retfw = (int) fwrite(endpointparameterstr, strlen(endpointparameterstr), 1, fd);
//            retint = snprintf(intvalstr, sizeof intvalstr, "%d", comp+1);
//            retfw = (int) fwrite(intvalstr, strlen(intvalstr), 1, fd);
//            retfw = (int) fwrite(") = ", 4, 1, fd);
//            retfw = (int) fwrite(dubvalstr, strlen(dubvalstr), 1, fd);
//            retfw = (int) fwrite(";", 1, 1, fd);
//        }
//    }
    
//    printf("\n Number of bytes written: %d\n",retfw);
    
    if(SIZE*NUMELEM != retfw)
    {
        printf("\n fwrite() failed\n");
    }
    else
    {
//        printf("\n fwrite() successful, data written to text file\n");
    }
    
    
    fclose(fd);
//    printf("\n File stream closed through fclose()\n");
    
    printf4BIN(newFileNameBin,sysinfosolG);
    
    if (TempFlag==1)
    {
        sysinfowarmG = sysinfosolG;
        sysinfosolG = sysinfodomainG;
    }
}

void ViewParameterMappings(void)    // View mappings of phase and endpoint parameters
{
    
    for (int p=0; p<PG; p++)    // For each phase in problem
    {
        //        printf("\nPhaseParameterDependenciesG[%d] = ",p);
        //        printf(PhaseParameterDependenciesG[p]); // Check phase parameter dependencies on each other: Appears to be good
        //        printf("\nStatePhaseDependenciesG[%d] = ",p);
        //        printf(StatePhaseDependenciesG[p]); // Check phase parameter dependencies on state: Appears to be good
        //        printf("\nControlPhaseDependenciesG[%d] = ",p);
        //        printf(ControlPhaseDependenciesG[p]);   // Check phase parameter dependencies on control: Appears to be good
        //        printf("\nStaticPhaseDependenciesG[%d] = ",p);
        //        printf(StaticPhaseDependenciesG[p]);    // Check phase parameter dependencies on static parameters: Appears to be good
        //        printf("\nTimePhaseDependenciesG[%d] = ",p);
        //        printf(TimePhaseDependenciesG[p]);  // Check phase parameter dependencies on time: Appears to be good
        //        printf("\nDynamicPhaseDependenciesG[%d] = ",p);
        //
        //        printf(DynamicPhaseDependenciesG[p]);   // Check dynamic function dependencies on phase parameters: Appears to be good
        //        printf("\nPathPhaseDependenciesG[%d] = ",p);
        //        printf(PathPhaseDependenciesG[p]);  // Check path function dependencies on phase parameters: Appears to be good
        //        printf("\nLagrangePhaseDependenciesG[%d] = ",p);
        //        printf(LagrangePhaseDependenciesG[p]);  // Check lagrange function dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseDynamicTimeDependMapG[%d] = ",p);
        //
        //        printf(PhaseDynamicTimeDependMapG[p]);  // Check dynamic function and time dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseDynamicStateDependMapG[%d] = ",p);
        //        printf(PhaseDynamicStateDependMapG[p]); // Check dynamic function and state dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseDynamicControlDependMapG[%d] = ",p);
        //        printf(PhaseDynamicControlDependMapG[p]);   // Check dynamic function and control dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseDynamicStaticDependMapG[%d] = ",p);
        //        printf(PhaseDynamicStaticDependMapG[p]);    // Check dynamic function and static parameter dependencies on phase parameters: Appears to be good
        //
        //        printf("\nPhasePathTimeDependMapG[%d] = ",p);
        //        printf(PhasePathTimeDependMapG[p]); // Check path function and time dependencies on phase parameters: Appears to be good
        //        printf("\nPhasePathStateDependMapG[%d] = ",p);
        //        printf(PhasePathStateDependMapG[p]);    // Check path function and state dependencies on phase parameters: Appears to be good
        //        printf("\nPhasePathControlDependMapG[%d] = ",p);
        //        printf(PhasePathControlDependMapG[p]);  // Check path function and control dependencies on phase parameters: Appears to be good
        //        printf("\nPhasePathStaticDependMapG[%d] = ",p);
        //        printf(PhasePathStaticDependMapG[p]);   // Check path function and static parameter dependencies on phase parameters: Appears to be good
        //
        //        printf("\nPhaseLagrangeTimeDependMapG[%d] = ",p);
        //        printf(PhaseLagrangeTimeDependMapG[p]); // Check lagrange function and time dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseLagrangeStateDependMapG[%d] = ",p);
        //        printf(PhaseLagrangeStateDependMapG[p]);    // Check lagrange function and state dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseLagrangeControlDependMapG[%d] = ",p);
        //        printf(PhaseLagrangeControlDependMapG[p]);  // Check lagrange function and control dependencies on phase parameters: Appears to be good
        //        printf("\nPhaseLagrangeStaticDependMapG[%d] = ",p);
        //        printf(PhaseLagrangeStaticDependMapG[p]);   // Check lagrange function and static parameter dependencies on phase parameters: Appears to be good
        //
        //        printf("\nInitStateEndpointDependenciesG[%d] = ",p);
        //        printf(InitStateEndpointDependenciesG[p]);   // Check endpoint parameter dependencies on initial state: Appears to be good
        //        printf("\nFinalStateEndpointDependenciesG[%d] = ",p);
        //        printf(FinalStateEndpointDependenciesG[p]); // Check endpoint parameter dependencies on final state: Appears to be good
        //        printf("\nIntegralEndpointDependenciesG[%d] = ",p);
        //        printf(IntegralEndpointDependenciesG[p]);   // Check endpoint parameter dependencies on integrals: Appears to be good
        //        printf("\nInitTimeEndpointDependenciesG[%d] = ",p);
        //        printf(InitTimeEndpointDependenciesG[p]);   // Check endpoint parameter dependencies on initial time: Appears to be good
        //        printf("\nFinalTimeEndpointDependenciesG[%d] = ",p);
        //        printf(FinalTimeEndpointDependenciesG[p]);   // Check endpoint parameter dependencies on final time: Appears to be good
        //
        //        printf("\nEndpointEventInitStateDependMapG[%d] = ",p);
        //        printf(EndpointEventInitStateDependMapG[p]);    // Check event fuction and initial state dependencies on endpoint parameters: Appears to be good
        //        printf("\nEndpointEventFinalStateDependMapG[%d] = ",p);
        //        printf(EndpointEventFinalStateDependMapG[p]);   // Check event fuction and final state dependencies on endpoint parameters: Appears to be good
        //        printf("\nEndpointEventIntegralDependMapG[%d] = ",p);
        //        printf(EndpointEventIntegralDependMapG[p]);     // Check event fuction and integral dependencies on endpoint parameters: Appears to be good
        //        printf("\nEndpointEventInitTimeDependMapG[%d] = ",p);
        //        printf(EndpointEventInitTimeDependMapG[p]);     // Check event fuction and initial time dependencies on endpoint parameters: Appears to be good
        //        printf("\nEndpointEventFinalTimeDependMapG[%d] = ",p);
        //        printf(EndpointEventFinalTimeDependMapG[p]);    // Check event fuction and final time dependencies on endpoint parameters: Appears to be good
    }
    //    printf("\nEndpointParameterDependenciesG = ");
    //    printf(EndpointParameterDependenciesG); // Check endpoint parameter dependencies on each other: Appears to be good
    
    //    printf("\nStaticEndpointDependenciesG = ");
    //    printf(StaticEndpointDependenciesG);    // Check endpoint parameter dependencies on static parameters: Appears to be good
    
    //    printf("\nObjectiveEndpointDependenciesG = ");
    //    printf(ObjectiveEndpointDependenciesG); // Check objective fuction dependencies on endpoint parameters: Appears to be good
    
    //    printf("\nEndpointObjectiveInitStateDependMapG = ");
    //    printf(EndpointObjectiveInitStateDependMapG); // Check objective fuction and initial state dependencies on endpoint parameters: Appears to be good
    //    printf("\nEndpointObjectiveFinalStateDependMapG = ");
    //    printf(EndpointObjectiveFinalStateDependMapG);  // Check objective fuction and final state dependencies on endpoint parameters: Appears to be good
    //    printf("\nEndpointObjectiveIntegralDependMapG = ");
    //    printf(EndpointObjectiveIntegralDependMapG); // Check objective fuction and integral dependencies on endpoint parameters: Appears to be good
    //    printf("\nEndpointObjectiveInitTimeDependMapG = ");
    //    printf(EndpointObjectiveInitTimeDependMapG); // Check objective fuction and initial time dependencies on endpoint parameters: Appears to be good
    //    printf("\nEndpointObjectiveFinalTimeDependMapG = ");
    //    printf(EndpointObjectiveFinalTimeDependMapG); // Check objective fuction and final time dependencies on endpoint parameters: Appears to be good
    //    printf("\nEndpointObjectiveStaticDependMapG = ");
    //    printf(EndpointObjectiveStaticDependMapG);  // Check objective fuction and static parameter dependencies on endpoint parameters: Appears to be good
    //
    //    printf("\nEventEndpointDependenciesG = ");
    //    printf(EventEndpointDependenciesG); // Check event fuction dependencies on endpoint parameters: Appears to be good
    
    //    printf("\nEndpointEventStaticDependMapG = ");
    //    printf(EndpointEventStaticDependMapG);  // Check event fuction and static parameter dependencies on endpoint parameters: Appears to be good
}

void ViewPhaseFunctionOutputs(void) // View outputs of functions in each phase of problem
{
    doubleMatMat ret_val(PG);
    for (int phase=0; phase<PG; phase++)
    {
        ret_val.mat[phase] = getDoubleMat(NtG[phase]+1);
    }
    
    //    sysinfoG = sysinfosolG;
    
    ComputeParameters(sysinfoG,phaseparametersG,endpointparametersG);
    
    if (derivativeSupplierG==0)
    {
        for (int phase=0; phase<PG; phase++)
        {
            if (nxG[phase]>0)
            {
                for (int comp=0; comp<nxG[phase]; comp++)
                {
                    dyn_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\ndyn_valHD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (ncG[phase]>0)
            {
                for (int comp=0; comp<ncG[phase]; comp++)
                {
                    path_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\npath_valHD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (nqG[phase]>0)
            {
                for (int comp=0; comp<nqG[phase]; comp++)
                {
                    lag_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\nlag_valHD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
        }
    }
    else if (derivativeSupplierG==1)
    {
        for (int phase=0; phase<PG; phase++)
        {
            if (nxG[phase]>0)
            {
                for (int comp=0; comp<nxG[phase]; comp++)
                {
                    dyn_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\ndyn_valBC.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (ncG[phase]>0)
            {
                for (int comp=0; comp<ncG[phase]; comp++)
                {
                    path_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\npath_valBC.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (nqG[phase]>0)
            {
                for (int comp=0; comp<nqG[phase]; comp++)
                {
                    lag_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\nlag_valBC.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
        }
    }
    else if (derivativeSupplierG==2)
    {
        for (int phase=0; phase<PG; phase++)
        {
            if (nxG[phase]>0)
            {
                for (int comp=0; comp<nxG[phase]; comp++)
                {
                    dyn_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\ndyn_valCD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (ncG[phase]>0)
            {
                for (int comp=0; comp<ncG[phase]; comp++)
                {
                    path_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\npath_valCD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (nqG[phase]>0)
            {
                for (int comp=0; comp<nqG[phase]; comp++)
                {
                    lag_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\nlag_valCD.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
        }
    }
    else if (derivativeSupplierG==3)
    {
        for (int phase=0; phase<PG; phase++)
        {
            if (nxG[phase]>0)
            {
                for (int comp=0; comp<nxG[phase]; comp++)
                {
                    dyn_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\ndyn_valCN.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (ncG[phase]>0)
            {
                for (int comp=0; comp<ncG[phase]; comp++)
                {
                    path_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\npath_valCN.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
            if (nqG[phase]>0)
            {
                for (int comp=0; comp<nqG[phase]; comp++)
                {
                    lag_func(PhaseSwitchG.val[phase],comp,sysinfoG.phaseinfo[phase],sysinfoG.s,phaseparametersG.parametersStruct[phase],ret_val.mat[phase]);
                    for (int pt=0; pt<ret_val.mat[phase].Len; pt++)
                    {
                        printf("\nlag_valCN.phase(%d).comp(%d).point(%d) = %.25f;",phase+1,comp+1,pt+1,ret_val.mat[phase].val[pt]);
                    }
                }
            }
        }
    }
}

void GetHere(void)
{
    printf("\nGET HERE!!!");
    printf("\nGET HERE!!!");
    printf("\nGET HERE!!!\n");
}

void printf4BIN(const char* strFile, const systemInfo& sourceObj)
{
    
    int size;
    
    std::ofstream binaryFileWrite;
    
    binaryFileWrite.open(strFile, std::ios::out| std::ios::binary); // opens file
    binaryFileWrite.write ((char*)&sourceObj.NumP, sizeof(sourceObj.NumP));
    binaryFileWrite.write ((char*)&sourceObj.NumS, sizeof(sourceObj.NumS));
    for (int phase=0; phase<sourceObj.NumP; phase++)
    {
        binaryFileWrite.write ((char*)&sourceObj.NumX[phase], sizeof(sourceObj.NumX[phase]));
    }
    for (int phase=0; phase<sourceObj.NumP; phase++)
    {
        binaryFileWrite.write ((char*)&sourceObj.NumU[phase], sizeof(sourceObj.NumU[phase]));
    }
    for (int phase=0; phase<sourceObj.NumP; phase++)
    {
        binaryFileWrite.write ((char*)&sourceObj.NumQ[phase], sizeof(sourceObj.NumQ[phase]));
    }
    for (int phase=0; phase<sourceObj.NumP; phase++)
    {
        binaryFileWrite.write ((char*)&sourceObj.NumColPts[phase], sizeof(sourceObj.NumColPts[phase]));
    }
    
    for (int phase=0; phase<sourceObj.NumP; phase++)
    {
        for (int comp=0; comp<sourceObj.NumX[phase]; comp++)
        {
            for (int pt=0; pt<sourceObj.NumColPts[phase]+1; pt++)
            {
                binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].ptInfo[pt].x[comp], sizeof(sourceObj.phaseinfo[phase].ptInfo[pt].x[comp]));
            }
        }
        for (int comp=0; comp<sourceObj.NumU[phase]; comp++)
        {
            for (int pt=0; pt<sourceObj.NumColPts[phase]+1; pt++)
            {
                binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].ptInfo[pt].u[comp], sizeof(sourceObj.phaseinfo[phase].ptInfo[pt].u[comp]));
            }
        }
        for (int comp=0; comp<sourceObj.NumX[phase]; comp++)
        {
            for (int pt=0; pt<sourceObj.NumColPts[phase]+1; pt++)
            {
                binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].ptInfo[pt].lam[comp], sizeof(sourceObj.phaseinfo[phase].ptInfo[pt].lam[comp]));
            }
        }
        for (int pt=0; pt<sourceObj.NumColPts[phase]+1; pt++)
        {
            binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].ptInfo[pt].tau, sizeof(sourceObj.phaseinfo[phase].ptInfo[pt].tau));
        }
        for (int pt=0; pt<sourceObj.NumColPts[phase]+1; pt++)
        {
            binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].ptInfo[pt].t, sizeof(sourceObj.phaseinfo[phase].ptInfo[pt].t));
        }
        for (int comp=0; comp<sourceObj.NumQ[phase]; comp++)
        {
            binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].q[comp], sizeof(sourceObj.phaseinfo[phase].q[comp]));
        }
        for (int comp=0; comp<sourceObj.NumX[phase]; comp++)
        {
            binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].x0[comp], sizeof(sourceObj.phaseinfo[phase].x0[comp]));
        }
        for (int comp=0; comp<sourceObj.NumX[phase]; comp++)
        {
            binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].xf[comp], sizeof(sourceObj.phaseinfo[phase].xf[comp]));
        }
        binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].t0, sizeof(sourceObj.phaseinfo[phase].t0));
        binaryFileWrite.write ((char*)&sourceObj.phaseinfo[phase].tf, sizeof(sourceObj.phaseinfo[phase].tf));
    }
    for (int comp=0; comp<sourceObj.NumS; comp++)
    {
        binaryFileWrite.write ((char*)&sourceObj.s[comp], sizeof(sourceObj.s[comp]));
    }
    
    binaryFileWrite.close();
}

systemInfo scanf4SystemInfoBIN(const char* strFile)
{
    int size;
    std::ifstream binaryFileRead;
    
    int NumP, NumS;
    char charretint[4];
    char charretdub[8];
    
    binaryFileRead.open(strFile, std::ios::in| std::ios::binary); // opens file
    binaryFileRead.seekg(0,std::ios::end);      // Seeks to end of file
    size = (int) binaryFileRead.tellg();        // Tells size of binary file
//    printf("\nsize = %d",size);
    binaryFileRead.seekg(0,std::ios::beg);      // Seeks to beginning of file
    for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
    {
        binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
    }
    NumP = CharArraytoIntC(charretint);
    for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
    {
        binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
    }
    NumS = CharArraytoIntC(charretint);
    
    int NumX[NumP];
    int NumU[NumP];
    int NumQ[NumP];
    int NumColPts[NumP];
    
    for (int phase=0; phase<NumP; phase++)
    {
        for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
        {
            binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
        }
        NumX[phase] = CharArraytoIntC(charretint);
    }
    
    for (int phase=0; phase<NumP; phase++)
    {
        for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
        {
            binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
        }
        NumU[phase] = CharArraytoIntC(charretint);
    }
    
    for (int phase=0; phase<NumP; phase++)
    {
        for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
        {
            binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
        }
        NumQ[phase] = CharArraytoIntC(charretint);
    }
    
    for (int phase=0; phase<NumP; phase++)
    {
        for (int bytenum=0; bytenum<4; bytenum++)   // For each byte in signed integer type
        {
            binaryFileRead.read(&charretint[bytenum],sizeof(charretint[bytenum]));
        }
        NumColPts[phase] = CharArraytoIntC(charretint);
    }
    
    systemInfo sysinforead(NumP,NumS,NumX,NumU,NumQ,NumColPts);
    
    for (int phase=0; phase<NumP; phase++)
    {
        for (int comp=0; comp<NumX[phase]; comp++)
        {
            for (int pt=0; pt<NumColPts[phase]+1; pt++)
            {
                for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
                {
                    binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
                }
                sysinforead.phaseinfo[phase].ptInfo[pt].x[comp] = CharArraytoDoubleC(charretdub);
            }
        }
        for (int comp=0; comp<NumU[phase]; comp++)
        {
            for (int pt=0; pt<NumColPts[phase]+1; pt++)
            {
                for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
                {
                    binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
                }
                sysinforead.phaseinfo[phase].ptInfo[pt].u[comp] = CharArraytoDoubleC(charretdub);
            }
        }
        for (int comp=0; comp<NumX[phase]; comp++)
        {
            for (int pt=0; pt<NumColPts[phase]+1; pt++)
            {
                for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
                {
                    binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
                }
                sysinforead.phaseinfo[phase].ptInfo[pt].lam[comp] = CharArraytoDoubleC(charretdub);
            }
        }
        for (int pt=0; pt<NumColPts[phase]+1; pt++)
        {
            for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
            {
                binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
            }
            sysinforead.phaseinfo[phase].ptInfo[pt].tau = CharArraytoDoubleC(charretdub);
        }
        for (int pt=0; pt<NumColPts[phase]+1; pt++)
        {
            for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
            {
                binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
            }
            sysinforead.phaseinfo[phase].ptInfo[pt].t = CharArraytoDoubleC(charretdub);
        }
        for (int comp=0; comp<NumQ[phase]; comp++)
        {
            for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
            {
                binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
            }
            sysinforead.phaseinfo[phase].q[comp] = CharArraytoDoubleC(charretdub);
        }
        for (int comp=0; comp<NumX[phase]; comp++)
        {
            for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
            {
                binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
            }
            sysinforead.phaseinfo[phase].x0[comp] = CharArraytoDoubleC(charretdub);
        }
        for (int comp=0; comp<NumX[phase]; comp++)
        {
            for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
            {
                binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
            }
            sysinforead.phaseinfo[phase].xf[comp] = CharArraytoDoubleC(charretdub);
        }
        for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
        {
            binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
        }
        sysinforead.phaseinfo[phase].t0 = CharArraytoDoubleC(charretdub);
        for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
        {
            binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
        }
        sysinforead.phaseinfo[phase].tf = CharArraytoDoubleC(charretdub);
    }
    for (int comp=0; comp<NumS; comp++)
    {
        for (int bytenum=0; bytenum<8; bytenum++)   // For each byte in double precision type
        {
            binaryFileRead.read(&charretdub[bytenum],sizeof(charretdub[bytenum]));
        }
        sysinforead.s[comp] = CharArraytoDoubleC(charretdub);
    }
    
    binaryFileRead.close();
    
    return sysinforead;
}

////////////////////////////////////////////////////////////////////////////////////////////////
//-----------------------------------------LGR functions--------------------------------------//
////////////////////////////////////////////////////////////////////////////////////////////////
LGR PointsWeightsLGRD(int N)
{
    LGR lgrstruc(N,0);
//    int k,l;
//    int Nm1;
//    double *tau = new double[N], *weights = new double[N];
//    double *P = new double[N*(N+1)];
//    int *Nindex = new int[N-1];
//    double *xold = new double[N];
//    int *overTol = new int[N];
//    int overTolsum = 0;
//    int iter=0;
//    int *DoffdiagI = new int[N*N], *DoffdiagJ = new int[N*N];
//    int *DdiagI = new int[N], *DdiagJ = new int[N];
//    double *DoffdiagVal = new double[N*N], *DdiagVal = new double[N];
//    int indexOff, index;
//    double *xxPlusEnd = new double[N+1];
//    int M = N+1, M2 = M*M;
//    double *Y = new double[(N+1)*(N+1)], *YT = new double[(N+1)*(N+1)];
//    double *IM = new double[(N+1)*(N+1)], *Ydiff = new double[(N+1)*(N+1)];
//    double *Ydcp = new double[M];
//    double *WW = new double[M2], *WWT = new double[M2];
//    double *negDT = new double[M2], *D = new double[M2];
//    double *oneMinusDcolsum = new double[M];
//
//    lgrstruc.setN(N);
//
//    Nm1 = N-1;
//    for (k=0; k<Nm1; k++)
//    {
//        Nindex[k] = k+1;
//    }
//
//    for (k=0; k<N; k++)
//    {
//        tau[k] = -cos(2*M_PI*k/(2*Nm1+1));
//        xold[k] = 2;
//    }
//
//    for (k=0; k<N*(N+1); k++)
//    {
//        P[k] = 0;
//    }
//
//    for (k=0; k<N; k++)
//    {
//        if (fabs(tau[k]-xold[k])>DBL_EPSILON)
//        {
//            overTol[k] = 1;
//        }
//        else
//        {
//            overTol[k] = 0;
//        }
//        overTolsum += overTol[k];
//    }
//
//    // while loop starts here
//    while (overTolsum && iter<1000)
//    {
//        iter++;
//        for (k=0; k<N; k++)
//        {
//            xold[k] = tau[k];
//        }
//
//        for (k=0; k<N+1; k++)
//        {
//            P[k] = 1;
//            for (l=0; l<k; l++)
//            {
//                P[k] = -1*P[k];
//            }
//        }
//
//        for (k=0; k<Nm1; k++)
//        {
//            P[(N+1)*Nindex[k]] = 1;
//            P[(N+1)*Nindex[k]+1] = tau[k+1];
//        }
//
//
//        // for loop in while loop starts here
//
//
//        for (k=2; k<N+1; k++)
//        {
//            for (l=0; l<Nm1; l++)
//            {
//                P[(N+1)*Nindex[l]+k] = ( (2*k-1)*tau[Nindex[l]]*P[(N+1)*Nindex[l]+k-1] - (k-1)*P[(N+1)*Nindex[l]+k-2] )/k;
//            }
//        }
//
//        // for loop in while loop ends here
//        for (k=0; k<Nm1; k++)
//        {
//            tau[Nindex[k]] = xold[Nindex[k]] - ( (1-xold[Nindex[k]])/N )*(P[(N+1)*Nindex[k]+Nm1]+P[(N+1)*Nindex[k]+N])/(P[(N+1)*Nindex[k]+Nm1]-P[(N+1)*Nindex[k]+N]);
//        }
//
//        overTolsum = 0;
//        for (k=0; k<N; k++)
//        {
//            if (fabs(tau[k]-xold[k])>DBL_EPSILON)
//            {
//                overTol[k] = 1;
//            }
//            else
//            {
//                overTol[k] = 0;
//            }
//            overTolsum += overTol[k];
//        }
//    }
//    // while loop ends here
//
//    lgrstruc.setTau(tau);
//
//    weights[0] = 2.0/(N*N);
//    for (k=0; k<Nm1; k++)
//    {
//        weights[Nindex[k]] = (1-tau[Nindex[k]])/((N*P[(N+1)*Nindex[k]+Nm1])*(N*P[(N+1)*Nindex[k]+Nm1]));
//    }
//
//    lgrstruc.setWeights(weights);
//
//    indexOff = 0;
//    index = 0;
//    for (k=0; k<N; k++)
//    {
//        for (l=0; l<(N+1); l++)
//        {
//            if (k!=l)
//            {
//                DoffdiagI[indexOff] = k;
//                DoffdiagJ[indexOff] = l;
//                indexOff++;
//            }
//            else
//            {
//                DdiagI[index] = k;
//                DdiagJ[index] = l;
//                index++;
//            }
//        }
//    }
//
//    lgrstruc.setDoffdiagI(DoffdiagI);
//    lgrstruc.setDoffdiagJ(DoffdiagJ);
//    lgrstruc.setDdiagI(DdiagI);
//    lgrstruc.setDdiagJ(DdiagJ);
//
//
//    for (k=0; k<N; k++)
//    {
//        xxPlusEnd[k] = tau[k];
//    }
//    xxPlusEnd[N] = 1.0;
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            Y[M*k+l] = xxPlusEnd[k];
//            YT[M*l+k] = xxPlusEnd[k];
//            if (l == k)
//            {
//                IM[M*k+l] = 1;
//            }
//            else
//            {
//                IM[M*k+l] = 0;
//            }
//        }
//    }
//
//    for (k=0; k<M2; k++)
//    {
//        Ydiff[k] = Y[k] - YT[k] + IM[k];
//    }
//
//    for (k=0; k<M; k++)
//    {
//        Ydcp[k] = 1.0;
//    }
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            Ydcp[k] = Ydcp[k]*Ydiff[M*l+k];
//        }
//    }
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            WW[k*M+l] = 1/Ydcp[k];
//            WWT[l*M+k] = 1/Ydcp[k];
//        }
//    }
//
//    for (k=0; k<M2; k++)
//    {
//        negDT[k] = WW[k]/(WWT[k]*Ydiff[k]);
//    }
//
//    for (k=0; k<M; k++)
//    {
//        oneMinusDcolsum[k] = 1.0;
//    }
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            oneMinusDcolsum[k] = oneMinusDcolsum[k] - negDT[M*l+k];
//        }
//    }
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            if (l==k)
//            {
//                negDT[M*k+l] = oneMinusDcolsum[k];
//            }
//        }
//    }
//
//    for (k=0; k<M; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            D[M*l+k] = -negDT[M*k+l];
//        }
//    }
//
//    indexOff = 0;
//    index = 0;
//    for (k=0; k<N; k++)
//    {
//        for (l=0; l<M; l++)
//        {
//            if (k == l)
//            {
//                DdiagVal[index] = D[M*k+l];
//                //                printf("\nDdiagVal[%d,%d] = %.15f",k,l,D[M*k+l]);
//                index++;
//            }
//            else
//            {
//                DoffdiagVal[indexOff] = D[M*k+l];
//                //                printf("\nDoffdiagVal[%d,%d] = %.15f",k,l,D[M*k+l]);
//                indexOff++;
//            }
//        }
//    }
//
//    lgrstruc.setDoffdiagVal(DoffdiagVal);
//    lgrstruc.setDdiagVal(DdiagVal);
//    lgrstruc.setD(D);
//
//    double *D2_N = new double[N*N];
//    for (k=0; k<N; k++)
//    {
//        for (l=0; l<N; l++)
//        {
//            D2_N[k*N+l] = D[k*M + l + 1];
//        }
//    }
//
//    int rows = N, cols = N;
//    CMatrix dmat("Dmat", rows, cols);
//    dmat.FillMatrix(D2_N);
//    CMatrix dmatinv = dmat.Inverse();
//    //    std::cout << dmat;
//    //    std::cout << dmatinv;
//    //    CMatrix unit = (dmat * dmatinv);
//    //    unit.SetName("A * A-Inv");
//    //    std::cout << unit;
//
//    double *Emat;
//    int *Erows = new int[N*N], *Ecols = new int[N*N];
//    double *Evals = new double[N*N];
//    Emat = dmatinv.Vectorize();
//    for (k=0; k<N; k++)
//    {
//        for (l=0; l<N; l++)
//        {
//            //            printf("\nEmat[%d][%d] = %.15f",k,l,Emat[k*N+l]);
//            Erows[k*N+l] = k;
//            Ecols[k*N+l] = l;
//            Evals[k*N+l] = Emat[k*N+l];
//        }
//    }
//    lgrstruc.setEmat(Emat);
//    lgrstruc.setErows(Erows);
//    lgrstruc.setEcols(Ecols);
//    lgrstruc.setEvals(Evals);
//
//    int *Frow = new int[N], *Fcol = new int[N];
//    double *Fval = new double[N];
//    for (k=0; k<N; k++)
//    {
//        Frow[k] = k;
//        Fcol[k] = 0;
//        Fval[k] = 1;
//    }
//    lgrstruc.setFrow(Frow);
//    lgrstruc.setFcol(Fcol);
//    lgrstruc.setFval(Fval);
    
    return lgrstruc;
}












